
// Generated from g4files/SPECTREParser.g4 by ANTLR 4.13.2


#include "SPECTREParserListener.h"
#include "SPECTREParserVisitor.h"

#include "SPECTREParser.h"


using namespace antlrcpp;
using namespace edacurry;

using namespace antlr4;

namespace {

struct SPECTREParserStaticData final {
  SPECTREParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  SPECTREParserStaticData(const SPECTREParserStaticData&) = delete;
  SPECTREParserStaticData(SPECTREParserStaticData&&) = delete;
  SPECTREParserStaticData& operator=(const SPECTREParserStaticData&) = delete;
  SPECTREParserStaticData& operator=(SPECTREParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag spectreparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<SPECTREParserStaticData> spectreparserParserStaticData = nullptr;

void spectreparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (spectreparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(spectreparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<SPECTREParserStaticData>(
    std::vector<std::string>{
      "netlist", "netlist_title", "netlist_entity", "include", "standard_include", 
      "cpp_include", "ahdl_include", "lang", "library", "library_header", 
      "library_content", "library_footer", "section", "section_header", 
      "section_content", "section_footer", "analogmodel", "subckt", "subckt_header", 
      "subckt_content", "subckt_footer", "if_statement", "if_alternative", 
      "if_body", "analysis", "ac", "acmatch", "dc", "dcmatch", "envlp", 
      "sp", "stb", "sweep", "sweep_header", "sweep_content", "sweep_footer", 
      "tdr", "tran", "xf", "pac", "pdisto", "pnoise", "psp", "pss", "pxf", 
      "pz", "qpac", "qpnoise", "qpsp", "qpss", "qpxf", "sens", "sens_output_variables_list", 
      "sens_design_parameters_list", "sens_analyses_list", "montecarlo", 
      "montecarlo_header", "montecarlo_content", "montecarlo_export", "montecarlo_footer", 
      "noise", "checklimit", "global", "model", "model_name", "model_master", 
      "control", "alter", "altergroup", "altergroup_header", "altergroup_content", 
      "altergroup_footer", "assert_statement", "check_statement", "save", 
      "option", "set", "shell", "info", "nodeset", "ic", "statistics", "statistics_header", 
      "statistics_content", "statistics_footer", "process", "mismatch", 
      "correlate", "truncate", "vary", "reliability", "reliability_header", 
      "reliability_content", "reliability_footer", "reliability_control", 
      "global_declarations", "component", "component_id", "component_master", 
      "component_attribute", "component_value", "component_value_list", 
      "component_analysis", "node_list", "node_list_item", "node_mapping", 
      "node_pair", "node_branch", "node", "expression", "expression_unary", 
      "expression_function_call", "expression_pair", "expression_scope", 
      "expression_operator", "expression_atom", "parameter_list", "parameter_list_item", 
      "parameter_assign", "parameter_id", "parameter_access", "value_access", 
      "value_access_assign", "time_pair", "time_point", "filepath", "filepath_element", 
      "keyword", "analysis_type", "component_type"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'='", 
      "'!'", "'<'", "'>'", "", "", "", "", "", "", "", "", "", "", "", "", 
      "'and'", "'or'", "':'", "';'", "'+'", "'-'", "'*'", "'('", "')'", 
      "'['", "']'", "'{'", "'}'", "'\\u003F'", "','", "'$'", "'&'", "'.'", 
      "'_'", "'@'", "'#'", "'\\'", "'/'", "'''", "'\"'", "'|'", "'%'", "'^'", 
      "'~'"
    },
    std::vector<std::string>{
      "", "COMMENT", "GLOBAL", "INCLUDE", "CPP_INCLUDE", "AHDL_INCLUDE", 
      "LIBRARY", "LIBRARY_END", "SECTION", "SECTION_END", "SUBCKT", "INLINE_SUBCKT", 
      "SUBCKT_END", "SIMULATOR", "GLOBAL_PARAMETERS", "MODEL", "EXPORT", 
      "SAVE", "ALTER", "ALTERGROUP", "OPTIONS", "SET", "SHELL", "INFO", 
      "NODESET", "IC", "ASSERT", "CHECK", "LANGUAGE", "PORTS", "WAVE", "PWL", 
      "SIN", "SFFM", "PULSE", "COEFFS", "INSENSITIVE", "IF", "ELSE", "PARAMETERS", 
      "ANALOGMODEL", "CHECKPOINT", "SPECTRE", "SPICE", "STATISTICS", "PROCESS", 
      "CORRELATE", "TRUNCATE", "MISMATCH", "VARY", "RELIABILITY", "AC", 
      "ACMATCH", "DC", "DCMATCH", "ENVLP", "SP", "STB", "SWEEP", "TDR", 
      "TRAN", "XF", "PAC", "PDISTO", "PNOISE", "PSP", "PSS", "PXF", "PZ", 
      "QPAC", "QPNOISE", "QPSP", "QPSS", "QPXF", "SENS", "MONTECARLO", "NOISE", 
      "CHECKLIMIT", "A2D", "B3SOIPD", "BJT", "BJT301", "BJT500", "BJT503", 
      "BJT504", "BJT504T", "BSIM1", "BSIM2", "BSIM3", "BSIM3V3", "BSIM4", 
      "BSIMSOI", "BTASOI", "CAPACITOR", "CCCS", "CCVS", "CKTROM", "CORE", 
      "D2A", "DELAY", "DIO500", "DIODE", "EKV", "FOURIER", "GAAS", "HBT", 
      "HISIM", "HVMOS", "INDUCTOR", "INTCAP", "IPROBE", "ISOURCE", "JFET", 
      "JUNCAP", "MISNAN", "MOS0", "MOS1", "MOS1000", "MOS1100", "MOS11010", 
      "MOS11011", "MOS15", "MOS2", "MOS3", "MOS30", "MOS3002", "MOS3100", 
      "MOS40", "MOS705", "MOS902", "MOS903", "MSLINE", "MTLINE", "MUTUAL_INDUCTOR", 
      "NODCAP", "NODE", "NPORT", "PARAMTEST", "PCCCS", "PCCVS", "PHY_RES", 
      "PORT", "PSITFT", "PVCCS", "PVCVS", "QUANTITY", "RDIFF", "RELAY", 
      "RESISTOR", "SCCCS", "SCCVS", "SVCCS", "SVCVS", "SWITCH", "TLINE", 
      "TOM2", "TOM3", "TRANSFORMER", "VBIC", "VCCS", "VCVS", "VSOURCE", 
      "WINDING", "ZCCCS", "ZCCVS", "ZVCCS", "ZVCVS", "BSOURCE", "EQUAL", 
      "EXCLAMATION_MARK", "LESS_THAN", "GREATER_THAN", "LESS_THAN_EQUAL", 
      "GREATER_THAN_EQUAL", "LOGIC_EQUAL", "LOGIC_NOT_EQUAL", "LOGIC_AND", 
      "LOGIC_OR", "LOGIC_BITWISE_AND", "LOGIC_BITWISE_OR", "LOGIC_XOR", 
      "BITWISE_SHIFT_LEFT", "BITWISE_SHIFT_RIGHT", "POWER_OPERATOR", "AND", 
      "OR", "COLON", "SEMICOLON", "PLUS", "MINUS", "STAR", "OPEN_ROUND", 
      "CLOSE_ROUND", "OPEN_SQUARE", "CLOSE_SQUARE", "OPEN_CURLY", "CLOSE_CURLY", 
      "QUESTION_MARK", "COMMA", "DOLLAR", "AMPERSAND", "DOT", "UNDERSCORE", 
      "AT_SIGN", "POUND_SIGN", "BACKSLASH", "SLASH", "APEX", "QUOTES", "PIPE", 
      "PERCENT", "CARET", "TILDE", "ARROW", "PERCENTAGE", "COMPLEX", "NUMBER", 
      "ID", "STRING", "NL", "WS", "CNL"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,221,1887,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,1,0,3,0,262,8,0,1,0,5,0,265,8,0,10,0,12,0,268,9,0,1,
  	0,3,0,271,8,0,1,0,4,0,274,8,0,11,0,12,0,275,1,0,5,0,279,8,0,10,0,12,0,
  	282,9,0,1,0,3,0,285,8,0,1,1,4,1,288,8,1,11,1,12,1,289,1,1,5,1,293,8,1,
  	10,1,12,1,296,9,1,1,1,3,1,299,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
  	1,2,1,2,1,2,1,2,3,2,314,8,2,1,3,1,3,1,3,3,3,319,8,3,1,4,1,4,1,4,3,4,324,
  	8,4,1,4,5,4,327,8,4,10,4,12,4,330,9,4,1,4,3,4,333,8,4,1,5,1,5,1,5,5,5,
  	338,8,5,10,5,12,5,341,9,5,1,5,3,5,344,8,5,1,6,1,6,1,6,3,6,349,8,6,1,6,
  	3,6,352,8,6,1,6,5,6,355,8,6,10,6,12,6,358,9,6,1,6,3,6,361,8,6,1,7,1,7,
  	1,7,1,7,1,7,5,7,368,8,7,10,7,12,7,371,9,7,1,7,3,7,374,8,7,1,7,1,7,1,7,
  	1,7,1,7,1,7,1,7,3,7,383,8,7,1,7,5,7,386,8,7,10,7,12,7,389,9,7,1,7,3,7,
  	392,8,7,3,7,394,8,7,1,8,1,8,4,8,398,8,8,11,8,12,8,399,1,8,1,8,1,9,1,9,
  	1,9,5,9,407,8,9,10,9,12,9,410,9,9,1,9,3,9,413,8,9,1,10,1,10,1,11,1,11,
  	3,11,419,8,11,1,11,5,11,422,8,11,10,11,12,11,425,9,11,1,11,3,11,428,8,
  	11,1,12,1,12,4,12,432,8,12,11,12,12,12,433,1,12,1,12,1,13,1,13,1,13,5,
  	13,441,8,13,10,13,12,13,444,9,13,1,13,3,13,447,8,13,1,14,1,14,1,15,1,
  	15,3,15,453,8,15,1,15,5,15,456,8,15,10,15,12,15,459,9,15,1,15,3,15,462,
  	8,15,1,16,1,16,1,16,1,16,3,16,468,8,16,1,17,1,17,4,17,472,8,17,11,17,
  	12,17,473,1,17,1,17,1,18,1,18,1,18,3,18,481,8,18,1,18,4,18,484,8,18,11,
  	18,12,18,485,1,19,1,19,1,20,1,20,3,20,492,8,20,1,20,5,20,495,8,20,10,
  	20,12,20,498,9,20,1,20,3,20,501,8,20,1,21,1,21,1,21,1,21,3,21,507,8,21,
  	1,22,1,22,1,22,1,23,5,23,513,8,23,10,23,12,23,516,9,23,1,23,1,23,5,23,
  	520,8,23,10,23,12,23,523,9,23,3,23,525,8,23,1,23,1,23,1,23,1,23,1,23,
  	4,23,532,8,23,11,23,12,23,533,1,23,5,23,537,8,23,10,23,12,23,540,9,23,
  	1,23,3,23,543,8,23,1,23,5,23,546,8,23,10,23,12,23,549,9,23,1,23,3,23,
  	552,8,23,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,3,24,582,8,24,1,25,1,25,1,25,3,25,587,8,25,1,25,5,25,590,8,
  	25,10,25,12,25,593,9,25,1,25,3,25,596,8,25,1,26,1,26,1,26,3,26,601,8,
  	26,1,26,3,26,604,8,26,1,26,5,26,607,8,26,10,26,12,26,610,9,26,1,26,3,
  	26,613,8,26,1,27,1,27,1,27,3,27,618,8,27,1,27,5,27,621,8,27,10,27,12,
  	27,624,9,27,1,27,3,27,627,8,27,1,28,1,28,3,28,631,8,28,1,28,1,28,3,28,
  	635,8,28,1,28,5,28,638,8,28,10,28,12,28,641,9,28,1,28,3,28,644,8,28,1,
  	29,1,29,3,29,648,8,29,1,29,1,29,3,29,652,8,29,1,29,5,29,655,8,29,10,29,
  	12,29,658,9,29,1,29,3,29,661,8,29,1,30,1,30,1,30,3,30,666,8,30,1,30,5,
  	30,669,8,30,10,30,12,30,672,9,30,1,30,3,30,675,8,30,1,31,1,31,1,31,3,
  	31,680,8,31,1,31,5,31,683,8,31,10,31,12,31,686,9,31,1,31,3,31,689,8,31,
  	1,32,1,32,4,32,693,8,32,11,32,12,32,694,1,32,1,32,1,33,1,33,1,33,5,33,
  	702,8,33,10,33,12,33,705,9,33,1,33,5,33,708,8,33,10,33,12,33,711,9,33,
  	1,33,1,33,5,33,715,8,33,10,33,12,33,718,9,33,1,33,3,33,721,8,33,1,34,
  	1,34,1,35,1,35,5,35,727,8,35,10,35,12,35,730,9,35,1,35,3,35,733,8,35,
  	1,36,1,36,1,36,3,36,738,8,36,1,36,5,36,741,8,36,10,36,12,36,744,9,36,
  	1,36,3,36,747,8,36,1,37,1,37,1,37,3,37,752,8,37,1,37,5,37,755,8,37,10,
  	37,12,37,758,9,37,1,37,3,37,761,8,37,1,38,1,38,3,38,765,8,38,1,38,1,38,
  	3,38,769,8,38,1,38,5,38,772,8,38,10,38,12,38,775,9,38,1,38,3,38,778,8,
  	38,1,39,1,39,3,39,782,8,39,1,39,1,39,3,39,786,8,39,1,39,5,39,789,8,39,
  	10,39,12,39,792,9,39,1,39,3,39,795,8,39,1,40,1,40,3,40,799,8,40,1,40,
  	1,40,3,40,803,8,40,1,40,5,40,806,8,40,10,40,12,40,809,9,40,1,40,3,40,
  	812,8,40,1,41,1,41,3,41,816,8,41,1,41,1,41,3,41,820,8,41,1,41,5,41,823,
  	8,41,10,41,12,41,826,9,41,1,41,3,41,829,8,41,1,42,1,42,1,42,3,42,834,
  	8,42,1,42,5,42,837,8,42,10,42,12,42,840,9,42,1,42,3,42,843,8,42,1,43,
  	1,43,3,43,847,8,43,1,43,1,43,3,43,851,8,43,1,43,5,43,854,8,43,10,43,12,
  	43,857,9,43,1,43,3,43,860,8,43,1,44,1,44,3,44,864,8,44,1,44,1,44,3,44,
  	868,8,44,1,44,5,44,871,8,44,10,44,12,44,874,9,44,1,44,3,44,877,8,44,1,
  	45,1,45,3,45,881,8,45,1,45,1,45,3,45,885,8,45,1,45,5,45,888,8,45,10,45,
  	12,45,891,9,45,1,45,3,45,894,8,45,1,46,1,46,1,46,3,46,899,8,46,1,46,5,
  	46,902,8,46,10,46,12,46,905,9,46,1,46,3,46,908,8,46,1,47,1,47,3,47,912,
  	8,47,1,47,1,47,3,47,916,8,47,1,47,5,47,919,8,47,10,47,12,47,922,9,47,
  	1,47,3,47,925,8,47,1,48,1,48,1,48,3,48,930,8,48,1,48,5,48,933,8,48,10,
  	48,12,48,936,9,48,1,48,3,48,939,8,48,1,49,1,49,3,49,943,8,49,1,49,1,49,
  	3,49,947,8,49,1,49,5,49,950,8,49,10,49,12,49,953,9,49,1,49,3,49,956,8,
  	49,1,50,1,50,3,50,960,8,50,1,50,1,50,3,50,964,8,50,1,50,5,50,967,8,50,
  	10,50,12,50,970,9,50,1,50,3,50,973,8,50,1,51,1,51,3,51,977,8,51,1,51,
  	1,51,3,51,981,8,51,1,51,1,51,3,51,985,8,51,1,51,5,51,988,8,51,10,51,12,
  	51,991,9,51,1,51,3,51,994,8,51,1,52,1,52,4,52,998,8,52,11,52,12,52,999,
  	1,52,1,52,1,53,1,53,4,53,1006,8,53,11,53,12,53,1007,1,53,1,53,1,54,1,
  	54,4,54,1014,8,54,11,54,12,54,1015,1,54,1,54,1,55,1,55,4,55,1022,8,55,
  	11,55,12,55,1023,1,55,1,55,1,55,1,56,1,56,1,56,5,56,1032,8,56,10,56,12,
  	56,1035,9,56,1,56,5,56,1038,8,56,10,56,12,56,1041,9,56,1,56,1,56,5,56,
  	1045,8,56,10,56,12,56,1048,9,56,1,56,3,56,1051,8,56,1,57,1,57,1,58,1,
  	58,1,58,5,58,1058,8,58,10,58,12,58,1061,9,58,1,58,3,58,1064,8,58,1,59,
  	1,59,5,59,1068,8,59,10,59,12,59,1071,9,59,1,59,3,59,1074,8,59,1,60,1,
  	60,3,60,1078,8,60,1,60,1,60,3,60,1082,8,60,1,60,5,60,1085,8,60,10,60,
  	12,60,1088,9,60,1,60,3,60,1091,8,60,1,61,1,61,1,61,3,61,1096,8,61,1,61,
  	5,61,1099,8,61,10,61,12,61,1102,9,61,1,61,3,61,1105,8,61,1,62,1,62,1,
  	62,5,62,1110,8,62,10,62,12,62,1113,9,62,1,62,3,62,1116,8,62,1,63,1,63,
  	1,63,1,63,3,63,1122,8,63,1,63,5,63,1125,8,63,10,63,12,63,1128,9,63,1,
  	63,3,63,1131,8,63,1,64,1,64,1,65,1,65,3,65,1137,8,65,1,66,1,66,1,66,1,
  	66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,1150,8,66,1,67,1,67,1,67,3,
  	67,1155,8,67,1,67,5,67,1158,8,67,10,67,12,67,1161,9,67,1,67,3,67,1164,
  	8,67,1,68,1,68,1,68,4,68,1169,8,68,11,68,12,68,1170,1,68,1,68,1,69,1,
  	69,1,69,5,69,1178,8,69,10,69,12,69,1181,9,69,1,69,1,69,5,69,1185,8,69,
  	10,69,12,69,1188,9,69,1,69,3,69,1191,8,69,1,70,1,70,1,71,1,71,5,71,1197,
  	8,71,10,71,12,71,1200,9,71,1,71,3,71,1203,8,71,1,72,1,72,1,72,1,72,3,
  	72,1209,8,72,1,72,5,72,1212,8,72,10,72,12,72,1215,9,72,1,72,3,72,1218,
  	8,72,1,73,1,73,1,73,1,73,5,73,1224,8,73,10,73,12,73,1227,9,73,1,73,3,
  	73,1230,8,73,1,74,1,74,1,74,3,74,1235,8,74,1,74,5,74,1238,8,74,10,74,
  	12,74,1241,9,74,1,74,3,74,1244,8,74,1,75,1,75,1,75,3,75,1249,8,75,1,75,
  	5,75,1252,8,75,10,75,12,75,1255,9,75,1,75,3,75,1258,8,75,1,76,1,76,1,
  	76,3,76,1263,8,76,1,76,5,76,1266,8,76,10,76,12,76,1269,9,76,1,76,3,76,
  	1272,8,76,1,77,1,77,1,77,3,77,1277,8,77,1,77,5,77,1280,8,77,10,77,12,
  	77,1283,9,77,1,77,3,77,1286,8,77,1,78,1,78,1,78,3,78,1291,8,78,1,78,5,
  	78,1294,8,78,10,78,12,78,1297,9,78,1,78,3,78,1300,8,78,1,79,1,79,3,79,
  	1304,8,79,1,79,1,79,1,79,5,79,1309,8,79,10,79,12,79,1312,9,79,1,79,3,
  	79,1315,8,79,1,80,1,80,3,80,1319,8,80,1,80,5,80,1322,8,80,10,80,12,80,
  	1325,9,80,1,80,3,80,1328,8,80,1,81,1,81,4,81,1332,8,81,11,81,12,81,1333,
  	1,81,1,81,1,82,1,82,5,82,1340,8,82,10,82,12,82,1343,9,82,1,82,1,82,5,
  	82,1347,8,82,10,82,12,82,1350,9,82,1,83,1,83,1,83,1,83,1,83,3,83,1357,
  	8,83,1,84,1,84,5,84,1361,8,84,10,84,12,84,1364,9,84,1,84,3,84,1367,8,
  	84,1,85,1,85,5,85,1371,8,85,10,85,12,85,1374,9,85,1,85,1,85,5,85,1378,
  	8,85,10,85,12,85,1381,9,85,1,85,4,85,1384,8,85,11,85,12,85,1385,1,85,
  	1,85,5,85,1390,8,85,10,85,12,85,1393,9,85,1,85,3,85,1396,8,85,1,86,1,
  	86,5,86,1400,8,86,10,86,12,86,1403,9,86,1,86,1,86,5,86,1407,8,86,10,86,
  	12,86,1410,9,86,1,86,4,86,1413,8,86,11,86,12,86,1414,1,86,1,86,5,86,1419,
  	8,86,10,86,12,86,1422,9,86,1,86,3,86,1425,8,86,1,87,1,87,1,87,1,87,1,
  	87,4,87,1432,8,87,11,87,12,87,1433,1,87,1,87,5,87,1438,8,87,10,87,12,
  	87,1441,9,87,1,87,3,87,1444,8,87,1,87,1,87,1,87,1,87,1,87,4,87,1451,8,
  	87,11,87,12,87,1452,1,87,1,87,4,87,1457,8,87,11,87,12,87,1458,1,87,1,
  	87,5,87,1463,8,87,10,87,12,87,1466,9,87,1,87,3,87,1469,8,87,3,87,1471,
  	8,87,1,88,1,88,1,88,5,88,1476,8,88,10,88,12,88,1479,9,88,1,88,3,88,1482,
  	8,88,1,89,1,89,1,89,3,89,1487,8,89,1,89,5,89,1490,8,89,10,89,12,89,1493,
  	9,89,1,89,3,89,1496,8,89,1,90,1,90,4,90,1500,8,90,11,90,12,90,1501,1,
  	90,1,90,1,91,1,91,1,91,3,91,1509,8,91,1,91,5,91,1512,8,91,10,91,12,91,
  	1515,9,91,1,91,1,91,5,91,1519,8,91,10,91,12,91,1522,9,91,1,92,1,92,3,
  	92,1526,8,92,1,93,1,93,5,93,1530,8,93,10,93,12,93,1533,9,93,1,93,3,93,
  	1536,8,93,1,94,1,94,1,94,5,94,1541,8,94,10,94,12,94,1544,9,94,1,94,3,
  	94,1547,8,94,1,95,1,95,1,95,4,95,1552,8,95,11,95,12,95,1553,1,95,1,95,
  	5,95,1558,8,95,10,95,12,95,1561,9,95,1,95,3,95,1564,8,95,1,95,1,95,4,
  	95,1568,8,95,11,95,12,95,1569,1,95,5,95,1573,8,95,10,95,12,95,1576,9,
  	95,1,95,3,95,1579,8,95,3,95,1581,8,95,1,96,1,96,3,96,1585,8,96,1,96,1,
  	96,5,96,1589,8,96,10,96,12,96,1592,9,96,1,96,5,96,1595,8,96,10,96,12,
  	96,1598,9,96,1,96,3,96,1601,8,96,1,97,1,97,1,98,1,98,3,98,1607,8,98,1,
  	99,1,99,1,99,1,99,3,99,1613,8,99,1,100,3,100,1616,8,100,1,100,1,100,3,
  	100,1620,8,100,1,100,3,100,1623,8,100,1,101,1,101,3,101,1627,8,101,1,
  	101,1,101,4,101,1631,8,101,11,101,12,101,1632,1,101,4,101,1636,8,101,
  	11,101,12,101,1637,3,101,1640,8,101,1,101,1,101,1,101,1,101,3,101,1646,
  	8,101,1,101,1,101,4,101,1650,8,101,11,101,12,101,1651,1,101,4,101,1655,
  	8,101,11,101,12,101,1656,3,101,1659,8,101,1,101,1,101,1,101,1,101,3,101,
  	1665,8,101,1,101,1,101,4,101,1669,8,101,11,101,12,101,1670,1,101,4,101,
  	1674,8,101,11,101,12,101,1675,3,101,1678,8,101,1,101,1,101,3,101,1682,
  	8,101,1,102,1,102,1,102,3,102,1687,8,102,1,102,1,102,1,102,3,102,1692,
  	8,102,3,102,1694,8,102,1,103,4,103,1697,8,103,11,103,12,103,1698,1,103,
  	1,103,4,103,1703,8,103,11,103,12,103,1704,1,103,1,103,3,103,1709,8,103,
  	1,104,1,104,1,104,3,104,1714,8,104,1,105,1,105,1,105,1,105,1,106,1,106,
  	1,106,1,106,1,107,1,107,1,107,1,107,1,108,1,108,1,108,3,108,1731,8,108,
  	1,109,1,109,1,109,1,109,1,109,1,109,3,109,1739,8,109,1,109,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,3,109,1750,8,109,5,109,1752,8,109,
  	10,109,12,109,1755,9,109,1,110,1,110,1,110,1,111,1,111,1,111,1,111,3,
  	111,1764,8,111,4,111,1766,8,111,11,111,12,111,1767,1,111,1,111,1,112,
  	1,112,1,112,1,112,1,113,1,113,1,113,3,113,1779,8,113,4,113,1781,8,113,
  	11,113,12,113,1782,1,113,1,113,1,114,1,114,1,115,1,115,1,115,1,115,1,
  	115,1,115,1,115,1,115,3,115,1797,8,115,1,116,3,116,1800,8,116,1,116,3,
  	116,1803,8,116,1,116,4,116,1806,8,116,11,116,12,116,1807,1,116,3,116,
  	1811,8,116,1,117,1,117,3,117,1815,8,117,1,118,1,118,1,118,1,118,1,118,
  	1,118,1,118,1,118,3,118,1825,8,118,1,119,1,119,3,119,1829,8,119,1,120,
  	1,120,1,120,1,121,3,121,1835,8,121,1,121,1,121,1,121,1,121,3,121,1841,
  	8,121,1,121,1,121,1,122,1,122,1,122,1,122,1,123,1,123,1,123,1,123,1,123,
  	1,123,1,123,1,123,3,123,1857,8,123,1,124,1,124,1,125,1,125,1,126,1,126,
  	1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,
  	1,126,1,126,3,126,1879,8,126,1,127,1,127,1,128,1,128,1,129,1,129,1,129,
  	0,1,218,130,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,
  	42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,
  	88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,
  	126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,
  	162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,
  	198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,
  	234,236,238,240,242,244,246,248,250,252,254,256,258,0,12,1,0,10,11,1,
  	0,30,35,2,0,51,51,53,53,1,0,216,217,1,0,188,189,4,0,191,191,193,193,195,
  	195,207,207,4,0,192,192,194,194,196,196,207,207,4,0,168,183,188,190,206,
  	206,210,211,3,0,8,8,53,53,217,217,1,0,18,50,1,0,51,77,1,0,78,167,2132,
  	0,261,1,0,0,0,2,287,1,0,0,0,4,313,1,0,0,0,6,318,1,0,0,0,8,320,1,0,0,0,
  	10,334,1,0,0,0,12,345,1,0,0,0,14,393,1,0,0,0,16,395,1,0,0,0,18,403,1,
  	0,0,0,20,414,1,0,0,0,22,416,1,0,0,0,24,429,1,0,0,0,26,437,1,0,0,0,28,
  	448,1,0,0,0,30,450,1,0,0,0,32,463,1,0,0,0,34,469,1,0,0,0,36,477,1,0,0,
  	0,38,487,1,0,0,0,40,489,1,0,0,0,42,502,1,0,0,0,44,508,1,0,0,0,46,524,
  	1,0,0,0,48,581,1,0,0,0,50,583,1,0,0,0,52,597,1,0,0,0,54,614,1,0,0,0,56,
  	628,1,0,0,0,58,645,1,0,0,0,60,662,1,0,0,0,62,676,1,0,0,0,64,690,1,0,0,
  	0,66,698,1,0,0,0,68,722,1,0,0,0,70,724,1,0,0,0,72,734,1,0,0,0,74,748,
  	1,0,0,0,76,762,1,0,0,0,78,779,1,0,0,0,80,796,1,0,0,0,82,813,1,0,0,0,84,
  	830,1,0,0,0,86,844,1,0,0,0,88,861,1,0,0,0,90,878,1,0,0,0,92,895,1,0,0,
  	0,94,909,1,0,0,0,96,926,1,0,0,0,98,940,1,0,0,0,100,957,1,0,0,0,102,974,
  	1,0,0,0,104,995,1,0,0,0,106,1003,1,0,0,0,108,1011,1,0,0,0,110,1019,1,
  	0,0,0,112,1028,1,0,0,0,114,1052,1,0,0,0,116,1054,1,0,0,0,118,1065,1,0,
  	0,0,120,1075,1,0,0,0,122,1092,1,0,0,0,124,1106,1,0,0,0,126,1117,1,0,0,
  	0,128,1132,1,0,0,0,130,1136,1,0,0,0,132,1149,1,0,0,0,134,1151,1,0,0,0,
  	136,1165,1,0,0,0,138,1174,1,0,0,0,140,1192,1,0,0,0,142,1194,1,0,0,0,144,
  	1204,1,0,0,0,146,1219,1,0,0,0,148,1231,1,0,0,0,150,1245,1,0,0,0,152,1259,
  	1,0,0,0,154,1273,1,0,0,0,156,1287,1,0,0,0,158,1301,1,0,0,0,160,1316,1,
  	0,0,0,162,1329,1,0,0,0,164,1337,1,0,0,0,166,1356,1,0,0,0,168,1358,1,0,
  	0,0,170,1368,1,0,0,0,172,1397,1,0,0,0,174,1470,1,0,0,0,176,1472,1,0,0,
  	0,178,1483,1,0,0,0,180,1497,1,0,0,0,182,1505,1,0,0,0,184,1525,1,0,0,0,
  	186,1527,1,0,0,0,188,1537,1,0,0,0,190,1580,1,0,0,0,192,1582,1,0,0,0,194,
  	1602,1,0,0,0,196,1606,1,0,0,0,198,1612,1,0,0,0,200,1615,1,0,0,0,202,1681,
  	1,0,0,0,204,1693,1,0,0,0,206,1708,1,0,0,0,208,1713,1,0,0,0,210,1715,1,
  	0,0,0,212,1719,1,0,0,0,214,1723,1,0,0,0,216,1727,1,0,0,0,218,1738,1,0,
  	0,0,220,1756,1,0,0,0,222,1759,1,0,0,0,224,1771,1,0,0,0,226,1775,1,0,0,
  	0,228,1786,1,0,0,0,230,1796,1,0,0,0,232,1799,1,0,0,0,234,1814,1,0,0,0,
  	236,1824,1,0,0,0,238,1826,1,0,0,0,240,1830,1,0,0,0,242,1834,1,0,0,0,244,
  	1844,1,0,0,0,246,1856,1,0,0,0,248,1858,1,0,0,0,250,1860,1,0,0,0,252,1878,
  	1,0,0,0,254,1880,1,0,0,0,256,1882,1,0,0,0,258,1884,1,0,0,0,260,262,3,
  	2,1,0,261,260,1,0,0,0,261,262,1,0,0,0,262,270,1,0,0,0,263,265,5,219,0,
  	0,264,263,1,0,0,0,265,268,1,0,0,0,266,264,1,0,0,0,266,267,1,0,0,0,267,
  	271,1,0,0,0,268,266,1,0,0,0,269,271,5,0,0,1,270,266,1,0,0,0,270,269,1,
  	0,0,0,271,273,1,0,0,0,272,274,3,4,2,0,273,272,1,0,0,0,274,275,1,0,0,0,
  	275,273,1,0,0,0,275,276,1,0,0,0,276,284,1,0,0,0,277,279,5,219,0,0,278,
  	277,1,0,0,0,279,282,1,0,0,0,280,278,1,0,0,0,280,281,1,0,0,0,281,285,1,
  	0,0,0,282,280,1,0,0,0,283,285,5,0,0,1,284,280,1,0,0,0,284,283,1,0,0,0,
  	285,1,1,0,0,0,286,288,5,217,0,0,287,286,1,0,0,0,288,289,1,0,0,0,289,287,
  	1,0,0,0,289,290,1,0,0,0,290,298,1,0,0,0,291,293,5,219,0,0,292,291,1,0,
  	0,0,293,296,1,0,0,0,294,292,1,0,0,0,294,295,1,0,0,0,295,299,1,0,0,0,296,
  	294,1,0,0,0,297,299,5,0,0,1,298,294,1,0,0,0,298,297,1,0,0,0,299,3,1,0,
  	0,0,300,314,3,6,3,0,301,314,3,16,8,0,302,314,3,34,17,0,303,314,3,48,24,
  	0,304,314,3,124,62,0,305,314,3,126,63,0,306,314,3,190,95,0,307,314,3,
  	132,66,0,308,314,3,192,96,0,309,314,3,14,7,0,310,314,3,24,12,0,311,314,
  	3,32,16,0,312,314,3,162,81,0,313,300,1,0,0,0,313,301,1,0,0,0,313,302,
  	1,0,0,0,313,303,1,0,0,0,313,304,1,0,0,0,313,305,1,0,0,0,313,306,1,0,0,
  	0,313,307,1,0,0,0,313,308,1,0,0,0,313,309,1,0,0,0,313,310,1,0,0,0,313,
  	311,1,0,0,0,313,312,1,0,0,0,314,5,1,0,0,0,315,319,3,8,4,0,316,319,3,10,
  	5,0,317,319,3,12,6,0,318,315,1,0,0,0,318,316,1,0,0,0,318,317,1,0,0,0,
  	319,7,1,0,0,0,320,321,5,3,0,0,321,323,3,250,125,0,322,324,3,236,118,0,
  	323,322,1,0,0,0,323,324,1,0,0,0,324,332,1,0,0,0,325,327,5,219,0,0,326,
  	325,1,0,0,0,327,330,1,0,0,0,328,326,1,0,0,0,328,329,1,0,0,0,329,333,1,
  	0,0,0,330,328,1,0,0,0,331,333,5,0,0,1,332,328,1,0,0,0,332,331,1,0,0,0,
  	333,9,1,0,0,0,334,335,5,4,0,0,335,343,3,250,125,0,336,338,5,219,0,0,337,
  	336,1,0,0,0,338,341,1,0,0,0,339,337,1,0,0,0,339,340,1,0,0,0,340,344,1,
  	0,0,0,341,339,1,0,0,0,342,344,5,0,0,1,343,339,1,0,0,0,343,342,1,0,0,0,
  	344,11,1,0,0,0,345,346,5,5,0,0,346,348,3,250,125,0,347,349,5,189,0,0,
  	348,347,1,0,0,0,348,349,1,0,0,0,349,351,1,0,0,0,350,352,5,217,0,0,351,
  	350,1,0,0,0,351,352,1,0,0,0,352,360,1,0,0,0,353,355,5,219,0,0,354,353,
  	1,0,0,0,355,358,1,0,0,0,356,354,1,0,0,0,356,357,1,0,0,0,357,361,1,0,0,
  	0,358,356,1,0,0,0,359,361,5,0,0,1,360,356,1,0,0,0,360,359,1,0,0,0,361,
  	13,1,0,0,0,362,363,5,13,0,0,363,364,5,28,0,0,364,365,5,168,0,0,365,373,
  	5,43,0,0,366,368,5,219,0,0,367,366,1,0,0,0,368,371,1,0,0,0,369,367,1,
  	0,0,0,369,370,1,0,0,0,370,374,1,0,0,0,371,369,1,0,0,0,372,374,5,0,0,1,
  	373,369,1,0,0,0,373,372,1,0,0,0,374,394,1,0,0,0,375,376,5,13,0,0,376,
  	377,5,28,0,0,377,378,5,168,0,0,378,382,5,42,0,0,379,380,5,36,0,0,380,
  	381,5,168,0,0,381,383,5,217,0,0,382,379,1,0,0,0,382,383,1,0,0,0,383,391,
  	1,0,0,0,384,386,5,219,0,0,385,384,1,0,0,0,386,389,1,0,0,0,387,385,1,0,
  	0,0,387,388,1,0,0,0,388,392,1,0,0,0,389,387,1,0,0,0,390,392,5,0,0,1,391,
  	387,1,0,0,0,391,390,1,0,0,0,392,394,1,0,0,0,393,362,1,0,0,0,393,375,1,
  	0,0,0,394,15,1,0,0,0,395,397,3,18,9,0,396,398,3,20,10,0,397,396,1,0,0,
  	0,398,399,1,0,0,0,399,397,1,0,0,0,399,400,1,0,0,0,400,401,1,0,0,0,401,
  	402,3,22,11,0,402,17,1,0,0,0,403,404,5,6,0,0,404,412,5,217,0,0,405,407,
  	5,219,0,0,406,405,1,0,0,0,407,410,1,0,0,0,408,406,1,0,0,0,408,409,1,0,
  	0,0,409,413,1,0,0,0,410,408,1,0,0,0,411,413,5,0,0,1,412,408,1,0,0,0,412,
  	411,1,0,0,0,413,19,1,0,0,0,414,415,3,4,2,0,415,21,1,0,0,0,416,418,5,7,
  	0,0,417,419,5,217,0,0,418,417,1,0,0,0,418,419,1,0,0,0,419,427,1,0,0,0,
  	420,422,5,219,0,0,421,420,1,0,0,0,422,425,1,0,0,0,423,421,1,0,0,0,423,
  	424,1,0,0,0,424,428,1,0,0,0,425,423,1,0,0,0,426,428,5,0,0,1,427,423,1,
  	0,0,0,427,426,1,0,0,0,428,23,1,0,0,0,429,431,3,26,13,0,430,432,3,28,14,
  	0,431,430,1,0,0,0,432,433,1,0,0,0,433,431,1,0,0,0,433,434,1,0,0,0,434,
  	435,1,0,0,0,435,436,3,30,15,0,436,25,1,0,0,0,437,438,5,8,0,0,438,446,
  	5,217,0,0,439,441,5,219,0,0,440,439,1,0,0,0,441,444,1,0,0,0,442,440,1,
  	0,0,0,442,443,1,0,0,0,443,447,1,0,0,0,444,442,1,0,0,0,445,447,5,0,0,1,
  	446,442,1,0,0,0,446,445,1,0,0,0,447,27,1,0,0,0,448,449,3,4,2,0,449,29,
  	1,0,0,0,450,452,5,9,0,0,451,453,5,217,0,0,452,451,1,0,0,0,452,453,1,0,
  	0,0,453,461,1,0,0,0,454,456,5,219,0,0,455,454,1,0,0,0,456,459,1,0,0,0,
  	457,455,1,0,0,0,457,458,1,0,0,0,458,462,1,0,0,0,459,457,1,0,0,0,460,462,
  	5,0,0,1,461,457,1,0,0,0,461,460,1,0,0,0,462,31,1,0,0,0,463,464,5,217,
  	0,0,464,465,3,206,103,0,465,467,5,40,0,0,466,468,3,232,116,0,467,466,
  	1,0,0,0,467,468,1,0,0,0,468,33,1,0,0,0,469,471,3,36,18,0,470,472,3,38,
  	19,0,471,470,1,0,0,0,472,473,1,0,0,0,473,471,1,0,0,0,473,474,1,0,0,0,
  	474,475,1,0,0,0,475,476,3,40,20,0,476,35,1,0,0,0,477,478,7,0,0,0,478,
  	480,5,217,0,0,479,481,3,206,103,0,480,479,1,0,0,0,480,481,1,0,0,0,481,
  	483,1,0,0,0,482,484,5,219,0,0,483,482,1,0,0,0,484,485,1,0,0,0,485,483,
  	1,0,0,0,485,486,1,0,0,0,486,37,1,0,0,0,487,488,3,4,2,0,488,39,1,0,0,0,
  	489,491,5,12,0,0,490,492,5,217,0,0,491,490,1,0,0,0,491,492,1,0,0,0,492,
  	500,1,0,0,0,493,495,5,219,0,0,494,493,1,0,0,0,495,498,1,0,0,0,496,494,
  	1,0,0,0,496,497,1,0,0,0,497,501,1,0,0,0,498,496,1,0,0,0,499,501,5,0,0,
  	1,500,496,1,0,0,0,500,499,1,0,0,0,501,41,1,0,0,0,502,503,5,37,0,0,503,
  	504,3,218,109,0,504,506,3,46,23,0,505,507,3,44,22,0,506,505,1,0,0,0,506,
  	507,1,0,0,0,507,43,1,0,0,0,508,509,5,38,0,0,509,510,3,46,23,0,510,45,
  	1,0,0,0,511,513,5,219,0,0,512,511,1,0,0,0,513,516,1,0,0,0,514,512,1,0,
  	0,0,514,515,1,0,0,0,515,517,1,0,0,0,516,514,1,0,0,0,517,521,5,195,0,0,
  	518,520,5,219,0,0,519,518,1,0,0,0,520,523,1,0,0,0,521,519,1,0,0,0,521,
  	522,1,0,0,0,522,525,1,0,0,0,523,521,1,0,0,0,524,514,1,0,0,0,524,525,1,
  	0,0,0,525,531,1,0,0,0,526,532,3,192,96,0,527,532,3,48,24,0,528,532,3,
  	132,66,0,529,532,3,42,21,0,530,532,5,219,0,0,531,526,1,0,0,0,531,527,
  	1,0,0,0,531,528,1,0,0,0,531,529,1,0,0,0,531,530,1,0,0,0,532,533,1,0,0,
  	0,533,531,1,0,0,0,533,534,1,0,0,0,534,542,1,0,0,0,535,537,5,219,0,0,536,
  	535,1,0,0,0,537,540,1,0,0,0,538,536,1,0,0,0,538,539,1,0,0,0,539,541,1,
  	0,0,0,540,538,1,0,0,0,541,543,5,196,0,0,542,538,1,0,0,0,542,543,1,0,0,
  	0,543,551,1,0,0,0,544,546,5,219,0,0,545,544,1,0,0,0,546,549,1,0,0,0,547,
  	545,1,0,0,0,547,548,1,0,0,0,548,552,1,0,0,0,549,547,1,0,0,0,550,552,5,
  	0,0,1,551,547,1,0,0,0,551,550,1,0,0,0,552,47,1,0,0,0,553,582,3,50,25,
  	0,554,582,3,52,26,0,555,582,3,54,27,0,556,582,3,56,28,0,557,582,3,58,
  	29,0,558,582,3,60,30,0,559,582,3,62,31,0,560,582,3,64,32,0,561,582,3,
  	72,36,0,562,582,3,74,37,0,563,582,3,76,38,0,564,582,3,78,39,0,565,582,
  	3,80,40,0,566,582,3,82,41,0,567,582,3,84,42,0,568,582,3,86,43,0,569,582,
  	3,88,44,0,570,582,3,90,45,0,571,582,3,92,46,0,572,582,3,94,47,0,573,582,
  	3,96,48,0,574,582,3,98,49,0,575,582,3,100,50,0,576,582,3,102,51,0,577,
  	582,3,110,55,0,578,582,3,120,60,0,579,582,3,122,61,0,580,582,3,180,90,
  	0,581,553,1,0,0,0,581,554,1,0,0,0,581,555,1,0,0,0,581,556,1,0,0,0,581,
  	557,1,0,0,0,581,558,1,0,0,0,581,559,1,0,0,0,581,560,1,0,0,0,581,561,1,
  	0,0,0,581,562,1,0,0,0,581,563,1,0,0,0,581,564,1,0,0,0,581,565,1,0,0,0,
  	581,566,1,0,0,0,581,567,1,0,0,0,581,568,1,0,0,0,581,569,1,0,0,0,581,570,
  	1,0,0,0,581,571,1,0,0,0,581,572,1,0,0,0,581,573,1,0,0,0,581,574,1,0,0,
  	0,581,575,1,0,0,0,581,576,1,0,0,0,581,577,1,0,0,0,581,578,1,0,0,0,581,
  	579,1,0,0,0,581,580,1,0,0,0,582,49,1,0,0,0,583,584,5,217,0,0,584,586,
  	5,51,0,0,585,587,3,232,116,0,586,585,1,0,0,0,586,587,1,0,0,0,587,595,
  	1,0,0,0,588,590,5,219,0,0,589,588,1,0,0,0,590,593,1,0,0,0,591,589,1,0,
  	0,0,591,592,1,0,0,0,592,596,1,0,0,0,593,591,1,0,0,0,594,596,5,0,0,1,595,
  	591,1,0,0,0,595,594,1,0,0,0,596,51,1,0,0,0,597,598,5,217,0,0,598,600,
  	5,52,0,0,599,601,3,206,103,0,600,599,1,0,0,0,600,601,1,0,0,0,601,603,
  	1,0,0,0,602,604,3,232,116,0,603,602,1,0,0,0,603,604,1,0,0,0,604,612,1,
  	0,0,0,605,607,5,219,0,0,606,605,1,0,0,0,607,610,1,0,0,0,608,606,1,0,0,
  	0,608,609,1,0,0,0,609,613,1,0,0,0,610,608,1,0,0,0,611,613,5,0,0,1,612,
  	608,1,0,0,0,612,611,1,0,0,0,613,53,1,0,0,0,614,615,5,217,0,0,615,617,
  	5,53,0,0,616,618,3,232,116,0,617,616,1,0,0,0,617,618,1,0,0,0,618,626,
  	1,0,0,0,619,621,5,219,0,0,620,619,1,0,0,0,621,624,1,0,0,0,622,620,1,0,
  	0,0,622,623,1,0,0,0,623,627,1,0,0,0,624,622,1,0,0,0,625,627,5,0,0,1,626,
  	622,1,0,0,0,626,625,1,0,0,0,627,55,1,0,0,0,628,630,5,217,0,0,629,631,
  	3,206,103,0,630,629,1,0,0,0,630,631,1,0,0,0,631,632,1,0,0,0,632,634,5,
  	54,0,0,633,635,3,232,116,0,634,633,1,0,0,0,634,635,1,0,0,0,635,643,1,
  	0,0,0,636,638,5,219,0,0,637,636,1,0,0,0,638,641,1,0,0,0,639,637,1,0,0,
  	0,639,640,1,0,0,0,640,644,1,0,0,0,641,639,1,0,0,0,642,644,5,0,0,1,643,
  	639,1,0,0,0,643,642,1,0,0,0,644,57,1,0,0,0,645,647,5,217,0,0,646,648,
  	3,206,103,0,647,646,1,0,0,0,647,648,1,0,0,0,648,649,1,0,0,0,649,651,5,
  	55,0,0,650,652,3,232,116,0,651,650,1,0,0,0,651,652,1,0,0,0,652,660,1,
  	0,0,0,653,655,5,219,0,0,654,653,1,0,0,0,655,658,1,0,0,0,656,654,1,0,0,
  	0,656,657,1,0,0,0,657,661,1,0,0,0,658,656,1,0,0,0,659,661,5,0,0,1,660,
  	656,1,0,0,0,660,659,1,0,0,0,661,59,1,0,0,0,662,663,5,217,0,0,663,665,
  	5,56,0,0,664,666,3,232,116,0,665,664,1,0,0,0,665,666,1,0,0,0,666,674,
  	1,0,0,0,667,669,5,219,0,0,668,667,1,0,0,0,669,672,1,0,0,0,670,668,1,0,
  	0,0,670,671,1,0,0,0,671,675,1,0,0,0,672,670,1,0,0,0,673,675,5,0,0,1,674,
  	670,1,0,0,0,674,673,1,0,0,0,675,61,1,0,0,0,676,677,5,217,0,0,677,679,
  	5,57,0,0,678,680,3,232,116,0,679,678,1,0,0,0,679,680,1,0,0,0,680,688,
  	1,0,0,0,681,683,5,219,0,0,682,681,1,0,0,0,683,686,1,0,0,0,684,682,1,0,
  	0,0,684,685,1,0,0,0,685,689,1,0,0,0,686,684,1,0,0,0,687,689,5,0,0,1,688,
  	684,1,0,0,0,688,687,1,0,0,0,689,63,1,0,0,0,690,692,3,66,33,0,691,693,
  	3,68,34,0,692,691,1,0,0,0,693,694,1,0,0,0,694,692,1,0,0,0,694,695,1,0,
  	0,0,695,696,1,0,0,0,696,697,3,70,35,0,697,65,1,0,0,0,698,699,5,217,0,
  	0,699,703,5,58,0,0,700,702,5,219,0,0,701,700,1,0,0,0,702,705,1,0,0,0,
  	703,701,1,0,0,0,703,704,1,0,0,0,704,709,1,0,0,0,705,703,1,0,0,0,706,708,
  	3,232,116,0,707,706,1,0,0,0,708,711,1,0,0,0,709,707,1,0,0,0,709,710,1,
  	0,0,0,710,712,1,0,0,0,711,709,1,0,0,0,712,720,5,195,0,0,713,715,5,219,
  	0,0,714,713,1,0,0,0,715,718,1,0,0,0,716,714,1,0,0,0,716,717,1,0,0,0,717,
  	721,1,0,0,0,718,716,1,0,0,0,719,721,5,0,0,1,720,716,1,0,0,0,720,719,1,
  	0,0,0,721,67,1,0,0,0,722,723,3,4,2,0,723,69,1,0,0,0,724,732,5,196,0,0,
  	725,727,5,219,0,0,726,725,1,0,0,0,727,730,1,0,0,0,728,726,1,0,0,0,728,
  	729,1,0,0,0,729,733,1,0,0,0,730,728,1,0,0,0,731,733,5,0,0,1,732,728,1,
  	0,0,0,732,731,1,0,0,0,733,71,1,0,0,0,734,735,5,217,0,0,735,737,5,59,0,
  	0,736,738,3,232,116,0,737,736,1,0,0,0,737,738,1,0,0,0,738,746,1,0,0,0,
  	739,741,5,219,0,0,740,739,1,0,0,0,741,744,1,0,0,0,742,740,1,0,0,0,742,
  	743,1,0,0,0,743,747,1,0,0,0,744,742,1,0,0,0,745,747,5,0,0,1,746,742,1,
  	0,0,0,746,745,1,0,0,0,747,73,1,0,0,0,748,749,5,217,0,0,749,751,5,60,0,
  	0,750,752,3,232,116,0,751,750,1,0,0,0,751,752,1,0,0,0,752,760,1,0,0,0,
  	753,755,5,219,0,0,754,753,1,0,0,0,755,758,1,0,0,0,756,754,1,0,0,0,756,
  	757,1,0,0,0,757,761,1,0,0,0,758,756,1,0,0,0,759,761,5,0,0,1,760,756,1,
  	0,0,0,760,759,1,0,0,0,761,75,1,0,0,0,762,764,5,217,0,0,763,765,3,206,
  	103,0,764,763,1,0,0,0,764,765,1,0,0,0,765,766,1,0,0,0,766,768,5,61,0,
  	0,767,769,3,232,116,0,768,767,1,0,0,0,768,769,1,0,0,0,769,777,1,0,0,0,
  	770,772,5,219,0,0,771,770,1,0,0,0,772,775,1,0,0,0,773,771,1,0,0,0,773,
  	774,1,0,0,0,774,778,1,0,0,0,775,773,1,0,0,0,776,778,5,0,0,1,777,773,1,
  	0,0,0,777,776,1,0,0,0,778,77,1,0,0,0,779,781,5,217,0,0,780,782,3,206,
  	103,0,781,780,1,0,0,0,781,782,1,0,0,0,782,783,1,0,0,0,783,785,5,62,0,
  	0,784,786,3,232,116,0,785,784,1,0,0,0,785,786,1,0,0,0,786,794,1,0,0,0,
  	787,789,5,219,0,0,788,787,1,0,0,0,789,792,1,0,0,0,790,788,1,0,0,0,790,
  	791,1,0,0,0,791,795,1,0,0,0,792,790,1,0,0,0,793,795,5,0,0,1,794,790,1,
  	0,0,0,794,793,1,0,0,0,795,79,1,0,0,0,796,798,5,217,0,0,797,799,3,206,
  	103,0,798,797,1,0,0,0,798,799,1,0,0,0,799,800,1,0,0,0,800,802,5,63,0,
  	0,801,803,3,232,116,0,802,801,1,0,0,0,802,803,1,0,0,0,803,811,1,0,0,0,
  	804,806,5,219,0,0,805,804,1,0,0,0,806,809,1,0,0,0,807,805,1,0,0,0,807,
  	808,1,0,0,0,808,812,1,0,0,0,809,807,1,0,0,0,810,812,5,0,0,1,811,807,1,
  	0,0,0,811,810,1,0,0,0,812,81,1,0,0,0,813,815,5,217,0,0,814,816,3,206,
  	103,0,815,814,1,0,0,0,815,816,1,0,0,0,816,817,1,0,0,0,817,819,5,64,0,
  	0,818,820,3,232,116,0,819,818,1,0,0,0,819,820,1,0,0,0,820,828,1,0,0,0,
  	821,823,5,219,0,0,822,821,1,0,0,0,823,826,1,0,0,0,824,822,1,0,0,0,824,
  	825,1,0,0,0,825,829,1,0,0,0,826,824,1,0,0,0,827,829,5,0,0,1,828,824,1,
  	0,0,0,828,827,1,0,0,0,829,83,1,0,0,0,830,831,5,217,0,0,831,833,5,65,0,
  	0,832,834,3,232,116,0,833,832,1,0,0,0,833,834,1,0,0,0,834,842,1,0,0,0,
  	835,837,5,219,0,0,836,835,1,0,0,0,837,840,1,0,0,0,838,836,1,0,0,0,838,
  	839,1,0,0,0,839,843,1,0,0,0,840,838,1,0,0,0,841,843,5,0,0,1,842,838,1,
  	0,0,0,842,841,1,0,0,0,843,85,1,0,0,0,844,846,5,217,0,0,845,847,3,206,
  	103,0,846,845,1,0,0,0,846,847,1,0,0,0,847,848,1,0,0,0,848,850,5,66,0,
  	0,849,851,3,232,116,0,850,849,1,0,0,0,850,851,1,0,0,0,851,859,1,0,0,0,
  	852,854,5,219,0,0,853,852,1,0,0,0,854,857,1,0,0,0,855,853,1,0,0,0,855,
  	856,1,0,0,0,856,860,1,0,0,0,857,855,1,0,0,0,858,860,5,0,0,1,859,855,1,
  	0,0,0,859,858,1,0,0,0,860,87,1,0,0,0,861,863,5,217,0,0,862,864,3,206,
  	103,0,863,862,1,0,0,0,863,864,1,0,0,0,864,865,1,0,0,0,865,867,5,67,0,
  	0,866,868,3,232,116,0,867,866,1,0,0,0,867,868,1,0,0,0,868,876,1,0,0,0,
  	869,871,5,219,0,0,870,869,1,0,0,0,871,874,1,0,0,0,872,870,1,0,0,0,872,
  	873,1,0,0,0,873,877,1,0,0,0,874,872,1,0,0,0,875,877,5,0,0,1,876,872,1,
  	0,0,0,876,875,1,0,0,0,877,89,1,0,0,0,878,880,5,217,0,0,879,881,3,206,
  	103,0,880,879,1,0,0,0,880,881,1,0,0,0,881,882,1,0,0,0,882,884,5,68,0,
  	0,883,885,3,232,116,0,884,883,1,0,0,0,884,885,1,0,0,0,885,893,1,0,0,0,
  	886,888,5,219,0,0,887,886,1,0,0,0,888,891,1,0,0,0,889,887,1,0,0,0,889,
  	890,1,0,0,0,890,894,1,0,0,0,891,889,1,0,0,0,892,894,5,0,0,1,893,889,1,
  	0,0,0,893,892,1,0,0,0,894,91,1,0,0,0,895,896,5,217,0,0,896,898,5,69,0,
  	0,897,899,3,232,116,0,898,897,1,0,0,0,898,899,1,0,0,0,899,907,1,0,0,0,
  	900,902,5,219,0,0,901,900,1,0,0,0,902,905,1,0,0,0,903,901,1,0,0,0,903,
  	904,1,0,0,0,904,908,1,0,0,0,905,903,1,0,0,0,906,908,5,0,0,1,907,903,1,
  	0,0,0,907,906,1,0,0,0,908,93,1,0,0,0,909,911,5,217,0,0,910,912,3,206,
  	103,0,911,910,1,0,0,0,911,912,1,0,0,0,912,913,1,0,0,0,913,915,5,70,0,
  	0,914,916,3,232,116,0,915,914,1,0,0,0,915,916,1,0,0,0,916,924,1,0,0,0,
  	917,919,5,219,0,0,918,917,1,0,0,0,919,922,1,0,0,0,920,918,1,0,0,0,920,
  	921,1,0,0,0,921,925,1,0,0,0,922,920,1,0,0,0,923,925,5,0,0,1,924,920,1,
  	0,0,0,924,923,1,0,0,0,925,95,1,0,0,0,926,927,5,217,0,0,927,929,5,71,0,
  	0,928,930,3,232,116,0,929,928,1,0,0,0,929,930,1,0,0,0,930,938,1,0,0,0,
  	931,933,5,219,0,0,932,931,1,0,0,0,933,936,1,0,0,0,934,932,1,0,0,0,934,
  	935,1,0,0,0,935,939,1,0,0,0,936,934,1,0,0,0,937,939,5,0,0,1,938,934,1,
  	0,0,0,938,937,1,0,0,0,939,97,1,0,0,0,940,942,5,217,0,0,941,943,3,206,
  	103,0,942,941,1,0,0,0,942,943,1,0,0,0,943,944,1,0,0,0,944,946,5,72,0,
  	0,945,947,3,232,116,0,946,945,1,0,0,0,946,947,1,0,0,0,947,955,1,0,0,0,
  	948,950,5,219,0,0,949,948,1,0,0,0,950,953,1,0,0,0,951,949,1,0,0,0,951,
  	952,1,0,0,0,952,956,1,0,0,0,953,951,1,0,0,0,954,956,5,0,0,1,955,951,1,
  	0,0,0,955,954,1,0,0,0,956,99,1,0,0,0,957,959,5,217,0,0,958,960,3,206,
  	103,0,959,958,1,0,0,0,959,960,1,0,0,0,960,961,1,0,0,0,961,963,5,73,0,
  	0,962,964,3,232,116,0,963,962,1,0,0,0,963,964,1,0,0,0,964,972,1,0,0,0,
  	965,967,5,219,0,0,966,965,1,0,0,0,967,970,1,0,0,0,968,966,1,0,0,0,968,
  	969,1,0,0,0,969,973,1,0,0,0,970,968,1,0,0,0,971,973,5,0,0,1,972,968,1,
  	0,0,0,972,971,1,0,0,0,973,101,1,0,0,0,974,976,5,74,0,0,975,977,3,104,
  	52,0,976,975,1,0,0,0,976,977,1,0,0,0,977,980,1,0,0,0,978,979,5,217,0,
  	0,979,981,3,106,53,0,980,978,1,0,0,0,980,981,1,0,0,0,981,984,1,0,0,0,
  	982,983,5,217,0,0,983,985,3,106,53,0,984,982,1,0,0,0,984,985,1,0,0,0,
  	985,993,1,0,0,0,986,988,5,219,0,0,987,986,1,0,0,0,988,991,1,0,0,0,989,
  	987,1,0,0,0,989,990,1,0,0,0,990,994,1,0,0,0,991,989,1,0,0,0,992,994,5,
  	0,0,1,993,989,1,0,0,0,993,992,1,0,0,0,994,103,1,0,0,0,995,997,5,191,0,
  	0,996,998,3,206,103,0,997,996,1,0,0,0,998,999,1,0,0,0,999,997,1,0,0,0,
  	999,1000,1,0,0,0,1000,1001,1,0,0,0,1001,1002,5,192,0,0,1002,105,1,0,0,
  	0,1003,1005,5,191,0,0,1004,1006,3,206,103,0,1005,1004,1,0,0,0,1006,1007,
  	1,0,0,0,1007,1005,1,0,0,0,1007,1008,1,0,0,0,1008,1009,1,0,0,0,1009,1010,
  	5,192,0,0,1010,107,1,0,0,0,1011,1013,5,191,0,0,1012,1014,3,206,103,0,
  	1013,1012,1,0,0,0,1014,1015,1,0,0,0,1015,1013,1,0,0,0,1015,1016,1,0,0,
  	0,1016,1017,1,0,0,0,1017,1018,5,192,0,0,1018,109,1,0,0,0,1019,1021,3,
  	112,56,0,1020,1022,3,114,57,0,1021,1020,1,0,0,0,1022,1023,1,0,0,0,1023,
  	1021,1,0,0,0,1023,1024,1,0,0,0,1024,1025,1,0,0,0,1025,1026,3,116,58,0,
  	1026,1027,3,118,59,0,1027,111,1,0,0,0,1028,1029,5,217,0,0,1029,1033,5,
  	75,0,0,1030,1032,5,219,0,0,1031,1030,1,0,0,0,1032,1035,1,0,0,0,1033,1031,
  	1,0,0,0,1033,1034,1,0,0,0,1034,1039,1,0,0,0,1035,1033,1,0,0,0,1036,1038,
  	3,232,116,0,1037,1036,1,0,0,0,1038,1041,1,0,0,0,1039,1037,1,0,0,0,1039,
  	1040,1,0,0,0,1040,1042,1,0,0,0,1041,1039,1,0,0,0,1042,1050,5,195,0,0,
  	1043,1045,5,219,0,0,1044,1043,1,0,0,0,1045,1048,1,0,0,0,1046,1044,1,0,
  	0,0,1046,1047,1,0,0,0,1047,1051,1,0,0,0,1048,1046,1,0,0,0,1049,1051,5,
  	0,0,1,1050,1046,1,0,0,0,1050,1049,1,0,0,0,1051,113,1,0,0,0,1052,1053,
  	3,4,2,0,1053,115,1,0,0,0,1054,1055,5,16,0,0,1055,1063,3,232,116,0,1056,
  	1058,5,219,0,0,1057,1056,1,0,0,0,1058,1061,1,0,0,0,1059,1057,1,0,0,0,
  	1059,1060,1,0,0,0,1060,1064,1,0,0,0,1061,1059,1,0,0,0,1062,1064,5,0,0,
  	1,1063,1059,1,0,0,0,1063,1062,1,0,0,0,1064,117,1,0,0,0,1065,1073,5,196,
  	0,0,1066,1068,5,219,0,0,1067,1066,1,0,0,0,1068,1071,1,0,0,0,1069,1067,
  	1,0,0,0,1069,1070,1,0,0,0,1070,1074,1,0,0,0,1071,1069,1,0,0,0,1072,1074,
  	5,0,0,1,1073,1069,1,0,0,0,1073,1072,1,0,0,0,1074,119,1,0,0,0,1075,1077,
  	5,217,0,0,1076,1078,3,206,103,0,1077,1076,1,0,0,0,1077,1078,1,0,0,0,1078,
  	1079,1,0,0,0,1079,1081,5,76,0,0,1080,1082,3,232,116,0,1081,1080,1,0,0,
  	0,1081,1082,1,0,0,0,1082,1090,1,0,0,0,1083,1085,5,219,0,0,1084,1083,1,
  	0,0,0,1085,1088,1,0,0,0,1086,1084,1,0,0,0,1086,1087,1,0,0,0,1087,1091,
  	1,0,0,0,1088,1086,1,0,0,0,1089,1091,5,0,0,1,1090,1086,1,0,0,0,1090,1089,
  	1,0,0,0,1091,121,1,0,0,0,1092,1093,5,217,0,0,1093,1095,5,77,0,0,1094,
  	1096,3,232,116,0,1095,1094,1,0,0,0,1095,1096,1,0,0,0,1096,1104,1,0,0,
  	0,1097,1099,5,219,0,0,1098,1097,1,0,0,0,1099,1102,1,0,0,0,1100,1098,1,
  	0,0,0,1100,1101,1,0,0,0,1101,1105,1,0,0,0,1102,1100,1,0,0,0,1103,1105,
  	5,0,0,1,1104,1100,1,0,0,0,1104,1103,1,0,0,0,1105,123,1,0,0,0,1106,1107,
  	5,2,0,0,1107,1115,3,206,103,0,1108,1110,5,219,0,0,1109,1108,1,0,0,0,1110,
  	1113,1,0,0,0,1111,1109,1,0,0,0,1111,1112,1,0,0,0,1112,1116,1,0,0,0,1113,
  	1111,1,0,0,0,1114,1116,5,0,0,1,1115,1111,1,0,0,0,1115,1114,1,0,0,0,1116,
  	125,1,0,0,0,1117,1118,5,15,0,0,1118,1119,3,128,64,0,1119,1121,3,130,65,
  	0,1120,1122,3,232,116,0,1121,1120,1,0,0,0,1121,1122,1,0,0,0,1122,1130,
  	1,0,0,0,1123,1125,5,219,0,0,1124,1123,1,0,0,0,1125,1128,1,0,0,0,1126,
  	1124,1,0,0,0,1126,1127,1,0,0,0,1127,1131,1,0,0,0,1128,1126,1,0,0,0,1129,
  	1131,5,0,0,1,1130,1126,1,0,0,0,1130,1129,1,0,0,0,1131,127,1,0,0,0,1132,
  	1133,5,217,0,0,1133,129,1,0,0,0,1134,1137,5,217,0,0,1135,1137,3,258,129,
  	0,1136,1134,1,0,0,0,1136,1135,1,0,0,0,1137,131,1,0,0,0,1138,1150,3,134,
  	67,0,1139,1150,3,136,68,0,1140,1150,3,144,72,0,1141,1150,3,146,73,0,1142,
  	1150,3,148,74,0,1143,1150,3,150,75,0,1144,1150,3,152,76,0,1145,1150,3,
  	154,77,0,1146,1150,3,156,78,0,1147,1150,3,158,79,0,1148,1150,3,160,80,
  	0,1149,1138,1,0,0,0,1149,1139,1,0,0,0,1149,1140,1,0,0,0,1149,1141,1,0,
  	0,0,1149,1142,1,0,0,0,1149,1143,1,0,0,0,1149,1144,1,0,0,0,1149,1145,1,
  	0,0,0,1149,1146,1,0,0,0,1149,1147,1,0,0,0,1149,1148,1,0,0,0,1150,133,
  	1,0,0,0,1151,1152,5,217,0,0,1152,1154,5,18,0,0,1153,1155,3,232,116,0,
  	1154,1153,1,0,0,0,1154,1155,1,0,0,0,1155,1163,1,0,0,0,1156,1158,5,219,
  	0,0,1157,1156,1,0,0,0,1158,1161,1,0,0,0,1159,1157,1,0,0,0,1159,1160,1,
  	0,0,0,1160,1164,1,0,0,0,1161,1159,1,0,0,0,1162,1164,5,0,0,1,1163,1159,
  	1,0,0,0,1163,1162,1,0,0,0,1164,135,1,0,0,0,1165,1166,3,138,69,0,1166,
  	1168,3,190,95,0,1167,1169,3,140,70,0,1168,1167,1,0,0,0,1169,1170,1,0,
  	0,0,1170,1168,1,0,0,0,1170,1171,1,0,0,0,1171,1172,1,0,0,0,1172,1173,3,
  	142,71,0,1173,137,1,0,0,0,1174,1175,5,217,0,0,1175,1179,5,19,0,0,1176,
  	1178,5,219,0,0,1177,1176,1,0,0,0,1178,1181,1,0,0,0,1179,1177,1,0,0,0,
  	1179,1180,1,0,0,0,1180,1182,1,0,0,0,1181,1179,1,0,0,0,1182,1190,5,195,
  	0,0,1183,1185,5,219,0,0,1184,1183,1,0,0,0,1185,1188,1,0,0,0,1186,1184,
  	1,0,0,0,1186,1187,1,0,0,0,1187,1191,1,0,0,0,1188,1186,1,0,0,0,1189,1191,
  	5,0,0,1,1190,1186,1,0,0,0,1190,1189,1,0,0,0,1191,139,1,0,0,0,1192,1193,
  	3,4,2,0,1193,141,1,0,0,0,1194,1202,5,196,0,0,1195,1197,5,219,0,0,1196,
  	1195,1,0,0,0,1197,1200,1,0,0,0,1198,1196,1,0,0,0,1198,1199,1,0,0,0,1199,
  	1203,1,0,0,0,1200,1198,1,0,0,0,1201,1203,5,0,0,1,1202,1198,1,0,0,0,1202,
  	1201,1,0,0,0,1203,143,1,0,0,0,1204,1205,5,217,0,0,1205,1206,5,26,0,0,
  	1206,1208,3,236,118,0,1207,1209,3,232,116,0,1208,1207,1,0,0,0,1208,1209,
  	1,0,0,0,1209,1217,1,0,0,0,1210,1212,5,219,0,0,1211,1210,1,0,0,0,1212,
  	1215,1,0,0,0,1213,1211,1,0,0,0,1213,1214,1,0,0,0,1214,1218,1,0,0,0,1215,
  	1213,1,0,0,0,1216,1218,5,0,0,1,1217,1213,1,0,0,0,1217,1216,1,0,0,0,1218,
  	145,1,0,0,0,1219,1220,5,217,0,0,1220,1221,5,27,0,0,1221,1229,3,236,118,
  	0,1222,1224,5,219,0,0,1223,1222,1,0,0,0,1224,1227,1,0,0,0,1225,1223,1,
  	0,0,0,1225,1226,1,0,0,0,1226,1230,1,0,0,0,1227,1225,1,0,0,0,1228,1230,
  	5,0,0,1,1229,1225,1,0,0,0,1229,1228,1,0,0,0,1230,147,1,0,0,0,1231,1232,
  	5,17,0,0,1232,1234,5,217,0,0,1233,1235,3,232,116,0,1234,1233,1,0,0,0,
  	1234,1235,1,0,0,0,1235,1243,1,0,0,0,1236,1238,5,219,0,0,1237,1236,1,0,
  	0,0,1238,1241,1,0,0,0,1239,1237,1,0,0,0,1239,1240,1,0,0,0,1240,1244,1,
  	0,0,0,1241,1239,1,0,0,0,1242,1244,5,0,0,1,1243,1239,1,0,0,0,1243,1242,
  	1,0,0,0,1244,149,1,0,0,0,1245,1246,5,217,0,0,1246,1248,5,20,0,0,1247,
  	1249,3,232,116,0,1248,1247,1,0,0,0,1248,1249,1,0,0,0,1249,1257,1,0,0,
  	0,1250,1252,5,219,0,0,1251,1250,1,0,0,0,1252,1255,1,0,0,0,1253,1251,1,
  	0,0,0,1253,1254,1,0,0,0,1254,1258,1,0,0,0,1255,1253,1,0,0,0,1256,1258,
  	5,0,0,1,1257,1253,1,0,0,0,1257,1256,1,0,0,0,1258,151,1,0,0,0,1259,1260,
  	5,217,0,0,1260,1262,5,21,0,0,1261,1263,3,232,116,0,1262,1261,1,0,0,0,
  	1262,1263,1,0,0,0,1263,1271,1,0,0,0,1264,1266,5,219,0,0,1265,1264,1,0,
  	0,0,1266,1269,1,0,0,0,1267,1265,1,0,0,0,1267,1268,1,0,0,0,1268,1272,1,
  	0,0,0,1269,1267,1,0,0,0,1270,1272,5,0,0,1,1271,1267,1,0,0,0,1271,1270,
  	1,0,0,0,1272,153,1,0,0,0,1273,1274,5,217,0,0,1274,1276,5,22,0,0,1275,
  	1277,3,232,116,0,1276,1275,1,0,0,0,1276,1277,1,0,0,0,1277,1285,1,0,0,
  	0,1278,1280,5,219,0,0,1279,1278,1,0,0,0,1280,1283,1,0,0,0,1281,1279,1,
  	0,0,0,1281,1282,1,0,0,0,1282,1286,1,0,0,0,1283,1281,1,0,0,0,1284,1286,
  	5,0,0,1,1285,1281,1,0,0,0,1285,1284,1,0,0,0,1286,155,1,0,0,0,1287,1288,
  	5,217,0,0,1288,1290,5,23,0,0,1289,1291,3,232,116,0,1290,1289,1,0,0,0,
  	1290,1291,1,0,0,0,1291,1299,1,0,0,0,1292,1294,5,219,0,0,1293,1292,1,0,
  	0,0,1294,1297,1,0,0,0,1295,1293,1,0,0,0,1295,1296,1,0,0,0,1296,1300,1,
  	0,0,0,1297,1295,1,0,0,0,1298,1300,5,0,0,1,1299,1295,1,0,0,0,1299,1298,
  	1,0,0,0,1300,157,1,0,0,0,1301,1303,5,24,0,0,1302,1304,3,240,120,0,1303,
  	1302,1,0,0,0,1303,1304,1,0,0,0,1304,1305,1,0,0,0,1305,1306,5,168,0,0,
  	1306,1314,3,218,109,0,1307,1309,5,219,0,0,1308,1307,1,0,0,0,1309,1312,
  	1,0,0,0,1310,1308,1,0,0,0,1310,1311,1,0,0,0,1311,1315,1,0,0,0,1312,1310,
  	1,0,0,0,1313,1315,5,0,0,1,1314,1310,1,0,0,0,1314,1313,1,0,0,0,1315,159,
  	1,0,0,0,1316,1318,5,25,0,0,1317,1319,3,232,116,0,1318,1317,1,0,0,0,1318,
  	1319,1,0,0,0,1319,1327,1,0,0,0,1320,1322,5,219,0,0,1321,1320,1,0,0,0,
  	1322,1325,1,0,0,0,1323,1321,1,0,0,0,1323,1324,1,0,0,0,1324,1328,1,0,0,
  	0,1325,1323,1,0,0,0,1326,1328,5,0,0,1,1327,1323,1,0,0,0,1327,1326,1,0,
  	0,0,1328,161,1,0,0,0,1329,1331,3,164,82,0,1330,1332,3,166,83,0,1331,1330,
  	1,0,0,0,1332,1333,1,0,0,0,1333,1331,1,0,0,0,1333,1334,1,0,0,0,1334,1335,
  	1,0,0,0,1335,1336,3,168,84,0,1336,163,1,0,0,0,1337,1341,5,44,0,0,1338,
  	1340,5,219,0,0,1339,1338,1,0,0,0,1340,1343,1,0,0,0,1341,1339,1,0,0,0,
  	1341,1342,1,0,0,0,1342,1344,1,0,0,0,1343,1341,1,0,0,0,1344,1348,5,195,
  	0,0,1345,1347,5,219,0,0,1346,1345,1,0,0,0,1347,1350,1,0,0,0,1348,1346,
  	1,0,0,0,1348,1349,1,0,0,0,1349,165,1,0,0,0,1350,1348,1,0,0,0,1351,1357,
  	3,170,85,0,1352,1357,3,172,86,0,1353,1357,3,178,89,0,1354,1357,3,174,
  	87,0,1355,1357,3,176,88,0,1356,1351,1,0,0,0,1356,1352,1,0,0,0,1356,1353,
  	1,0,0,0,1356,1354,1,0,0,0,1356,1355,1,0,0,0,1357,167,1,0,0,0,1358,1366,
  	5,196,0,0,1359,1361,5,219,0,0,1360,1359,1,0,0,0,1361,1364,1,0,0,0,1362,
  	1360,1,0,0,0,1362,1363,1,0,0,0,1363,1367,1,0,0,0,1364,1362,1,0,0,0,1365,
  	1367,5,0,0,1,1366,1362,1,0,0,0,1366,1365,1,0,0,0,1367,169,1,0,0,0,1368,
  	1372,5,45,0,0,1369,1371,5,219,0,0,1370,1369,1,0,0,0,1371,1374,1,0,0,0,
  	1372,1370,1,0,0,0,1372,1373,1,0,0,0,1373,1375,1,0,0,0,1374,1372,1,0,0,
  	0,1375,1379,5,195,0,0,1376,1378,5,219,0,0,1377,1376,1,0,0,0,1378,1381,
  	1,0,0,0,1379,1377,1,0,0,0,1379,1380,1,0,0,0,1380,1383,1,0,0,0,1381,1379,
  	1,0,0,0,1382,1384,3,166,83,0,1383,1382,1,0,0,0,1384,1385,1,0,0,0,1385,
  	1383,1,0,0,0,1385,1386,1,0,0,0,1386,1387,1,0,0,0,1387,1395,5,196,0,0,
  	1388,1390,5,219,0,0,1389,1388,1,0,0,0,1390,1393,1,0,0,0,1391,1389,1,0,
  	0,0,1391,1392,1,0,0,0,1392,1396,1,0,0,0,1393,1391,1,0,0,0,1394,1396,5,
  	0,0,1,1395,1391,1,0,0,0,1395,1394,1,0,0,0,1396,171,1,0,0,0,1397,1401,
  	5,48,0,0,1398,1400,5,219,0,0,1399,1398,1,0,0,0,1400,1403,1,0,0,0,1401,
  	1399,1,0,0,0,1401,1402,1,0,0,0,1402,1404,1,0,0,0,1403,1401,1,0,0,0,1404,
  	1408,5,195,0,0,1405,1407,5,219,0,0,1406,1405,1,0,0,0,1407,1410,1,0,0,
  	0,1408,1406,1,0,0,0,1408,1409,1,0,0,0,1409,1412,1,0,0,0,1410,1408,1,0,
  	0,0,1411,1413,3,166,83,0,1412,1411,1,0,0,0,1413,1414,1,0,0,0,1414,1412,
  	1,0,0,0,1414,1415,1,0,0,0,1415,1416,1,0,0,0,1416,1424,5,196,0,0,1417,
  	1419,5,219,0,0,1418,1417,1,0,0,0,1419,1422,1,0,0,0,1420,1418,1,0,0,0,
  	1420,1421,1,0,0,0,1421,1425,1,0,0,0,1422,1420,1,0,0,0,1423,1425,5,0,0,
  	1,1424,1420,1,0,0,0,1424,1423,1,0,0,0,1425,173,1,0,0,0,1426,1427,5,46,
  	0,0,1427,1428,5,217,0,0,1428,1429,5,168,0,0,1429,1431,5,193,0,0,1430,
  	1432,3,238,119,0,1431,1430,1,0,0,0,1432,1433,1,0,0,0,1433,1431,1,0,0,
  	0,1433,1434,1,0,0,0,1434,1435,1,0,0,0,1435,1443,5,194,0,0,1436,1438,5,
  	219,0,0,1437,1436,1,0,0,0,1438,1441,1,0,0,0,1439,1437,1,0,0,0,1439,1440,
  	1,0,0,0,1440,1444,1,0,0,0,1441,1439,1,0,0,0,1442,1444,5,0,0,1,1443,1439,
  	1,0,0,0,1443,1442,1,0,0,0,1444,1471,1,0,0,0,1445,1456,5,46,0,0,1446,1447,
  	5,217,0,0,1447,1448,5,168,0,0,1448,1450,5,193,0,0,1449,1451,3,238,119,
  	0,1450,1449,1,0,0,0,1451,1452,1,0,0,0,1452,1450,1,0,0,0,1452,1453,1,0,
  	0,0,1453,1454,1,0,0,0,1454,1455,5,194,0,0,1455,1457,1,0,0,0,1456,1446,
  	1,0,0,0,1457,1458,1,0,0,0,1458,1456,1,0,0,0,1458,1459,1,0,0,0,1459,1460,
  	1,0,0,0,1460,1468,3,236,118,0,1461,1463,5,219,0,0,1462,1461,1,0,0,0,1463,
  	1466,1,0,0,0,1464,1462,1,0,0,0,1464,1465,1,0,0,0,1465,1469,1,0,0,0,1466,
  	1464,1,0,0,0,1467,1469,5,0,0,1,1468,1464,1,0,0,0,1468,1467,1,0,0,0,1469,
  	1471,1,0,0,0,1470,1426,1,0,0,0,1470,1445,1,0,0,0,1471,175,1,0,0,0,1472,
  	1473,5,47,0,0,1473,1481,3,236,118,0,1474,1476,5,219,0,0,1475,1474,1,0,
  	0,0,1476,1479,1,0,0,0,1477,1475,1,0,0,0,1477,1478,1,0,0,0,1478,1482,1,
  	0,0,0,1479,1477,1,0,0,0,1480,1482,5,0,0,1,1481,1477,1,0,0,0,1481,1480,
  	1,0,0,0,1482,177,1,0,0,0,1483,1484,5,49,0,0,1484,1486,5,217,0,0,1485,
  	1487,3,232,116,0,1486,1485,1,0,0,0,1486,1487,1,0,0,0,1487,1495,1,0,0,
  	0,1488,1490,5,219,0,0,1489,1488,1,0,0,0,1490,1493,1,0,0,0,1491,1489,1,
  	0,0,0,1491,1492,1,0,0,0,1492,1496,1,0,0,0,1493,1491,1,0,0,0,1494,1496,
  	5,0,0,1,1495,1491,1,0,0,0,1495,1494,1,0,0,0,1496,179,1,0,0,0,1497,1499,
  	3,182,91,0,1498,1500,3,184,92,0,1499,1498,1,0,0,0,1500,1501,1,0,0,0,1501,
  	1499,1,0,0,0,1501,1502,1,0,0,0,1502,1503,1,0,0,0,1503,1504,3,186,93,0,
  	1504,181,1,0,0,0,1505,1506,5,217,0,0,1506,1508,5,50,0,0,1507,1509,3,232,
  	116,0,1508,1507,1,0,0,0,1508,1509,1,0,0,0,1509,1513,1,0,0,0,1510,1512,
  	5,219,0,0,1511,1510,1,0,0,0,1512,1515,1,0,0,0,1513,1511,1,0,0,0,1513,
  	1514,1,0,0,0,1514,1516,1,0,0,0,1515,1513,1,0,0,0,1516,1520,5,195,0,0,
  	1517,1519,5,219,0,0,1518,1517,1,0,0,0,1519,1522,1,0,0,0,1520,1518,1,0,
  	0,0,1520,1521,1,0,0,0,1521,183,1,0,0,0,1522,1520,1,0,0,0,1523,1526,3,
  	188,94,0,1524,1526,3,4,2,0,1525,1523,1,0,0,0,1525,1524,1,0,0,0,1526,185,
  	1,0,0,0,1527,1535,5,196,0,0,1528,1530,5,219,0,0,1529,1528,1,0,0,0,1530,
  	1533,1,0,0,0,1531,1529,1,0,0,0,1531,1532,1,0,0,0,1532,1536,1,0,0,0,1533,
  	1531,1,0,0,0,1534,1536,5,0,0,1,1535,1531,1,0,0,0,1535,1534,1,0,0,0,1536,
  	187,1,0,0,0,1537,1538,5,217,0,0,1538,1546,3,232,116,0,1539,1541,5,219,
  	0,0,1540,1539,1,0,0,0,1541,1544,1,0,0,0,1542,1540,1,0,0,0,1542,1543,1,
  	0,0,0,1543,1547,1,0,0,0,1544,1542,1,0,0,0,1545,1547,5,0,0,1,1546,1542,
  	1,0,0,0,1546,1545,1,0,0,0,1547,189,1,0,0,0,1548,1549,5,14,0,0,1549,1551,
  	5,191,0,0,1550,1552,3,234,117,0,1551,1550,1,0,0,0,1552,1553,1,0,0,0,1553,
  	1551,1,0,0,0,1553,1554,1,0,0,0,1554,1555,1,0,0,0,1555,1563,5,192,0,0,
  	1556,1558,5,219,0,0,1557,1556,1,0,0,0,1558,1561,1,0,0,0,1559,1557,1,0,
  	0,0,1559,1560,1,0,0,0,1560,1564,1,0,0,0,1561,1559,1,0,0,0,1562,1564,5,
  	0,0,1,1563,1559,1,0,0,0,1563,1562,1,0,0,0,1564,1581,1,0,0,0,1565,1567,
  	5,14,0,0,1566,1568,3,234,117,0,1567,1566,1,0,0,0,1568,1569,1,0,0,0,1569,
  	1567,1,0,0,0,1569,1570,1,0,0,0,1570,1578,1,0,0,0,1571,1573,5,219,0,0,
  	1572,1571,1,0,0,0,1573,1576,1,0,0,0,1574,1572,1,0,0,0,1574,1575,1,0,0,
  	0,1575,1579,1,0,0,0,1576,1574,1,0,0,0,1577,1579,5,0,0,1,1578,1574,1,0,
  	0,0,1578,1577,1,0,0,0,1579,1581,1,0,0,0,1580,1548,1,0,0,0,1580,1565,1,
  	0,0,0,1581,191,1,0,0,0,1582,1584,3,194,97,0,1583,1585,3,206,103,0,1584,
  	1583,1,0,0,0,1584,1585,1,0,0,0,1585,1586,1,0,0,0,1586,1590,3,196,98,0,
  	1587,1589,3,198,99,0,1588,1587,1,0,0,0,1589,1592,1,0,0,0,1590,1588,1,
  	0,0,0,1590,1591,1,0,0,0,1591,1600,1,0,0,0,1592,1590,1,0,0,0,1593,1595,
  	5,219,0,0,1594,1593,1,0,0,0,1595,1598,1,0,0,0,1596,1594,1,0,0,0,1596,
  	1597,1,0,0,0,1597,1601,1,0,0,0,1598,1596,1,0,0,0,1599,1601,5,0,0,1,1600,
  	1596,1,0,0,0,1600,1599,1,0,0,0,1601,193,1,0,0,0,1602,1603,5,217,0,0,1603,
  	195,1,0,0,0,1604,1607,5,217,0,0,1605,1607,3,258,129,0,1606,1604,1,0,0,
  	0,1606,1605,1,0,0,0,1607,197,1,0,0,0,1608,1613,3,200,100,0,1609,1613,
  	3,202,101,0,1610,1613,3,204,102,0,1611,1613,3,236,118,0,1612,1608,1,0,
  	0,0,1612,1609,1,0,0,0,1612,1610,1,0,0,0,1612,1611,1,0,0,0,1613,199,1,
  	0,0,0,1614,1616,5,195,0,0,1615,1614,1,0,0,0,1615,1616,1,0,0,0,1616,1619,
  	1,0,0,0,1617,1620,5,218,0,0,1618,1620,3,218,109,0,1619,1617,1,0,0,0,1619,
  	1618,1,0,0,0,1620,1622,1,0,0,0,1621,1623,5,196,0,0,1622,1621,1,0,0,0,
  	1622,1623,1,0,0,0,1623,201,1,0,0,0,1624,1626,7,1,0,0,1625,1627,5,168,
  	0,0,1626,1625,1,0,0,0,1626,1627,1,0,0,0,1627,1628,1,0,0,0,1628,1639,5,
  	191,0,0,1629,1631,3,246,123,0,1630,1629,1,0,0,0,1631,1632,1,0,0,0,1632,
  	1630,1,0,0,0,1632,1633,1,0,0,0,1633,1640,1,0,0,0,1634,1636,3,218,109,
  	0,1635,1634,1,0,0,0,1636,1637,1,0,0,0,1637,1635,1,0,0,0,1637,1638,1,0,
  	0,0,1638,1640,1,0,0,0,1639,1630,1,0,0,0,1639,1635,1,0,0,0,1640,1641,1,
  	0,0,0,1641,1642,5,192,0,0,1642,1682,1,0,0,0,1643,1645,7,1,0,0,1644,1646,
  	5,168,0,0,1645,1644,1,0,0,0,1645,1646,1,0,0,0,1646,1647,1,0,0,0,1647,
  	1658,5,193,0,0,1648,1650,3,246,123,0,1649,1648,1,0,0,0,1650,1651,1,0,
  	0,0,1651,1649,1,0,0,0,1651,1652,1,0,0,0,1652,1659,1,0,0,0,1653,1655,3,
  	218,109,0,1654,1653,1,0,0,0,1655,1656,1,0,0,0,1656,1654,1,0,0,0,1656,
  	1657,1,0,0,0,1657,1659,1,0,0,0,1658,1649,1,0,0,0,1658,1654,1,0,0,0,1659,
  	1660,1,0,0,0,1660,1661,5,194,0,0,1661,1682,1,0,0,0,1662,1664,7,1,0,0,
  	1663,1665,5,168,0,0,1664,1663,1,0,0,0,1664,1665,1,0,0,0,1665,1666,1,0,
  	0,0,1666,1677,5,195,0,0,1667,1669,3,246,123,0,1668,1667,1,0,0,0,1669,
  	1670,1,0,0,0,1670,1668,1,0,0,0,1670,1671,1,0,0,0,1671,1678,1,0,0,0,1672,
  	1674,3,218,109,0,1673,1672,1,0,0,0,1674,1675,1,0,0,0,1675,1673,1,0,0,
  	0,1675,1676,1,0,0,0,1676,1678,1,0,0,0,1677,1668,1,0,0,0,1677,1673,1,0,
  	0,0,1678,1679,1,0,0,0,1679,1680,5,195,0,0,1680,1682,1,0,0,0,1681,1624,
  	1,0,0,0,1681,1643,1,0,0,0,1681,1662,1,0,0,0,1682,203,1,0,0,0,1683,1684,
  	7,2,0,0,1684,1686,5,195,0,0,1685,1687,3,218,109,0,1686,1685,1,0,0,0,1686,
  	1687,1,0,0,0,1687,1688,1,0,0,0,1688,1694,5,196,0,0,1689,1691,7,2,0,0,
  	1690,1692,3,218,109,0,1691,1690,1,0,0,0,1691,1692,1,0,0,0,1692,1694,1,
  	0,0,0,1693,1683,1,0,0,0,1693,1689,1,0,0,0,1694,205,1,0,0,0,1695,1697,
  	3,208,104,0,1696,1695,1,0,0,0,1697,1698,1,0,0,0,1698,1696,1,0,0,0,1698,
  	1699,1,0,0,0,1699,1709,1,0,0,0,1700,1702,5,191,0,0,1701,1703,3,208,104,
  	0,1702,1701,1,0,0,0,1703,1704,1,0,0,0,1704,1702,1,0,0,0,1704,1705,1,0,
  	0,0,1705,1706,1,0,0,0,1706,1707,5,192,0,0,1707,1709,1,0,0,0,1708,1696,
  	1,0,0,0,1708,1700,1,0,0,0,1709,207,1,0,0,0,1710,1714,3,216,108,0,1711,
  	1714,3,210,105,0,1712,1714,3,214,107,0,1713,1710,1,0,0,0,1713,1711,1,
  	0,0,0,1713,1712,1,0,0,0,1714,209,1,0,0,0,1715,1716,3,216,108,0,1716,1717,
  	5,168,0,0,1717,1718,3,216,108,0,1718,211,1,0,0,0,1719,1720,3,216,108,
  	0,1720,1721,5,198,0,0,1721,1722,3,216,108,0,1722,213,1,0,0,0,1723,1724,
  	3,216,108,0,1724,1725,5,186,0,0,1725,1726,3,216,108,0,1726,215,1,0,0,
  	0,1727,1730,7,3,0,0,1728,1729,5,201,0,0,1729,1731,3,216,108,0,1730,1728,
  	1,0,0,0,1730,1731,1,0,0,0,1731,217,1,0,0,0,1732,1733,6,109,-1,0,1733,
  	1739,3,220,110,0,1734,1739,3,222,111,0,1735,1739,3,226,113,0,1736,1739,
  	3,230,115,0,1737,1739,3,224,112,0,1738,1732,1,0,0,0,1738,1734,1,0,0,0,
  	1738,1735,1,0,0,0,1738,1736,1,0,0,0,1738,1737,1,0,0,0,1739,1753,1,0,0,
  	0,1740,1741,10,1,0,0,1741,1742,5,197,0,0,1742,1743,3,218,109,0,1743,1744,
  	5,186,0,0,1744,1745,3,218,109,2,1745,1752,1,0,0,0,1746,1747,10,2,0,0,
  	1747,1749,3,228,114,0,1748,1750,3,218,109,0,1749,1748,1,0,0,0,1749,1750,
  	1,0,0,0,1750,1752,1,0,0,0,1751,1740,1,0,0,0,1751,1746,1,0,0,0,1752,1755,
  	1,0,0,0,1753,1751,1,0,0,0,1753,1754,1,0,0,0,1754,219,1,0,0,0,1755,1753,
  	1,0,0,0,1756,1757,7,4,0,0,1757,1758,3,218,109,0,1758,221,1,0,0,0,1759,
  	1760,5,217,0,0,1760,1765,5,191,0,0,1761,1763,3,218,109,0,1762,1764,5,
  	198,0,0,1763,1762,1,0,0,0,1763,1764,1,0,0,0,1764,1766,1,0,0,0,1765,1761,
  	1,0,0,0,1766,1767,1,0,0,0,1767,1765,1,0,0,0,1767,1768,1,0,0,0,1768,1769,
  	1,0,0,0,1769,1770,5,192,0,0,1770,223,1,0,0,0,1771,1772,3,230,115,0,1772,
  	1773,5,198,0,0,1773,1774,3,230,115,0,1774,225,1,0,0,0,1775,1780,7,5,0,
  	0,1776,1778,3,218,109,0,1777,1779,5,198,0,0,1778,1777,1,0,0,0,1778,1779,
  	1,0,0,0,1779,1781,1,0,0,0,1780,1776,1,0,0,0,1781,1782,1,0,0,0,1782,1780,
  	1,0,0,0,1782,1783,1,0,0,0,1783,1784,1,0,0,0,1784,1785,7,6,0,0,1785,227,
  	1,0,0,0,1786,1787,7,7,0,0,1787,229,1,0,0,0,1788,1797,5,216,0,0,1789,1797,
  	5,217,0,0,1790,1797,5,218,0,0,1791,1797,5,214,0,0,1792,1797,5,218,0,0,
  	1793,1797,3,254,127,0,1794,1797,3,256,128,0,1795,1797,3,258,129,0,1796,
  	1788,1,0,0,0,1796,1789,1,0,0,0,1796,1790,1,0,0,0,1796,1791,1,0,0,0,1796,
  	1792,1,0,0,0,1796,1793,1,0,0,0,1796,1794,1,0,0,0,1796,1795,1,0,0,0,1797,
  	231,1,0,0,0,1798,1800,5,39,0,0,1799,1798,1,0,0,0,1799,1800,1,0,0,0,1800,
  	1802,1,0,0,0,1801,1803,5,191,0,0,1802,1801,1,0,0,0,1802,1803,1,0,0,0,
  	1803,1805,1,0,0,0,1804,1806,3,234,117,0,1805,1804,1,0,0,0,1806,1807,1,
  	0,0,0,1807,1805,1,0,0,0,1807,1808,1,0,0,0,1808,1810,1,0,0,0,1809,1811,
  	5,192,0,0,1810,1809,1,0,0,0,1810,1811,1,0,0,0,1811,233,1,0,0,0,1812,1815,
  	3,236,118,0,1813,1815,3,238,119,0,1814,1812,1,0,0,0,1814,1813,1,0,0,0,
  	1815,235,1,0,0,0,1816,1817,3,238,119,0,1817,1818,5,168,0,0,1818,1819,
  	3,218,109,0,1819,1825,1,0,0,0,1820,1821,3,238,119,0,1821,1822,5,168,0,
  	0,1822,1823,3,250,125,0,1823,1825,1,0,0,0,1824,1816,1,0,0,0,1824,1820,
  	1,0,0,0,1825,237,1,0,0,0,1826,1828,7,8,0,0,1827,1829,3,226,113,0,1828,
  	1827,1,0,0,0,1828,1829,1,0,0,0,1829,239,1,0,0,0,1830,1831,5,186,0,0,1831,
  	1832,7,3,0,0,1832,241,1,0,0,0,1833,1835,5,217,0,0,1834,1833,1,0,0,0,1834,
  	1835,1,0,0,0,1835,1836,1,0,0,0,1836,1840,5,191,0,0,1837,1841,3,218,109,
  	0,1838,1841,3,212,106,0,1839,1841,3,216,108,0,1840,1837,1,0,0,0,1840,
  	1838,1,0,0,0,1840,1839,1,0,0,0,1841,1842,1,0,0,0,1842,1843,5,192,0,0,
  	1843,243,1,0,0,0,1844,1845,3,242,121,0,1845,1846,5,168,0,0,1846,1847,
  	3,218,109,0,1847,245,1,0,0,0,1848,1849,3,248,124,0,1849,1850,3,218,109,
  	0,1850,1857,1,0,0,0,1851,1852,3,248,124,0,1852,1853,5,195,0,0,1853,1854,
  	3,218,109,0,1854,1855,5,196,0,0,1855,1857,1,0,0,0,1856,1848,1,0,0,0,1856,
  	1851,1,0,0,0,1857,247,1,0,0,0,1858,1859,3,218,109,0,1859,249,1,0,0,0,
  	1860,1861,3,252,126,0,1861,251,1,0,0,0,1862,1879,5,217,0,0,1863,1879,
  	5,218,0,0,1864,1865,5,217,0,0,1865,1879,3,252,126,0,1866,1867,5,207,0,
  	0,1867,1868,3,252,126,0,1868,1869,5,207,0,0,1869,1879,1,0,0,0,1870,1871,
  	5,206,0,0,1871,1879,3,252,126,0,1872,1873,5,201,0,0,1873,1879,3,252,126,
  	0,1874,1875,5,189,0,0,1875,1879,3,252,126,0,1876,1877,5,199,0,0,1877,
  	1879,3,252,126,0,1878,1862,1,0,0,0,1878,1863,1,0,0,0,1878,1864,1,0,0,
  	0,1878,1866,1,0,0,0,1878,1870,1,0,0,0,1878,1872,1,0,0,0,1878,1874,1,0,
  	0,0,1878,1876,1,0,0,0,1879,253,1,0,0,0,1880,1881,7,9,0,0,1881,255,1,0,
  	0,0,1882,1883,7,10,0,0,1883,257,1,0,0,0,1884,1885,7,11,0,0,1885,259,1,
  	0,0,0,303,261,266,270,275,280,284,289,294,298,313,318,323,328,332,339,
  	343,348,351,356,360,369,373,382,387,391,393,399,408,412,418,423,427,433,
  	442,446,452,457,461,467,473,480,485,491,496,500,506,514,521,524,531,533,
  	538,542,547,551,581,586,591,595,600,603,608,612,617,622,626,630,634,639,
  	643,647,651,656,660,665,670,674,679,684,688,694,703,709,716,720,728,732,
  	737,742,746,751,756,760,764,768,773,777,781,785,790,794,798,802,807,811,
  	815,819,824,828,833,838,842,846,850,855,859,863,867,872,876,880,884,889,
  	893,898,903,907,911,915,920,924,929,934,938,942,946,951,955,959,963,968,
  	972,976,980,984,989,993,999,1007,1015,1023,1033,1039,1046,1050,1059,1063,
  	1069,1073,1077,1081,1086,1090,1095,1100,1104,1111,1115,1121,1126,1130,
  	1136,1149,1154,1159,1163,1170,1179,1186,1190,1198,1202,1208,1213,1217,
  	1225,1229,1234,1239,1243,1248,1253,1257,1262,1267,1271,1276,1281,1285,
  	1290,1295,1299,1303,1310,1314,1318,1323,1327,1333,1341,1348,1356,1362,
  	1366,1372,1379,1385,1391,1395,1401,1408,1414,1420,1424,1433,1439,1443,
  	1452,1458,1464,1468,1470,1477,1481,1486,1491,1495,1501,1508,1513,1520,
  	1525,1531,1535,1542,1546,1553,1559,1563,1569,1574,1578,1580,1584,1590,
  	1596,1600,1606,1612,1615,1619,1622,1626,1632,1637,1639,1645,1651,1656,
  	1658,1664,1670,1675,1677,1681,1686,1691,1693,1698,1704,1708,1713,1730,
  	1738,1749,1751,1753,1763,1767,1778,1782,1796,1799,1802,1807,1810,1814,
  	1824,1828,1834,1840,1856,1878
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  spectreparserParserStaticData = std::move(staticData);
}

}

SPECTREParser::SPECTREParser(TokenStream *input) : SPECTREParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

SPECTREParser::SPECTREParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  SPECTREParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *spectreparserParserStaticData->atn, spectreparserParserStaticData->decisionToDFA, spectreparserParserStaticData->sharedContextCache, options);
}

SPECTREParser::~SPECTREParser() {
  delete _interpreter;
}

const atn::ATN& SPECTREParser::getATN() const {
  return *spectreparserParserStaticData->atn;
}

std::string SPECTREParser::getGrammarFileName() const {
  return "SPECTREParser.g4";
}

const std::vector<std::string>& SPECTREParser::getRuleNames() const {
  return spectreparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& SPECTREParser::getVocabulary() const {
  return spectreparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView SPECTREParser::getSerializedATN() const {
  return spectreparserParserStaticData->serializedATN;
}


//----------------- NetlistContext ------------------------------------------------------------------

SPECTREParser::NetlistContext::NetlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SPECTREParser::NetlistContext::EOF() {
  return getTokens(SPECTREParser::EOF);
}

tree::TerminalNode* SPECTREParser::NetlistContext::EOF(size_t i) {
  return getToken(SPECTREParser::EOF, i);
}

SPECTREParser::Netlist_titleContext* SPECTREParser::NetlistContext::netlist_title() {
  return getRuleContext<SPECTREParser::Netlist_titleContext>(0);
}

std::vector<SPECTREParser::Netlist_entityContext *> SPECTREParser::NetlistContext::netlist_entity() {
  return getRuleContexts<SPECTREParser::Netlist_entityContext>();
}

SPECTREParser::Netlist_entityContext* SPECTREParser::NetlistContext::netlist_entity(size_t i) {
  return getRuleContext<SPECTREParser::Netlist_entityContext>(i);
}

std::vector<tree::TerminalNode *> SPECTREParser::NetlistContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::NetlistContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::NetlistContext::getRuleIndex() const {
  return SPECTREParser::RuleNetlist;
}

void SPECTREParser::NetlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNetlist(this);
}

void SPECTREParser::NetlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNetlist(this);
}


std::any SPECTREParser::NetlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNetlist(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::NetlistContext* SPECTREParser::netlist() {
  NetlistContext *_localctx = _tracker.createInstance<NetlistContext>(_ctx, getState());
  enterRule(_localctx, 0, SPECTREParser::RuleNetlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(261);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      setState(260);
      netlist_title();
      break;
    }

    default:
      break;
    }
    setState(270);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::GLOBAL:
      case SPECTREParser::INCLUDE:
      case SPECTREParser::CPP_INCLUDE:
      case SPECTREParser::AHDL_INCLUDE:
      case SPECTREParser::LIBRARY:
      case SPECTREParser::SECTION:
      case SPECTREParser::SUBCKT:
      case SPECTREParser::INLINE_SUBCKT:
      case SPECTREParser::SIMULATOR:
      case SPECTREParser::GLOBAL_PARAMETERS:
      case SPECTREParser::MODEL:
      case SPECTREParser::SAVE:
      case SPECTREParser::NODESET:
      case SPECTREParser::IC:
      case SPECTREParser::STATISTICS:
      case SPECTREParser::SENS:
      case SPECTREParser::ID:
      case SPECTREParser::NL: {
        setState(266);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(263);
          match(SPECTREParser::NL);
          setState(268);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(269);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(273); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(272);
      netlist_entity();
      setState(275); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 17592236567932) != 0) || _la == SPECTREParser::SENS || _la == SPECTREParser::ID);
    setState(284);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      setState(280);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SPECTREParser::NL) {
        setState(277);
        match(SPECTREParser::NL);
        setState(282);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(283);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Netlist_titleContext ------------------------------------------------------------------

SPECTREParser::Netlist_titleContext::Netlist_titleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Netlist_titleContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Netlist_titleContext::ID() {
  return getTokens(SPECTREParser::ID);
}

tree::TerminalNode* SPECTREParser::Netlist_titleContext::ID(size_t i) {
  return getToken(SPECTREParser::ID, i);
}

std::vector<tree::TerminalNode *> SPECTREParser::Netlist_titleContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Netlist_titleContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Netlist_titleContext::getRuleIndex() const {
  return SPECTREParser::RuleNetlist_title;
}

void SPECTREParser::Netlist_titleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNetlist_title(this);
}

void SPECTREParser::Netlist_titleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNetlist_title(this);
}


std::any SPECTREParser::Netlist_titleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNetlist_title(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Netlist_titleContext* SPECTREParser::netlist_title() {
  Netlist_titleContext *_localctx = _tracker.createInstance<Netlist_titleContext>(_ctx, getState());
  enterRule(_localctx, 2, SPECTREParser::RuleNetlist_title);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(287); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(286);
              match(SPECTREParser::ID);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(289); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(298);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      setState(294);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(291);
          match(SPECTREParser::NL); 
        }
        setState(296);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
      }
      break;
    }

    case 2: {
      setState(297);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Netlist_entityContext ------------------------------------------------------------------

SPECTREParser::Netlist_entityContext::Netlist_entityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::IncludeContext* SPECTREParser::Netlist_entityContext::include() {
  return getRuleContext<SPECTREParser::IncludeContext>(0);
}

SPECTREParser::LibraryContext* SPECTREParser::Netlist_entityContext::library() {
  return getRuleContext<SPECTREParser::LibraryContext>(0);
}

SPECTREParser::SubcktContext* SPECTREParser::Netlist_entityContext::subckt() {
  return getRuleContext<SPECTREParser::SubcktContext>(0);
}

SPECTREParser::AnalysisContext* SPECTREParser::Netlist_entityContext::analysis() {
  return getRuleContext<SPECTREParser::AnalysisContext>(0);
}

SPECTREParser::GlobalContext* SPECTREParser::Netlist_entityContext::global() {
  return getRuleContext<SPECTREParser::GlobalContext>(0);
}

SPECTREParser::ModelContext* SPECTREParser::Netlist_entityContext::model() {
  return getRuleContext<SPECTREParser::ModelContext>(0);
}

SPECTREParser::Global_declarationsContext* SPECTREParser::Netlist_entityContext::global_declarations() {
  return getRuleContext<SPECTREParser::Global_declarationsContext>(0);
}

SPECTREParser::ControlContext* SPECTREParser::Netlist_entityContext::control() {
  return getRuleContext<SPECTREParser::ControlContext>(0);
}

SPECTREParser::ComponentContext* SPECTREParser::Netlist_entityContext::component() {
  return getRuleContext<SPECTREParser::ComponentContext>(0);
}

SPECTREParser::LangContext* SPECTREParser::Netlist_entityContext::lang() {
  return getRuleContext<SPECTREParser::LangContext>(0);
}

SPECTREParser::SectionContext* SPECTREParser::Netlist_entityContext::section() {
  return getRuleContext<SPECTREParser::SectionContext>(0);
}

SPECTREParser::AnalogmodelContext* SPECTREParser::Netlist_entityContext::analogmodel() {
  return getRuleContext<SPECTREParser::AnalogmodelContext>(0);
}

SPECTREParser::StatisticsContext* SPECTREParser::Netlist_entityContext::statistics() {
  return getRuleContext<SPECTREParser::StatisticsContext>(0);
}


size_t SPECTREParser::Netlist_entityContext::getRuleIndex() const {
  return SPECTREParser::RuleNetlist_entity;
}

void SPECTREParser::Netlist_entityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNetlist_entity(this);
}

void SPECTREParser::Netlist_entityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNetlist_entity(this);
}


std::any SPECTREParser::Netlist_entityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNetlist_entity(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Netlist_entityContext* SPECTREParser::netlist_entity() {
  Netlist_entityContext *_localctx = _tracker.createInstance<Netlist_entityContext>(_ctx, getState());
  enterRule(_localctx, 4, SPECTREParser::RuleNetlist_entity);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(313);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(300);
      include();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(301);
      library();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(302);
      subckt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(303);
      analysis();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(304);
      global();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(305);
      model();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(306);
      global_declarations();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(307);
      control();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(308);
      component();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(309);
      lang();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(310);
      section();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(311);
      analogmodel();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(312);
      statistics();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncludeContext ------------------------------------------------------------------

SPECTREParser::IncludeContext::IncludeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Standard_includeContext* SPECTREParser::IncludeContext::standard_include() {
  return getRuleContext<SPECTREParser::Standard_includeContext>(0);
}

SPECTREParser::Cpp_includeContext* SPECTREParser::IncludeContext::cpp_include() {
  return getRuleContext<SPECTREParser::Cpp_includeContext>(0);
}

SPECTREParser::Ahdl_includeContext* SPECTREParser::IncludeContext::ahdl_include() {
  return getRuleContext<SPECTREParser::Ahdl_includeContext>(0);
}


size_t SPECTREParser::IncludeContext::getRuleIndex() const {
  return SPECTREParser::RuleInclude;
}

void SPECTREParser::IncludeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInclude(this);
}

void SPECTREParser::IncludeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInclude(this);
}


std::any SPECTREParser::IncludeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitInclude(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::IncludeContext* SPECTREParser::include() {
  IncludeContext *_localctx = _tracker.createInstance<IncludeContext>(_ctx, getState());
  enterRule(_localctx, 6, SPECTREParser::RuleInclude);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(318);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::INCLUDE: {
        enterOuterAlt(_localctx, 1);
        setState(315);
        standard_include();
        break;
      }

      case SPECTREParser::CPP_INCLUDE: {
        enterOuterAlt(_localctx, 2);
        setState(316);
        cpp_include();
        break;
      }

      case SPECTREParser::AHDL_INCLUDE: {
        enterOuterAlt(_localctx, 3);
        setState(317);
        ahdl_include();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Standard_includeContext ------------------------------------------------------------------

SPECTREParser::Standard_includeContext::Standard_includeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Standard_includeContext::INCLUDE() {
  return getToken(SPECTREParser::INCLUDE, 0);
}

SPECTREParser::FilepathContext* SPECTREParser::Standard_includeContext::filepath() {
  return getRuleContext<SPECTREParser::FilepathContext>(0);
}

tree::TerminalNode* SPECTREParser::Standard_includeContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_assignContext* SPECTREParser::Standard_includeContext::parameter_assign() {
  return getRuleContext<SPECTREParser::Parameter_assignContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Standard_includeContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Standard_includeContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Standard_includeContext::getRuleIndex() const {
  return SPECTREParser::RuleStandard_include;
}

void SPECTREParser::Standard_includeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandard_include(this);
}

void SPECTREParser::Standard_includeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandard_include(this);
}


std::any SPECTREParser::Standard_includeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitStandard_include(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Standard_includeContext* SPECTREParser::standard_include() {
  Standard_includeContext *_localctx = _tracker.createInstance<Standard_includeContext>(_ctx, getState());
  enterRule(_localctx, 8, SPECTREParser::RuleStandard_include);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(320);
    match(SPECTREParser::INCLUDE);
    setState(321);
    filepath();
    setState(323);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(322);
      parameter_assign();
      break;
    }

    default:
      break;
    }
    setState(332);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      setState(328);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(325);
          match(SPECTREParser::NL); 
        }
        setState(330);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
      }
      break;
    }

    case 2: {
      setState(331);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cpp_includeContext ------------------------------------------------------------------

SPECTREParser::Cpp_includeContext::Cpp_includeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Cpp_includeContext::CPP_INCLUDE() {
  return getToken(SPECTREParser::CPP_INCLUDE, 0);
}

SPECTREParser::FilepathContext* SPECTREParser::Cpp_includeContext::filepath() {
  return getRuleContext<SPECTREParser::FilepathContext>(0);
}

tree::TerminalNode* SPECTREParser::Cpp_includeContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Cpp_includeContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Cpp_includeContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Cpp_includeContext::getRuleIndex() const {
  return SPECTREParser::RuleCpp_include;
}

void SPECTREParser::Cpp_includeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCpp_include(this);
}

void SPECTREParser::Cpp_includeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCpp_include(this);
}


std::any SPECTREParser::Cpp_includeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitCpp_include(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Cpp_includeContext* SPECTREParser::cpp_include() {
  Cpp_includeContext *_localctx = _tracker.createInstance<Cpp_includeContext>(_ctx, getState());
  enterRule(_localctx, 10, SPECTREParser::RuleCpp_include);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(334);
    match(SPECTREParser::CPP_INCLUDE);
    setState(335);
    filepath();
    setState(343);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      setState(339);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(336);
          match(SPECTREParser::NL); 
        }
        setState(341);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
      }
      break;
    }

    case 2: {
      setState(342);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ahdl_includeContext ------------------------------------------------------------------

SPECTREParser::Ahdl_includeContext::Ahdl_includeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Ahdl_includeContext::AHDL_INCLUDE() {
  return getToken(SPECTREParser::AHDL_INCLUDE, 0);
}

SPECTREParser::FilepathContext* SPECTREParser::Ahdl_includeContext::filepath() {
  return getRuleContext<SPECTREParser::FilepathContext>(0);
}

tree::TerminalNode* SPECTREParser::Ahdl_includeContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

tree::TerminalNode* SPECTREParser::Ahdl_includeContext::MINUS() {
  return getToken(SPECTREParser::MINUS, 0);
}

tree::TerminalNode* SPECTREParser::Ahdl_includeContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Ahdl_includeContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Ahdl_includeContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Ahdl_includeContext::getRuleIndex() const {
  return SPECTREParser::RuleAhdl_include;
}

void SPECTREParser::Ahdl_includeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAhdl_include(this);
}

void SPECTREParser::Ahdl_includeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAhdl_include(this);
}


std::any SPECTREParser::Ahdl_includeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAhdl_include(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Ahdl_includeContext* SPECTREParser::ahdl_include() {
  Ahdl_includeContext *_localctx = _tracker.createInstance<Ahdl_includeContext>(_ctx, getState());
  enterRule(_localctx, 12, SPECTREParser::RuleAhdl_include);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(345);
    match(SPECTREParser::AHDL_INCLUDE);
    setState(346);
    filepath();
    setState(348);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SPECTREParser::MINUS) {
      setState(347);
      match(SPECTREParser::MINUS);
    }
    setState(351);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      setState(350);
      match(SPECTREParser::ID);
      break;
    }

    default:
      break;
    }
    setState(360);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      setState(356);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(353);
          match(SPECTREParser::NL); 
        }
        setState(358);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
      }
      break;
    }

    case 2: {
      setState(359);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LangContext ------------------------------------------------------------------

SPECTREParser::LangContext::LangContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::LangContext::SIMULATOR() {
  return getToken(SPECTREParser::SIMULATOR, 0);
}

tree::TerminalNode* SPECTREParser::LangContext::LANGUAGE() {
  return getToken(SPECTREParser::LANGUAGE, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::LangContext::EQUAL() {
  return getTokens(SPECTREParser::EQUAL);
}

tree::TerminalNode* SPECTREParser::LangContext::EQUAL(size_t i) {
  return getToken(SPECTREParser::EQUAL, i);
}

tree::TerminalNode* SPECTREParser::LangContext::SPICE() {
  return getToken(SPECTREParser::SPICE, 0);
}

tree::TerminalNode* SPECTREParser::LangContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::LangContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::LangContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}

tree::TerminalNode* SPECTREParser::LangContext::SPECTRE() {
  return getToken(SPECTREParser::SPECTRE, 0);
}

tree::TerminalNode* SPECTREParser::LangContext::INSENSITIVE() {
  return getToken(SPECTREParser::INSENSITIVE, 0);
}

tree::TerminalNode* SPECTREParser::LangContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}


size_t SPECTREParser::LangContext::getRuleIndex() const {
  return SPECTREParser::RuleLang;
}

void SPECTREParser::LangContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLang(this);
}

void SPECTREParser::LangContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLang(this);
}


std::any SPECTREParser::LangContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitLang(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::LangContext* SPECTREParser::lang() {
  LangContext *_localctx = _tracker.createInstance<LangContext>(_ctx, getState());
  enterRule(_localctx, 14, SPECTREParser::RuleLang);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(393);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(362);
      match(SPECTREParser::SIMULATOR);
      setState(363);
      match(SPECTREParser::LANGUAGE);
      setState(364);
      match(SPECTREParser::EQUAL);
      setState(365);
      match(SPECTREParser::SPICE);
      setState(373);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
      case 1: {
        setState(369);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(366);
            match(SPECTREParser::NL); 
          }
          setState(371);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
        }
        break;
      }

      case 2: {
        setState(372);
        match(SPECTREParser::EOF);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(375);
      match(SPECTREParser::SIMULATOR);
      setState(376);
      match(SPECTREParser::LANGUAGE);
      setState(377);
      match(SPECTREParser::EQUAL);
      setState(378);
      match(SPECTREParser::SPECTRE);
      setState(382);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SPECTREParser::INSENSITIVE) {
        setState(379);
        match(SPECTREParser::INSENSITIVE);
        setState(380);
        match(SPECTREParser::EQUAL);
        setState(381);
        match(SPECTREParser::ID);
      }
      setState(391);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
      case 1: {
        setState(387);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(384);
            match(SPECTREParser::NL); 
          }
          setState(389);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
        }
        break;
      }

      case 2: {
        setState(390);
        match(SPECTREParser::EOF);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LibraryContext ------------------------------------------------------------------

SPECTREParser::LibraryContext::LibraryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Library_headerContext* SPECTREParser::LibraryContext::library_header() {
  return getRuleContext<SPECTREParser::Library_headerContext>(0);
}

SPECTREParser::Library_footerContext* SPECTREParser::LibraryContext::library_footer() {
  return getRuleContext<SPECTREParser::Library_footerContext>(0);
}

std::vector<SPECTREParser::Library_contentContext *> SPECTREParser::LibraryContext::library_content() {
  return getRuleContexts<SPECTREParser::Library_contentContext>();
}

SPECTREParser::Library_contentContext* SPECTREParser::LibraryContext::library_content(size_t i) {
  return getRuleContext<SPECTREParser::Library_contentContext>(i);
}


size_t SPECTREParser::LibraryContext::getRuleIndex() const {
  return SPECTREParser::RuleLibrary;
}

void SPECTREParser::LibraryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary(this);
}

void SPECTREParser::LibraryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary(this);
}


std::any SPECTREParser::LibraryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitLibrary(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::LibraryContext* SPECTREParser::library() {
  LibraryContext *_localctx = _tracker.createInstance<LibraryContext>(_ctx, getState());
  enterRule(_localctx, 16, SPECTREParser::RuleLibrary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(395);
    library_header();
    setState(397); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(396);
      library_content();
      setState(399); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 17592236567932) != 0) || _la == SPECTREParser::SENS || _la == SPECTREParser::ID);
    setState(401);
    library_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_headerContext ------------------------------------------------------------------

SPECTREParser::Library_headerContext::Library_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Library_headerContext::LIBRARY() {
  return getToken(SPECTREParser::LIBRARY, 0);
}

tree::TerminalNode* SPECTREParser::Library_headerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Library_headerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Library_headerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Library_headerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Library_headerContext::getRuleIndex() const {
  return SPECTREParser::RuleLibrary_header;
}

void SPECTREParser::Library_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_header(this);
}

void SPECTREParser::Library_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_header(this);
}


std::any SPECTREParser::Library_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_header(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Library_headerContext* SPECTREParser::library_header() {
  Library_headerContext *_localctx = _tracker.createInstance<Library_headerContext>(_ctx, getState());
  enterRule(_localctx, 18, SPECTREParser::RuleLibrary_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(403);
    match(SPECTREParser::LIBRARY);
    setState(404);
    match(SPECTREParser::ID);
    setState(412);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::GLOBAL:
      case SPECTREParser::INCLUDE:
      case SPECTREParser::CPP_INCLUDE:
      case SPECTREParser::AHDL_INCLUDE:
      case SPECTREParser::LIBRARY:
      case SPECTREParser::SECTION:
      case SPECTREParser::SUBCKT:
      case SPECTREParser::INLINE_SUBCKT:
      case SPECTREParser::SIMULATOR:
      case SPECTREParser::GLOBAL_PARAMETERS:
      case SPECTREParser::MODEL:
      case SPECTREParser::SAVE:
      case SPECTREParser::NODESET:
      case SPECTREParser::IC:
      case SPECTREParser::STATISTICS:
      case SPECTREParser::SENS:
      case SPECTREParser::ID:
      case SPECTREParser::NL: {
        setState(408);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(405);
          match(SPECTREParser::NL);
          setState(410);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(411);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_contentContext ------------------------------------------------------------------

SPECTREParser::Library_contentContext::Library_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Netlist_entityContext* SPECTREParser::Library_contentContext::netlist_entity() {
  return getRuleContext<SPECTREParser::Netlist_entityContext>(0);
}


size_t SPECTREParser::Library_contentContext::getRuleIndex() const {
  return SPECTREParser::RuleLibrary_content;
}

void SPECTREParser::Library_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_content(this);
}

void SPECTREParser::Library_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_content(this);
}


std::any SPECTREParser::Library_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_content(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Library_contentContext* SPECTREParser::library_content() {
  Library_contentContext *_localctx = _tracker.createInstance<Library_contentContext>(_ctx, getState());
  enterRule(_localctx, 20, SPECTREParser::RuleLibrary_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(414);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_footerContext ------------------------------------------------------------------

SPECTREParser::Library_footerContext::Library_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Library_footerContext::LIBRARY_END() {
  return getToken(SPECTREParser::LIBRARY_END, 0);
}

tree::TerminalNode* SPECTREParser::Library_footerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

tree::TerminalNode* SPECTREParser::Library_footerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Library_footerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Library_footerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Library_footerContext::getRuleIndex() const {
  return SPECTREParser::RuleLibrary_footer;
}

void SPECTREParser::Library_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_footer(this);
}

void SPECTREParser::Library_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_footer(this);
}


std::any SPECTREParser::Library_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_footer(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Library_footerContext* SPECTREParser::library_footer() {
  Library_footerContext *_localctx = _tracker.createInstance<Library_footerContext>(_ctx, getState());
  enterRule(_localctx, 22, SPECTREParser::RuleLibrary_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(416);
    match(SPECTREParser::LIBRARY_END);
    setState(418);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      setState(417);
      match(SPECTREParser::ID);
      break;
    }

    default:
      break;
    }
    setState(427);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(423);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(420);
          match(SPECTREParser::NL); 
        }
        setState(425);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
      }
      break;
    }

    case 2: {
      setState(426);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SectionContext ------------------------------------------------------------------

SPECTREParser::SectionContext::SectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Section_headerContext* SPECTREParser::SectionContext::section_header() {
  return getRuleContext<SPECTREParser::Section_headerContext>(0);
}

SPECTREParser::Section_footerContext* SPECTREParser::SectionContext::section_footer() {
  return getRuleContext<SPECTREParser::Section_footerContext>(0);
}

std::vector<SPECTREParser::Section_contentContext *> SPECTREParser::SectionContext::section_content() {
  return getRuleContexts<SPECTREParser::Section_contentContext>();
}

SPECTREParser::Section_contentContext* SPECTREParser::SectionContext::section_content(size_t i) {
  return getRuleContext<SPECTREParser::Section_contentContext>(i);
}


size_t SPECTREParser::SectionContext::getRuleIndex() const {
  return SPECTREParser::RuleSection;
}

void SPECTREParser::SectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSection(this);
}

void SPECTREParser::SectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSection(this);
}


std::any SPECTREParser::SectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSection(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::SectionContext* SPECTREParser::section() {
  SectionContext *_localctx = _tracker.createInstance<SectionContext>(_ctx, getState());
  enterRule(_localctx, 24, SPECTREParser::RuleSection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(429);
    section_header();
    setState(431); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(430);
      section_content();
      setState(433); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 17592236567932) != 0) || _la == SPECTREParser::SENS || _la == SPECTREParser::ID);
    setState(435);
    section_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Section_headerContext ------------------------------------------------------------------

SPECTREParser::Section_headerContext::Section_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Section_headerContext::SECTION() {
  return getToken(SPECTREParser::SECTION, 0);
}

tree::TerminalNode* SPECTREParser::Section_headerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Section_headerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Section_headerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Section_headerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Section_headerContext::getRuleIndex() const {
  return SPECTREParser::RuleSection_header;
}

void SPECTREParser::Section_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSection_header(this);
}

void SPECTREParser::Section_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSection_header(this);
}


std::any SPECTREParser::Section_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSection_header(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Section_headerContext* SPECTREParser::section_header() {
  Section_headerContext *_localctx = _tracker.createInstance<Section_headerContext>(_ctx, getState());
  enterRule(_localctx, 26, SPECTREParser::RuleSection_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(437);
    match(SPECTREParser::SECTION);
    setState(438);
    match(SPECTREParser::ID);
    setState(446);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::GLOBAL:
      case SPECTREParser::INCLUDE:
      case SPECTREParser::CPP_INCLUDE:
      case SPECTREParser::AHDL_INCLUDE:
      case SPECTREParser::LIBRARY:
      case SPECTREParser::SECTION:
      case SPECTREParser::SUBCKT:
      case SPECTREParser::INLINE_SUBCKT:
      case SPECTREParser::SIMULATOR:
      case SPECTREParser::GLOBAL_PARAMETERS:
      case SPECTREParser::MODEL:
      case SPECTREParser::SAVE:
      case SPECTREParser::NODESET:
      case SPECTREParser::IC:
      case SPECTREParser::STATISTICS:
      case SPECTREParser::SENS:
      case SPECTREParser::ID:
      case SPECTREParser::NL: {
        setState(442);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(439);
          match(SPECTREParser::NL);
          setState(444);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(445);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Section_contentContext ------------------------------------------------------------------

SPECTREParser::Section_contentContext::Section_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Netlist_entityContext* SPECTREParser::Section_contentContext::netlist_entity() {
  return getRuleContext<SPECTREParser::Netlist_entityContext>(0);
}


size_t SPECTREParser::Section_contentContext::getRuleIndex() const {
  return SPECTREParser::RuleSection_content;
}

void SPECTREParser::Section_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSection_content(this);
}

void SPECTREParser::Section_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSection_content(this);
}


std::any SPECTREParser::Section_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSection_content(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Section_contentContext* SPECTREParser::section_content() {
  Section_contentContext *_localctx = _tracker.createInstance<Section_contentContext>(_ctx, getState());
  enterRule(_localctx, 28, SPECTREParser::RuleSection_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(448);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Section_footerContext ------------------------------------------------------------------

SPECTREParser::Section_footerContext::Section_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Section_footerContext::SECTION_END() {
  return getToken(SPECTREParser::SECTION_END, 0);
}

tree::TerminalNode* SPECTREParser::Section_footerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

tree::TerminalNode* SPECTREParser::Section_footerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Section_footerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Section_footerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Section_footerContext::getRuleIndex() const {
  return SPECTREParser::RuleSection_footer;
}

void SPECTREParser::Section_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSection_footer(this);
}

void SPECTREParser::Section_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSection_footer(this);
}


std::any SPECTREParser::Section_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSection_footer(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Section_footerContext* SPECTREParser::section_footer() {
  Section_footerContext *_localctx = _tracker.createInstance<Section_footerContext>(_ctx, getState());
  enterRule(_localctx, 30, SPECTREParser::RuleSection_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(450);
    match(SPECTREParser::SECTION_END);
    setState(452);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(451);
      match(SPECTREParser::ID);
      break;
    }

    default:
      break;
    }
    setState(461);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      setState(457);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(454);
          match(SPECTREParser::NL); 
        }
        setState(459);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
      }
      break;
    }

    case 2: {
      setState(460);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnalogmodelContext ------------------------------------------------------------------

SPECTREParser::AnalogmodelContext::AnalogmodelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::AnalogmodelContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::AnalogmodelContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

tree::TerminalNode* SPECTREParser::AnalogmodelContext::ANALOGMODEL() {
  return getToken(SPECTREParser::ANALOGMODEL, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::AnalogmodelContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}


size_t SPECTREParser::AnalogmodelContext::getRuleIndex() const {
  return SPECTREParser::RuleAnalogmodel;
}

void SPECTREParser::AnalogmodelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalogmodel(this);
}

void SPECTREParser::AnalogmodelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalogmodel(this);
}


std::any SPECTREParser::AnalogmodelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAnalogmodel(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::AnalogmodelContext* SPECTREParser::analogmodel() {
  AnalogmodelContext *_localctx = _tracker.createInstance<AnalogmodelContext>(_ctx, getState());
  enterRule(_localctx, 32, SPECTREParser::RuleAnalogmodel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(463);
    match(SPECTREParser::ID);
    setState(464);
    node_list();
    setState(465);
    match(SPECTREParser::ANALOGMODEL);
    setState(467);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      setState(466);
      parameter_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubcktContext ------------------------------------------------------------------

SPECTREParser::SubcktContext::SubcktContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Subckt_headerContext* SPECTREParser::SubcktContext::subckt_header() {
  return getRuleContext<SPECTREParser::Subckt_headerContext>(0);
}

SPECTREParser::Subckt_footerContext* SPECTREParser::SubcktContext::subckt_footer() {
  return getRuleContext<SPECTREParser::Subckt_footerContext>(0);
}

std::vector<SPECTREParser::Subckt_contentContext *> SPECTREParser::SubcktContext::subckt_content() {
  return getRuleContexts<SPECTREParser::Subckt_contentContext>();
}

SPECTREParser::Subckt_contentContext* SPECTREParser::SubcktContext::subckt_content(size_t i) {
  return getRuleContext<SPECTREParser::Subckt_contentContext>(i);
}


size_t SPECTREParser::SubcktContext::getRuleIndex() const {
  return SPECTREParser::RuleSubckt;
}

void SPECTREParser::SubcktContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt(this);
}

void SPECTREParser::SubcktContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt(this);
}


std::any SPECTREParser::SubcktContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSubckt(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::SubcktContext* SPECTREParser::subckt() {
  SubcktContext *_localctx = _tracker.createInstance<SubcktContext>(_ctx, getState());
  enterRule(_localctx, 34, SPECTREParser::RuleSubckt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(469);
    subckt_header();
    setState(471); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(470);
      subckt_content();
      setState(473); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 17592236567932) != 0) || _la == SPECTREParser::SENS || _la == SPECTREParser::ID);
    setState(475);
    subckt_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subckt_headerContext ------------------------------------------------------------------

SPECTREParser::Subckt_headerContext::Subckt_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Subckt_headerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Subckt_headerContext::INLINE_SUBCKT() {
  return getToken(SPECTREParser::INLINE_SUBCKT, 0);
}

tree::TerminalNode* SPECTREParser::Subckt_headerContext::SUBCKT() {
  return getToken(SPECTREParser::SUBCKT, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::Subckt_headerContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Subckt_headerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Subckt_headerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Subckt_headerContext::getRuleIndex() const {
  return SPECTREParser::RuleSubckt_header;
}

void SPECTREParser::Subckt_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt_header(this);
}

void SPECTREParser::Subckt_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt_header(this);
}


std::any SPECTREParser::Subckt_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSubckt_header(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Subckt_headerContext* SPECTREParser::subckt_header() {
  Subckt_headerContext *_localctx = _tracker.createInstance<Subckt_headerContext>(_ctx, getState());
  enterRule(_localctx, 36, SPECTREParser::RuleSubckt_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(477);
    _la = _input->LA(1);
    if (!(_la == SPECTREParser::SUBCKT

    || _la == SPECTREParser::INLINE_SUBCKT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(478);
    match(SPECTREParser::ID);
    setState(480);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(479);
      node_list();
    }
    setState(483); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(482);
      match(SPECTREParser::NL);
      setState(485); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SPECTREParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subckt_contentContext ------------------------------------------------------------------

SPECTREParser::Subckt_contentContext::Subckt_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Netlist_entityContext* SPECTREParser::Subckt_contentContext::netlist_entity() {
  return getRuleContext<SPECTREParser::Netlist_entityContext>(0);
}


size_t SPECTREParser::Subckt_contentContext::getRuleIndex() const {
  return SPECTREParser::RuleSubckt_content;
}

void SPECTREParser::Subckt_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt_content(this);
}

void SPECTREParser::Subckt_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt_content(this);
}


std::any SPECTREParser::Subckt_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSubckt_content(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Subckt_contentContext* SPECTREParser::subckt_content() {
  Subckt_contentContext *_localctx = _tracker.createInstance<Subckt_contentContext>(_ctx, getState());
  enterRule(_localctx, 38, SPECTREParser::RuleSubckt_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(487);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subckt_footerContext ------------------------------------------------------------------

SPECTREParser::Subckt_footerContext::Subckt_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Subckt_footerContext::SUBCKT_END() {
  return getToken(SPECTREParser::SUBCKT_END, 0);
}

tree::TerminalNode* SPECTREParser::Subckt_footerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

tree::TerminalNode* SPECTREParser::Subckt_footerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Subckt_footerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Subckt_footerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Subckt_footerContext::getRuleIndex() const {
  return SPECTREParser::RuleSubckt_footer;
}

void SPECTREParser::Subckt_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt_footer(this);
}

void SPECTREParser::Subckt_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt_footer(this);
}


std::any SPECTREParser::Subckt_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSubckt_footer(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Subckt_footerContext* SPECTREParser::subckt_footer() {
  Subckt_footerContext *_localctx = _tracker.createInstance<Subckt_footerContext>(_ctx, getState());
  enterRule(_localctx, 40, SPECTREParser::RuleSubckt_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(489);
    match(SPECTREParser::SUBCKT_END);
    setState(491);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      setState(490);
      match(SPECTREParser::ID);
      break;
    }

    default:
      break;
    }
    setState(500);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(496);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(493);
          match(SPECTREParser::NL); 
        }
        setState(498);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
      }
      break;
    }

    case 2: {
      setState(499);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_statementContext ------------------------------------------------------------------

SPECTREParser::If_statementContext::If_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::If_statementContext::IF() {
  return getToken(SPECTREParser::IF, 0);
}

SPECTREParser::ExpressionContext* SPECTREParser::If_statementContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}

SPECTREParser::If_bodyContext* SPECTREParser::If_statementContext::if_body() {
  return getRuleContext<SPECTREParser::If_bodyContext>(0);
}

SPECTREParser::If_alternativeContext* SPECTREParser::If_statementContext::if_alternative() {
  return getRuleContext<SPECTREParser::If_alternativeContext>(0);
}


size_t SPECTREParser::If_statementContext::getRuleIndex() const {
  return SPECTREParser::RuleIf_statement;
}

void SPECTREParser::If_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_statement(this);
}

void SPECTREParser::If_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_statement(this);
}


std::any SPECTREParser::If_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitIf_statement(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::If_statementContext* SPECTREParser::if_statement() {
  If_statementContext *_localctx = _tracker.createInstance<If_statementContext>(_ctx, getState());
  enterRule(_localctx, 42, SPECTREParser::RuleIf_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(502);
    match(SPECTREParser::IF);
    setState(503);
    expression(0);
    setState(504);
    if_body();
    setState(506);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      setState(505);
      if_alternative();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_alternativeContext ------------------------------------------------------------------

SPECTREParser::If_alternativeContext::If_alternativeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::If_alternativeContext::ELSE() {
  return getToken(SPECTREParser::ELSE, 0);
}

SPECTREParser::If_bodyContext* SPECTREParser::If_alternativeContext::if_body() {
  return getRuleContext<SPECTREParser::If_bodyContext>(0);
}


size_t SPECTREParser::If_alternativeContext::getRuleIndex() const {
  return SPECTREParser::RuleIf_alternative;
}

void SPECTREParser::If_alternativeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_alternative(this);
}

void SPECTREParser::If_alternativeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_alternative(this);
}


std::any SPECTREParser::If_alternativeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitIf_alternative(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::If_alternativeContext* SPECTREParser::if_alternative() {
  If_alternativeContext *_localctx = _tracker.createInstance<If_alternativeContext>(_ctx, getState());
  enterRule(_localctx, 44, SPECTREParser::RuleIf_alternative);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(508);
    match(SPECTREParser::ELSE);
    setState(509);
    if_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_bodyContext ------------------------------------------------------------------

SPECTREParser::If_bodyContext::If_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::If_bodyContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

tree::TerminalNode* SPECTREParser::If_bodyContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

std::vector<SPECTREParser::ComponentContext *> SPECTREParser::If_bodyContext::component() {
  return getRuleContexts<SPECTREParser::ComponentContext>();
}

SPECTREParser::ComponentContext* SPECTREParser::If_bodyContext::component(size_t i) {
  return getRuleContext<SPECTREParser::ComponentContext>(i);
}

std::vector<SPECTREParser::AnalysisContext *> SPECTREParser::If_bodyContext::analysis() {
  return getRuleContexts<SPECTREParser::AnalysisContext>();
}

SPECTREParser::AnalysisContext* SPECTREParser::If_bodyContext::analysis(size_t i) {
  return getRuleContext<SPECTREParser::AnalysisContext>(i);
}

std::vector<SPECTREParser::ControlContext *> SPECTREParser::If_bodyContext::control() {
  return getRuleContexts<SPECTREParser::ControlContext>();
}

SPECTREParser::ControlContext* SPECTREParser::If_bodyContext::control(size_t i) {
  return getRuleContext<SPECTREParser::ControlContext>(i);
}

std::vector<SPECTREParser::If_statementContext *> SPECTREParser::If_bodyContext::if_statement() {
  return getRuleContexts<SPECTREParser::If_statementContext>();
}

SPECTREParser::If_statementContext* SPECTREParser::If_bodyContext::if_statement(size_t i) {
  return getRuleContext<SPECTREParser::If_statementContext>(i);
}

std::vector<tree::TerminalNode *> SPECTREParser::If_bodyContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::If_bodyContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}

tree::TerminalNode* SPECTREParser::If_bodyContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}


size_t SPECTREParser::If_bodyContext::getRuleIndex() const {
  return SPECTREParser::RuleIf_body;
}

void SPECTREParser::If_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_body(this);
}

void SPECTREParser::If_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_body(this);
}


std::any SPECTREParser::If_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitIf_body(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::If_bodyContext* SPECTREParser::if_body() {
  If_bodyContext *_localctx = _tracker.createInstance<If_bodyContext>(_ctx, getState());
  enterRule(_localctx, 46, SPECTREParser::RuleIf_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(524);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(514);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SPECTREParser::NL) {
        setState(511);
        match(SPECTREParser::NL);
        setState(516);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(517);
      match(SPECTREParser::OPEN_CURLY);
      setState(521);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(518);
          match(SPECTREParser::NL); 
        }
        setState(523);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx);
      }
      break;
    }

    default:
      break;
    }
    setState(531); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(531);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
              case 1: {
                setState(526);
                component();
                break;
              }

              case 2: {
                setState(527);
                analysis();
                break;
              }

              case 3: {
                setState(528);
                control();
                break;
              }

              case 4: {
                setState(529);
                if_statement();
                break;
              }

              case 5: {
                setState(530);
                match(SPECTREParser::NL);
                break;
              }

              default:
                break;
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(533); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(542);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      setState(538);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SPECTREParser::NL) {
        setState(535);
        match(SPECTREParser::NL);
        setState(540);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(541);
      match(SPECTREParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
    setState(551);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      setState(547);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(544);
          match(SPECTREParser::NL); 
        }
        setState(549);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
      }
      break;
    }

    case 2: {
      setState(550);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnalysisContext ------------------------------------------------------------------

SPECTREParser::AnalysisContext::AnalysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::AcContext* SPECTREParser::AnalysisContext::ac() {
  return getRuleContext<SPECTREParser::AcContext>(0);
}

SPECTREParser::AcmatchContext* SPECTREParser::AnalysisContext::acmatch() {
  return getRuleContext<SPECTREParser::AcmatchContext>(0);
}

SPECTREParser::DcContext* SPECTREParser::AnalysisContext::dc() {
  return getRuleContext<SPECTREParser::DcContext>(0);
}

SPECTREParser::DcmatchContext* SPECTREParser::AnalysisContext::dcmatch() {
  return getRuleContext<SPECTREParser::DcmatchContext>(0);
}

SPECTREParser::EnvlpContext* SPECTREParser::AnalysisContext::envlp() {
  return getRuleContext<SPECTREParser::EnvlpContext>(0);
}

SPECTREParser::SpContext* SPECTREParser::AnalysisContext::sp() {
  return getRuleContext<SPECTREParser::SpContext>(0);
}

SPECTREParser::StbContext* SPECTREParser::AnalysisContext::stb() {
  return getRuleContext<SPECTREParser::StbContext>(0);
}

SPECTREParser::SweepContext* SPECTREParser::AnalysisContext::sweep() {
  return getRuleContext<SPECTREParser::SweepContext>(0);
}

SPECTREParser::TdrContext* SPECTREParser::AnalysisContext::tdr() {
  return getRuleContext<SPECTREParser::TdrContext>(0);
}

SPECTREParser::TranContext* SPECTREParser::AnalysisContext::tran() {
  return getRuleContext<SPECTREParser::TranContext>(0);
}

SPECTREParser::XfContext* SPECTREParser::AnalysisContext::xf() {
  return getRuleContext<SPECTREParser::XfContext>(0);
}

SPECTREParser::PacContext* SPECTREParser::AnalysisContext::pac() {
  return getRuleContext<SPECTREParser::PacContext>(0);
}

SPECTREParser::PdistoContext* SPECTREParser::AnalysisContext::pdisto() {
  return getRuleContext<SPECTREParser::PdistoContext>(0);
}

SPECTREParser::PnoiseContext* SPECTREParser::AnalysisContext::pnoise() {
  return getRuleContext<SPECTREParser::PnoiseContext>(0);
}

SPECTREParser::PspContext* SPECTREParser::AnalysisContext::psp() {
  return getRuleContext<SPECTREParser::PspContext>(0);
}

SPECTREParser::PssContext* SPECTREParser::AnalysisContext::pss() {
  return getRuleContext<SPECTREParser::PssContext>(0);
}

SPECTREParser::PxfContext* SPECTREParser::AnalysisContext::pxf() {
  return getRuleContext<SPECTREParser::PxfContext>(0);
}

SPECTREParser::PzContext* SPECTREParser::AnalysisContext::pz() {
  return getRuleContext<SPECTREParser::PzContext>(0);
}

SPECTREParser::QpacContext* SPECTREParser::AnalysisContext::qpac() {
  return getRuleContext<SPECTREParser::QpacContext>(0);
}

SPECTREParser::QpnoiseContext* SPECTREParser::AnalysisContext::qpnoise() {
  return getRuleContext<SPECTREParser::QpnoiseContext>(0);
}

SPECTREParser::QpspContext* SPECTREParser::AnalysisContext::qpsp() {
  return getRuleContext<SPECTREParser::QpspContext>(0);
}

SPECTREParser::QpssContext* SPECTREParser::AnalysisContext::qpss() {
  return getRuleContext<SPECTREParser::QpssContext>(0);
}

SPECTREParser::QpxfContext* SPECTREParser::AnalysisContext::qpxf() {
  return getRuleContext<SPECTREParser::QpxfContext>(0);
}

SPECTREParser::SensContext* SPECTREParser::AnalysisContext::sens() {
  return getRuleContext<SPECTREParser::SensContext>(0);
}

SPECTREParser::MontecarloContext* SPECTREParser::AnalysisContext::montecarlo() {
  return getRuleContext<SPECTREParser::MontecarloContext>(0);
}

SPECTREParser::NoiseContext* SPECTREParser::AnalysisContext::noise() {
  return getRuleContext<SPECTREParser::NoiseContext>(0);
}

SPECTREParser::ChecklimitContext* SPECTREParser::AnalysisContext::checklimit() {
  return getRuleContext<SPECTREParser::ChecklimitContext>(0);
}

SPECTREParser::ReliabilityContext* SPECTREParser::AnalysisContext::reliability() {
  return getRuleContext<SPECTREParser::ReliabilityContext>(0);
}


size_t SPECTREParser::AnalysisContext::getRuleIndex() const {
  return SPECTREParser::RuleAnalysis;
}

void SPECTREParser::AnalysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalysis(this);
}

void SPECTREParser::AnalysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalysis(this);
}


std::any SPECTREParser::AnalysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAnalysis(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::AnalysisContext* SPECTREParser::analysis() {
  AnalysisContext *_localctx = _tracker.createInstance<AnalysisContext>(_ctx, getState());
  enterRule(_localctx, 48, SPECTREParser::RuleAnalysis);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(581);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(553);
      ac();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(554);
      acmatch();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(555);
      dc();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(556);
      dcmatch();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(557);
      envlp();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(558);
      sp();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(559);
      stb();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(560);
      sweep();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(561);
      tdr();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(562);
      tran();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(563);
      xf();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(564);
      pac();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(565);
      pdisto();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(566);
      pnoise();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(567);
      psp();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(568);
      pss();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(569);
      pxf();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(570);
      pz();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(571);
      qpac();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(572);
      qpnoise();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(573);
      qpsp();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(574);
      qpss();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(575);
      qpxf();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(576);
      sens();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(577);
      montecarlo();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(578);
      noise();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(579);
      checklimit();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(580);
      reliability();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AcContext ------------------------------------------------------------------

SPECTREParser::AcContext::AcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::AcContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::AcContext::AC() {
  return getToken(SPECTREParser::AC, 0);
}

tree::TerminalNode* SPECTREParser::AcContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::AcContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::AcContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::AcContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::AcContext::getRuleIndex() const {
  return SPECTREParser::RuleAc;
}

void SPECTREParser::AcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAc(this);
}

void SPECTREParser::AcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAc(this);
}


std::any SPECTREParser::AcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAc(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::AcContext* SPECTREParser::ac() {
  AcContext *_localctx = _tracker.createInstance<AcContext>(_ctx, getState());
  enterRule(_localctx, 50, SPECTREParser::RuleAc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(583);
    match(SPECTREParser::ID);
    setState(584);
    match(SPECTREParser::AC);
    setState(586);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      setState(585);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(595);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      setState(591);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(588);
          match(SPECTREParser::NL); 
        }
        setState(593);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
      }
      break;
    }

    case 2: {
      setState(594);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AcmatchContext ------------------------------------------------------------------

SPECTREParser::AcmatchContext::AcmatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::AcmatchContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::AcmatchContext::ACMATCH() {
  return getToken(SPECTREParser::ACMATCH, 0);
}

tree::TerminalNode* SPECTREParser::AcmatchContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::AcmatchContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::AcmatchContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::AcmatchContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::AcmatchContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::AcmatchContext::getRuleIndex() const {
  return SPECTREParser::RuleAcmatch;
}

void SPECTREParser::AcmatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAcmatch(this);
}

void SPECTREParser::AcmatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAcmatch(this);
}


std::any SPECTREParser::AcmatchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAcmatch(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::AcmatchContext* SPECTREParser::acmatch() {
  AcmatchContext *_localctx = _tracker.createInstance<AcmatchContext>(_ctx, getState());
  enterRule(_localctx, 52, SPECTREParser::RuleAcmatch);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(597);
    match(SPECTREParser::ID);
    setState(598);
    match(SPECTREParser::ACMATCH);
    setState(600);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      setState(599);
      node_list();
      break;
    }

    default:
      break;
    }
    setState(603);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      setState(602);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(612);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(608);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(605);
          match(SPECTREParser::NL); 
        }
        setState(610);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
      }
      break;
    }

    case 2: {
      setState(611);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DcContext ------------------------------------------------------------------

SPECTREParser::DcContext::DcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::DcContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::DcContext::DC() {
  return getToken(SPECTREParser::DC, 0);
}

tree::TerminalNode* SPECTREParser::DcContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::DcContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::DcContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::DcContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::DcContext::getRuleIndex() const {
  return SPECTREParser::RuleDc;
}

void SPECTREParser::DcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDc(this);
}

void SPECTREParser::DcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDc(this);
}


std::any SPECTREParser::DcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitDc(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::DcContext* SPECTREParser::dc() {
  DcContext *_localctx = _tracker.createInstance<DcContext>(_ctx, getState());
  enterRule(_localctx, 54, SPECTREParser::RuleDc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(614);
    match(SPECTREParser::ID);
    setState(615);
    match(SPECTREParser::DC);
    setState(617);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(616);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(626);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      setState(622);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(619);
          match(SPECTREParser::NL); 
        }
        setState(624);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx);
      }
      break;
    }

    case 2: {
      setState(625);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DcmatchContext ------------------------------------------------------------------

SPECTREParser::DcmatchContext::DcmatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::DcmatchContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::DcmatchContext::DCMATCH() {
  return getToken(SPECTREParser::DCMATCH, 0);
}

tree::TerminalNode* SPECTREParser::DcmatchContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::DcmatchContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::DcmatchContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::DcmatchContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::DcmatchContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::DcmatchContext::getRuleIndex() const {
  return SPECTREParser::RuleDcmatch;
}

void SPECTREParser::DcmatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcmatch(this);
}

void SPECTREParser::DcmatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcmatch(this);
}


std::any SPECTREParser::DcmatchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitDcmatch(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::DcmatchContext* SPECTREParser::dcmatch() {
  DcmatchContext *_localctx = _tracker.createInstance<DcmatchContext>(_ctx, getState());
  enterRule(_localctx, 56, SPECTREParser::RuleDcmatch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(628);
    match(SPECTREParser::ID);
    setState(630);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(629);
      node_list();
    }
    setState(632);
    match(SPECTREParser::DCMATCH);
    setState(634);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
    case 1: {
      setState(633);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(643);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(639);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(636);
          match(SPECTREParser::NL); 
        }
        setState(641);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx);
      }
      break;
    }

    case 2: {
      setState(642);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnvlpContext ------------------------------------------------------------------

SPECTREParser::EnvlpContext::EnvlpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::EnvlpContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::EnvlpContext::ENVLP() {
  return getToken(SPECTREParser::ENVLP, 0);
}

tree::TerminalNode* SPECTREParser::EnvlpContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::EnvlpContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::EnvlpContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::EnvlpContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::EnvlpContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::EnvlpContext::getRuleIndex() const {
  return SPECTREParser::RuleEnvlp;
}

void SPECTREParser::EnvlpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnvlp(this);
}

void SPECTREParser::EnvlpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnvlp(this);
}


std::any SPECTREParser::EnvlpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitEnvlp(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::EnvlpContext* SPECTREParser::envlp() {
  EnvlpContext *_localctx = _tracker.createInstance<EnvlpContext>(_ctx, getState());
  enterRule(_localctx, 58, SPECTREParser::RuleEnvlp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(645);
    match(SPECTREParser::ID);
    setState(647);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(646);
      node_list();
    }
    setState(649);
    match(SPECTREParser::ENVLP);
    setState(651);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(650);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(660);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(656);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(653);
          match(SPECTREParser::NL); 
        }
        setState(658);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
      }
      break;
    }

    case 2: {
      setState(659);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpContext ------------------------------------------------------------------

SPECTREParser::SpContext::SpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::SpContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::SpContext::SP() {
  return getToken(SPECTREParser::SP, 0);
}

tree::TerminalNode* SPECTREParser::SpContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::SpContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::SpContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::SpContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::SpContext::getRuleIndex() const {
  return SPECTREParser::RuleSp;
}

void SPECTREParser::SpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSp(this);
}

void SPECTREParser::SpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSp(this);
}


std::any SPECTREParser::SpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSp(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::SpContext* SPECTREParser::sp() {
  SpContext *_localctx = _tracker.createInstance<SpContext>(_ctx, getState());
  enterRule(_localctx, 60, SPECTREParser::RuleSp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(662);
    match(SPECTREParser::ID);
    setState(663);
    match(SPECTREParser::SP);
    setState(665);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      setState(664);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(674);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      setState(670);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(667);
          match(SPECTREParser::NL); 
        }
        setState(672);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
      }
      break;
    }

    case 2: {
      setState(673);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StbContext ------------------------------------------------------------------

SPECTREParser::StbContext::StbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::StbContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::StbContext::STB() {
  return getToken(SPECTREParser::STB, 0);
}

tree::TerminalNode* SPECTREParser::StbContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::StbContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::StbContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::StbContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::StbContext::getRuleIndex() const {
  return SPECTREParser::RuleStb;
}

void SPECTREParser::StbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStb(this);
}

void SPECTREParser::StbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStb(this);
}


std::any SPECTREParser::StbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitStb(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::StbContext* SPECTREParser::stb() {
  StbContext *_localctx = _tracker.createInstance<StbContext>(_ctx, getState());
  enterRule(_localctx, 62, SPECTREParser::RuleStb);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(676);
    match(SPECTREParser::ID);
    setState(677);
    match(SPECTREParser::STB);
    setState(679);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(678);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(688);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(684);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(681);
          match(SPECTREParser::NL); 
        }
        setState(686);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
      }
      break;
    }

    case 2: {
      setState(687);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SweepContext ------------------------------------------------------------------

SPECTREParser::SweepContext::SweepContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Sweep_headerContext* SPECTREParser::SweepContext::sweep_header() {
  return getRuleContext<SPECTREParser::Sweep_headerContext>(0);
}

SPECTREParser::Sweep_footerContext* SPECTREParser::SweepContext::sweep_footer() {
  return getRuleContext<SPECTREParser::Sweep_footerContext>(0);
}

std::vector<SPECTREParser::Sweep_contentContext *> SPECTREParser::SweepContext::sweep_content() {
  return getRuleContexts<SPECTREParser::Sweep_contentContext>();
}

SPECTREParser::Sweep_contentContext* SPECTREParser::SweepContext::sweep_content(size_t i) {
  return getRuleContext<SPECTREParser::Sweep_contentContext>(i);
}


size_t SPECTREParser::SweepContext::getRuleIndex() const {
  return SPECTREParser::RuleSweep;
}

void SPECTREParser::SweepContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSweep(this);
}

void SPECTREParser::SweepContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSweep(this);
}


std::any SPECTREParser::SweepContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSweep(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::SweepContext* SPECTREParser::sweep() {
  SweepContext *_localctx = _tracker.createInstance<SweepContext>(_ctx, getState());
  enterRule(_localctx, 64, SPECTREParser::RuleSweep);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(690);
    sweep_header();
    setState(692); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(691);
      sweep_content();
      setState(694); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 17592236567932) != 0) || _la == SPECTREParser::SENS || _la == SPECTREParser::ID);
    setState(696);
    sweep_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sweep_headerContext ------------------------------------------------------------------

SPECTREParser::Sweep_headerContext::Sweep_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Sweep_headerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Sweep_headerContext::SWEEP() {
  return getToken(SPECTREParser::SWEEP, 0);
}

tree::TerminalNode* SPECTREParser::Sweep_headerContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Sweep_headerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Sweep_headerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Sweep_headerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}

std::vector<SPECTREParser::Parameter_listContext *> SPECTREParser::Sweep_headerContext::parameter_list() {
  return getRuleContexts<SPECTREParser::Parameter_listContext>();
}

SPECTREParser::Parameter_listContext* SPECTREParser::Sweep_headerContext::parameter_list(size_t i) {
  return getRuleContext<SPECTREParser::Parameter_listContext>(i);
}


size_t SPECTREParser::Sweep_headerContext::getRuleIndex() const {
  return SPECTREParser::RuleSweep_header;
}

void SPECTREParser::Sweep_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSweep_header(this);
}

void SPECTREParser::Sweep_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSweep_header(this);
}


std::any SPECTREParser::Sweep_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSweep_header(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Sweep_headerContext* SPECTREParser::sweep_header() {
  Sweep_headerContext *_localctx = _tracker.createInstance<Sweep_headerContext>(_ctx, getState());
  enterRule(_localctx, 66, SPECTREParser::RuleSweep_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(698);
    match(SPECTREParser::ID);
    setState(699);
    match(SPECTREParser::SWEEP);
    setState(703);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(700);
      match(SPECTREParser::NL);
      setState(705);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(709);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9007749010555136) != 0) || _la == SPECTREParser::OPEN_ROUND

    || _la == SPECTREParser::ID) {
      setState(706);
      parameter_list();
      setState(711);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(712);
    match(SPECTREParser::OPEN_CURLY);
    setState(720);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::GLOBAL:
      case SPECTREParser::INCLUDE:
      case SPECTREParser::CPP_INCLUDE:
      case SPECTREParser::AHDL_INCLUDE:
      case SPECTREParser::LIBRARY:
      case SPECTREParser::SECTION:
      case SPECTREParser::SUBCKT:
      case SPECTREParser::INLINE_SUBCKT:
      case SPECTREParser::SIMULATOR:
      case SPECTREParser::GLOBAL_PARAMETERS:
      case SPECTREParser::MODEL:
      case SPECTREParser::SAVE:
      case SPECTREParser::NODESET:
      case SPECTREParser::IC:
      case SPECTREParser::STATISTICS:
      case SPECTREParser::SENS:
      case SPECTREParser::ID:
      case SPECTREParser::NL: {
        setState(716);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(713);
          match(SPECTREParser::NL);
          setState(718);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(719);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sweep_contentContext ------------------------------------------------------------------

SPECTREParser::Sweep_contentContext::Sweep_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Netlist_entityContext* SPECTREParser::Sweep_contentContext::netlist_entity() {
  return getRuleContext<SPECTREParser::Netlist_entityContext>(0);
}


size_t SPECTREParser::Sweep_contentContext::getRuleIndex() const {
  return SPECTREParser::RuleSweep_content;
}

void SPECTREParser::Sweep_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSweep_content(this);
}

void SPECTREParser::Sweep_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSweep_content(this);
}


std::any SPECTREParser::Sweep_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSweep_content(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Sweep_contentContext* SPECTREParser::sweep_content() {
  Sweep_contentContext *_localctx = _tracker.createInstance<Sweep_contentContext>(_ctx, getState());
  enterRule(_localctx, 68, SPECTREParser::RuleSweep_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(722);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sweep_footerContext ------------------------------------------------------------------

SPECTREParser::Sweep_footerContext::Sweep_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Sweep_footerContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Sweep_footerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Sweep_footerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Sweep_footerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Sweep_footerContext::getRuleIndex() const {
  return SPECTREParser::RuleSweep_footer;
}

void SPECTREParser::Sweep_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSweep_footer(this);
}

void SPECTREParser::Sweep_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSweep_footer(this);
}


std::any SPECTREParser::Sweep_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSweep_footer(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Sweep_footerContext* SPECTREParser::sweep_footer() {
  Sweep_footerContext *_localctx = _tracker.createInstance<Sweep_footerContext>(_ctx, getState());
  enterRule(_localctx, 70, SPECTREParser::RuleSweep_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(724);
    match(SPECTREParser::CLOSE_CURLY);
    setState(732);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(728);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(725);
          match(SPECTREParser::NL); 
        }
        setState(730);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx);
      }
      break;
    }

    case 2: {
      setState(731);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TdrContext ------------------------------------------------------------------

SPECTREParser::TdrContext::TdrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::TdrContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::TdrContext::TDR() {
  return getToken(SPECTREParser::TDR, 0);
}

tree::TerminalNode* SPECTREParser::TdrContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::TdrContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::TdrContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::TdrContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::TdrContext::getRuleIndex() const {
  return SPECTREParser::RuleTdr;
}

void SPECTREParser::TdrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTdr(this);
}

void SPECTREParser::TdrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTdr(this);
}


std::any SPECTREParser::TdrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitTdr(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::TdrContext* SPECTREParser::tdr() {
  TdrContext *_localctx = _tracker.createInstance<TdrContext>(_ctx, getState());
  enterRule(_localctx, 72, SPECTREParser::RuleTdr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(734);
    match(SPECTREParser::ID);
    setState(735);
    match(SPECTREParser::TDR);
    setState(737);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(736);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(746);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
    case 1: {
      setState(742);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(739);
          match(SPECTREParser::NL); 
        }
        setState(744);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
      }
      break;
    }

    case 2: {
      setState(745);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TranContext ------------------------------------------------------------------

SPECTREParser::TranContext::TranContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::TranContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::TranContext::TRAN() {
  return getToken(SPECTREParser::TRAN, 0);
}

tree::TerminalNode* SPECTREParser::TranContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::TranContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::TranContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::TranContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::TranContext::getRuleIndex() const {
  return SPECTREParser::RuleTran;
}

void SPECTREParser::TranContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTran(this);
}

void SPECTREParser::TranContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTran(this);
}


std::any SPECTREParser::TranContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitTran(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::TranContext* SPECTREParser::tran() {
  TranContext *_localctx = _tracker.createInstance<TranContext>(_ctx, getState());
  enterRule(_localctx, 74, SPECTREParser::RuleTran);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(748);
    match(SPECTREParser::ID);
    setState(749);
    match(SPECTREParser::TRAN);
    setState(751);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(750);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(760);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {
    case 1: {
      setState(756);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(753);
          match(SPECTREParser::NL); 
        }
        setState(758);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
      }
      break;
    }

    case 2: {
      setState(759);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XfContext ------------------------------------------------------------------

SPECTREParser::XfContext::XfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::XfContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::XfContext::XF() {
  return getToken(SPECTREParser::XF, 0);
}

tree::TerminalNode* SPECTREParser::XfContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::XfContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::XfContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::XfContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::XfContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::XfContext::getRuleIndex() const {
  return SPECTREParser::RuleXf;
}

void SPECTREParser::XfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXf(this);
}

void SPECTREParser::XfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXf(this);
}


std::any SPECTREParser::XfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitXf(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::XfContext* SPECTREParser::xf() {
  XfContext *_localctx = _tracker.createInstance<XfContext>(_ctx, getState());
  enterRule(_localctx, 76, SPECTREParser::RuleXf);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(762);
    match(SPECTREParser::ID);
    setState(764);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(763);
      node_list();
    }
    setState(766);
    match(SPECTREParser::XF);
    setState(768);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      setState(767);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(777);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      setState(773);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(770);
          match(SPECTREParser::NL); 
        }
        setState(775);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
      }
      break;
    }

    case 2: {
      setState(776);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PacContext ------------------------------------------------------------------

SPECTREParser::PacContext::PacContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::PacContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::PacContext::PAC() {
  return getToken(SPECTREParser::PAC, 0);
}

tree::TerminalNode* SPECTREParser::PacContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::PacContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::PacContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::PacContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::PacContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::PacContext::getRuleIndex() const {
  return SPECTREParser::RulePac;
}

void SPECTREParser::PacContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPac(this);
}

void SPECTREParser::PacContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPac(this);
}


std::any SPECTREParser::PacContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitPac(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::PacContext* SPECTREParser::pac() {
  PacContext *_localctx = _tracker.createInstance<PacContext>(_ctx, getState());
  enterRule(_localctx, 78, SPECTREParser::RulePac);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(779);
    match(SPECTREParser::ID);
    setState(781);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(780);
      node_list();
    }
    setState(783);
    match(SPECTREParser::PAC);
    setState(785);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      setState(784);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(794);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      setState(790);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(787);
          match(SPECTREParser::NL); 
        }
        setState(792);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
      }
      break;
    }

    case 2: {
      setState(793);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PdistoContext ------------------------------------------------------------------

SPECTREParser::PdistoContext::PdistoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::PdistoContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::PdistoContext::PDISTO() {
  return getToken(SPECTREParser::PDISTO, 0);
}

tree::TerminalNode* SPECTREParser::PdistoContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::PdistoContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::PdistoContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::PdistoContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::PdistoContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::PdistoContext::getRuleIndex() const {
  return SPECTREParser::RulePdisto;
}

void SPECTREParser::PdistoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPdisto(this);
}

void SPECTREParser::PdistoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPdisto(this);
}


std::any SPECTREParser::PdistoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitPdisto(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::PdistoContext* SPECTREParser::pdisto() {
  PdistoContext *_localctx = _tracker.createInstance<PdistoContext>(_ctx, getState());
  enterRule(_localctx, 80, SPECTREParser::RulePdisto);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(796);
    match(SPECTREParser::ID);
    setState(798);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(797);
      node_list();
    }
    setState(800);
    match(SPECTREParser::PDISTO);
    setState(802);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      setState(801);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(811);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(807);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(804);
          match(SPECTREParser::NL); 
        }
        setState(809);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
      }
      break;
    }

    case 2: {
      setState(810);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PnoiseContext ------------------------------------------------------------------

SPECTREParser::PnoiseContext::PnoiseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::PnoiseContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::PnoiseContext::PNOISE() {
  return getToken(SPECTREParser::PNOISE, 0);
}

tree::TerminalNode* SPECTREParser::PnoiseContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::PnoiseContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::PnoiseContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::PnoiseContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::PnoiseContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::PnoiseContext::getRuleIndex() const {
  return SPECTREParser::RulePnoise;
}

void SPECTREParser::PnoiseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPnoise(this);
}

void SPECTREParser::PnoiseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPnoise(this);
}


std::any SPECTREParser::PnoiseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitPnoise(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::PnoiseContext* SPECTREParser::pnoise() {
  PnoiseContext *_localctx = _tracker.createInstance<PnoiseContext>(_ctx, getState());
  enterRule(_localctx, 82, SPECTREParser::RulePnoise);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(813);
    match(SPECTREParser::ID);
    setState(815);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(814);
      node_list();
    }
    setState(817);
    match(SPECTREParser::PNOISE);
    setState(819);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      setState(818);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(828);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      setState(824);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(821);
          match(SPECTREParser::NL); 
        }
        setState(826);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
      }
      break;
    }

    case 2: {
      setState(827);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PspContext ------------------------------------------------------------------

SPECTREParser::PspContext::PspContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::PspContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::PspContext::PSP() {
  return getToken(SPECTREParser::PSP, 0);
}

tree::TerminalNode* SPECTREParser::PspContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::PspContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::PspContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::PspContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::PspContext::getRuleIndex() const {
  return SPECTREParser::RulePsp;
}

void SPECTREParser::PspContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPsp(this);
}

void SPECTREParser::PspContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPsp(this);
}


std::any SPECTREParser::PspContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitPsp(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::PspContext* SPECTREParser::psp() {
  PspContext *_localctx = _tracker.createInstance<PspContext>(_ctx, getState());
  enterRule(_localctx, 84, SPECTREParser::RulePsp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(830);
    match(SPECTREParser::ID);
    setState(831);
    match(SPECTREParser::PSP);
    setState(833);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      setState(832);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(842);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      setState(838);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(835);
          match(SPECTREParser::NL); 
        }
        setState(840);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx);
      }
      break;
    }

    case 2: {
      setState(841);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PssContext ------------------------------------------------------------------

SPECTREParser::PssContext::PssContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::PssContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::PssContext::PSS() {
  return getToken(SPECTREParser::PSS, 0);
}

tree::TerminalNode* SPECTREParser::PssContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::PssContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::PssContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::PssContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::PssContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::PssContext::getRuleIndex() const {
  return SPECTREParser::RulePss;
}

void SPECTREParser::PssContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPss(this);
}

void SPECTREParser::PssContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPss(this);
}


std::any SPECTREParser::PssContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitPss(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::PssContext* SPECTREParser::pss() {
  PssContext *_localctx = _tracker.createInstance<PssContext>(_ctx, getState());
  enterRule(_localctx, 86, SPECTREParser::RulePss);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(844);
    match(SPECTREParser::ID);
    setState(846);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(845);
      node_list();
    }
    setState(848);
    match(SPECTREParser::PSS);
    setState(850);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      setState(849);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(859);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      setState(855);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(852);
          match(SPECTREParser::NL); 
        }
        setState(857);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx);
      }
      break;
    }

    case 2: {
      setState(858);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PxfContext ------------------------------------------------------------------

SPECTREParser::PxfContext::PxfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::PxfContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::PxfContext::PXF() {
  return getToken(SPECTREParser::PXF, 0);
}

tree::TerminalNode* SPECTREParser::PxfContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::PxfContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::PxfContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::PxfContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::PxfContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::PxfContext::getRuleIndex() const {
  return SPECTREParser::RulePxf;
}

void SPECTREParser::PxfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPxf(this);
}

void SPECTREParser::PxfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPxf(this);
}


std::any SPECTREParser::PxfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitPxf(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::PxfContext* SPECTREParser::pxf() {
  PxfContext *_localctx = _tracker.createInstance<PxfContext>(_ctx, getState());
  enterRule(_localctx, 88, SPECTREParser::RulePxf);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(861);
    match(SPECTREParser::ID);
    setState(863);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(862);
      node_list();
    }
    setState(865);
    match(SPECTREParser::PXF);
    setState(867);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
    case 1: {
      setState(866);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(876);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      setState(872);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(869);
          match(SPECTREParser::NL); 
        }
        setState(874);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx);
      }
      break;
    }

    case 2: {
      setState(875);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PzContext ------------------------------------------------------------------

SPECTREParser::PzContext::PzContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::PzContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::PzContext::PZ() {
  return getToken(SPECTREParser::PZ, 0);
}

tree::TerminalNode* SPECTREParser::PzContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::PzContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::PzContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::PzContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::PzContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::PzContext::getRuleIndex() const {
  return SPECTREParser::RulePz;
}

void SPECTREParser::PzContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPz(this);
}

void SPECTREParser::PzContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPz(this);
}


std::any SPECTREParser::PzContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitPz(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::PzContext* SPECTREParser::pz() {
  PzContext *_localctx = _tracker.createInstance<PzContext>(_ctx, getState());
  enterRule(_localctx, 90, SPECTREParser::RulePz);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(878);
    match(SPECTREParser::ID);
    setState(880);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(879);
      node_list();
    }
    setState(882);
    match(SPECTREParser::PZ);
    setState(884);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      setState(883);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(893);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
    case 1: {
      setState(889);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(886);
          match(SPECTREParser::NL); 
        }
        setState(891);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
      }
      break;
    }

    case 2: {
      setState(892);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QpacContext ------------------------------------------------------------------

SPECTREParser::QpacContext::QpacContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::QpacContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::QpacContext::QPAC() {
  return getToken(SPECTREParser::QPAC, 0);
}

tree::TerminalNode* SPECTREParser::QpacContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::QpacContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::QpacContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::QpacContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::QpacContext::getRuleIndex() const {
  return SPECTREParser::RuleQpac;
}

void SPECTREParser::QpacContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQpac(this);
}

void SPECTREParser::QpacContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQpac(this);
}


std::any SPECTREParser::QpacContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitQpac(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::QpacContext* SPECTREParser::qpac() {
  QpacContext *_localctx = _tracker.createInstance<QpacContext>(_ctx, getState());
  enterRule(_localctx, 92, SPECTREParser::RuleQpac);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(895);
    match(SPECTREParser::ID);
    setState(896);
    match(SPECTREParser::QPAC);
    setState(898);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      setState(897);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(907);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      setState(903);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(900);
          match(SPECTREParser::NL); 
        }
        setState(905);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx);
      }
      break;
    }

    case 2: {
      setState(906);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QpnoiseContext ------------------------------------------------------------------

SPECTREParser::QpnoiseContext::QpnoiseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::QpnoiseContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::QpnoiseContext::QPNOISE() {
  return getToken(SPECTREParser::QPNOISE, 0);
}

tree::TerminalNode* SPECTREParser::QpnoiseContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::QpnoiseContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::QpnoiseContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::QpnoiseContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::QpnoiseContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::QpnoiseContext::getRuleIndex() const {
  return SPECTREParser::RuleQpnoise;
}

void SPECTREParser::QpnoiseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQpnoise(this);
}

void SPECTREParser::QpnoiseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQpnoise(this);
}


std::any SPECTREParser::QpnoiseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitQpnoise(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::QpnoiseContext* SPECTREParser::qpnoise() {
  QpnoiseContext *_localctx = _tracker.createInstance<QpnoiseContext>(_ctx, getState());
  enterRule(_localctx, 94, SPECTREParser::RuleQpnoise);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(909);
    match(SPECTREParser::ID);
    setState(911);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(910);
      node_list();
    }
    setState(913);
    match(SPECTREParser::QPNOISE);
    setState(915);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      setState(914);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(924);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
    case 1: {
      setState(920);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(917);
          match(SPECTREParser::NL); 
        }
        setState(922);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
      }
      break;
    }

    case 2: {
      setState(923);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QpspContext ------------------------------------------------------------------

SPECTREParser::QpspContext::QpspContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::QpspContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::QpspContext::QPSP() {
  return getToken(SPECTREParser::QPSP, 0);
}

tree::TerminalNode* SPECTREParser::QpspContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::QpspContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::QpspContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::QpspContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::QpspContext::getRuleIndex() const {
  return SPECTREParser::RuleQpsp;
}

void SPECTREParser::QpspContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQpsp(this);
}

void SPECTREParser::QpspContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQpsp(this);
}


std::any SPECTREParser::QpspContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitQpsp(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::QpspContext* SPECTREParser::qpsp() {
  QpspContext *_localctx = _tracker.createInstance<QpspContext>(_ctx, getState());
  enterRule(_localctx, 96, SPECTREParser::RuleQpsp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(926);
    match(SPECTREParser::ID);
    setState(927);
    match(SPECTREParser::QPSP);
    setState(929);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
    case 1: {
      setState(928);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(938);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
    case 1: {
      setState(934);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(931);
          match(SPECTREParser::NL); 
        }
        setState(936);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
      }
      break;
    }

    case 2: {
      setState(937);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QpssContext ------------------------------------------------------------------

SPECTREParser::QpssContext::QpssContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::QpssContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::QpssContext::QPSS() {
  return getToken(SPECTREParser::QPSS, 0);
}

tree::TerminalNode* SPECTREParser::QpssContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::QpssContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::QpssContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::QpssContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::QpssContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::QpssContext::getRuleIndex() const {
  return SPECTREParser::RuleQpss;
}

void SPECTREParser::QpssContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQpss(this);
}

void SPECTREParser::QpssContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQpss(this);
}


std::any SPECTREParser::QpssContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitQpss(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::QpssContext* SPECTREParser::qpss() {
  QpssContext *_localctx = _tracker.createInstance<QpssContext>(_ctx, getState());
  enterRule(_localctx, 98, SPECTREParser::RuleQpss);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(940);
    match(SPECTREParser::ID);
    setState(942);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(941);
      node_list();
    }
    setState(944);
    match(SPECTREParser::QPSS);
    setState(946);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx)) {
    case 1: {
      setState(945);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(955);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
    case 1: {
      setState(951);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(948);
          match(SPECTREParser::NL); 
        }
        setState(953);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx);
      }
      break;
    }

    case 2: {
      setState(954);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QpxfContext ------------------------------------------------------------------

SPECTREParser::QpxfContext::QpxfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::QpxfContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::QpxfContext::QPXF() {
  return getToken(SPECTREParser::QPXF, 0);
}

tree::TerminalNode* SPECTREParser::QpxfContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::QpxfContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::QpxfContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::QpxfContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::QpxfContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::QpxfContext::getRuleIndex() const {
  return SPECTREParser::RuleQpxf;
}

void SPECTREParser::QpxfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQpxf(this);
}

void SPECTREParser::QpxfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQpxf(this);
}


std::any SPECTREParser::QpxfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitQpxf(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::QpxfContext* SPECTREParser::qpxf() {
  QpxfContext *_localctx = _tracker.createInstance<QpxfContext>(_ctx, getState());
  enterRule(_localctx, 100, SPECTREParser::RuleQpxf);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(957);
    match(SPECTREParser::ID);
    setState(959);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(958);
      node_list();
    }
    setState(961);
    match(SPECTREParser::QPXF);
    setState(963);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
    case 1: {
      setState(962);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(972);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      setState(968);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(965);
          match(SPECTREParser::NL); 
        }
        setState(970);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx);
      }
      break;
    }

    case 2: {
      setState(971);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SensContext ------------------------------------------------------------------

SPECTREParser::SensContext::SensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::SensContext::SENS() {
  return getToken(SPECTREParser::SENS, 0);
}

tree::TerminalNode* SPECTREParser::SensContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Sens_output_variables_listContext* SPECTREParser::SensContext::sens_output_variables_list() {
  return getRuleContext<SPECTREParser::Sens_output_variables_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::SensContext::ID() {
  return getTokens(SPECTREParser::ID);
}

tree::TerminalNode* SPECTREParser::SensContext::ID(size_t i) {
  return getToken(SPECTREParser::ID, i);
}

std::vector<SPECTREParser::Sens_design_parameters_listContext *> SPECTREParser::SensContext::sens_design_parameters_list() {
  return getRuleContexts<SPECTREParser::Sens_design_parameters_listContext>();
}

SPECTREParser::Sens_design_parameters_listContext* SPECTREParser::SensContext::sens_design_parameters_list(size_t i) {
  return getRuleContext<SPECTREParser::Sens_design_parameters_listContext>(i);
}

std::vector<tree::TerminalNode *> SPECTREParser::SensContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::SensContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::SensContext::getRuleIndex() const {
  return SPECTREParser::RuleSens;
}

void SPECTREParser::SensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSens(this);
}

void SPECTREParser::SensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSens(this);
}


std::any SPECTREParser::SensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSens(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::SensContext* SPECTREParser::sens() {
  SensContext *_localctx = _tracker.createInstance<SensContext>(_ctx, getState());
  enterRule(_localctx, 102, SPECTREParser::RuleSens);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(974);
    match(SPECTREParser::SENS);
    setState(976);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SPECTREParser::OPEN_ROUND) {
      setState(975);
      sens_output_variables_list();
    }
    setState(980);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      setState(978);
      match(SPECTREParser::ID);
      setState(979);
      sens_design_parameters_list();
      break;
    }

    default:
      break;
    }
    setState(984);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
    case 1: {
      setState(982);
      match(SPECTREParser::ID);
      setState(983);
      sens_design_parameters_list();
      break;
    }

    default:
      break;
    }
    setState(993);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx)) {
    case 1: {
      setState(989);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(986);
          match(SPECTREParser::NL); 
        }
        setState(991);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx);
      }
      break;
    }

    case 2: {
      setState(992);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sens_output_variables_listContext ------------------------------------------------------------------

SPECTREParser::Sens_output_variables_listContext::Sens_output_variables_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Sens_output_variables_listContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Sens_output_variables_listContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}

std::vector<SPECTREParser::Node_listContext *> SPECTREParser::Sens_output_variables_listContext::node_list() {
  return getRuleContexts<SPECTREParser::Node_listContext>();
}

SPECTREParser::Node_listContext* SPECTREParser::Sens_output_variables_listContext::node_list(size_t i) {
  return getRuleContext<SPECTREParser::Node_listContext>(i);
}


size_t SPECTREParser::Sens_output_variables_listContext::getRuleIndex() const {
  return SPECTREParser::RuleSens_output_variables_list;
}

void SPECTREParser::Sens_output_variables_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSens_output_variables_list(this);
}

void SPECTREParser::Sens_output_variables_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSens_output_variables_list(this);
}


std::any SPECTREParser::Sens_output_variables_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSens_output_variables_list(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Sens_output_variables_listContext* SPECTREParser::sens_output_variables_list() {
  Sens_output_variables_listContext *_localctx = _tracker.createInstance<Sens_output_variables_listContext>(_ctx, getState());
  enterRule(_localctx, 104, SPECTREParser::RuleSens_output_variables_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(995);
    match(SPECTREParser::OPEN_ROUND);
    setState(997); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(996);
      node_list();
      setState(999); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0));
    setState(1001);
    match(SPECTREParser::CLOSE_ROUND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sens_design_parameters_listContext ------------------------------------------------------------------

SPECTREParser::Sens_design_parameters_listContext::Sens_design_parameters_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Sens_design_parameters_listContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Sens_design_parameters_listContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}

std::vector<SPECTREParser::Node_listContext *> SPECTREParser::Sens_design_parameters_listContext::node_list() {
  return getRuleContexts<SPECTREParser::Node_listContext>();
}

SPECTREParser::Node_listContext* SPECTREParser::Sens_design_parameters_listContext::node_list(size_t i) {
  return getRuleContext<SPECTREParser::Node_listContext>(i);
}


size_t SPECTREParser::Sens_design_parameters_listContext::getRuleIndex() const {
  return SPECTREParser::RuleSens_design_parameters_list;
}

void SPECTREParser::Sens_design_parameters_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSens_design_parameters_list(this);
}

void SPECTREParser::Sens_design_parameters_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSens_design_parameters_list(this);
}


std::any SPECTREParser::Sens_design_parameters_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSens_design_parameters_list(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Sens_design_parameters_listContext* SPECTREParser::sens_design_parameters_list() {
  Sens_design_parameters_listContext *_localctx = _tracker.createInstance<Sens_design_parameters_listContext>(_ctx, getState());
  enterRule(_localctx, 106, SPECTREParser::RuleSens_design_parameters_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1003);
    match(SPECTREParser::OPEN_ROUND);
    setState(1005); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1004);
      node_list();
      setState(1007); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0));
    setState(1009);
    match(SPECTREParser::CLOSE_ROUND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sens_analyses_listContext ------------------------------------------------------------------

SPECTREParser::Sens_analyses_listContext::Sens_analyses_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Sens_analyses_listContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Sens_analyses_listContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}

std::vector<SPECTREParser::Node_listContext *> SPECTREParser::Sens_analyses_listContext::node_list() {
  return getRuleContexts<SPECTREParser::Node_listContext>();
}

SPECTREParser::Node_listContext* SPECTREParser::Sens_analyses_listContext::node_list(size_t i) {
  return getRuleContext<SPECTREParser::Node_listContext>(i);
}


size_t SPECTREParser::Sens_analyses_listContext::getRuleIndex() const {
  return SPECTREParser::RuleSens_analyses_list;
}

void SPECTREParser::Sens_analyses_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSens_analyses_list(this);
}

void SPECTREParser::Sens_analyses_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSens_analyses_list(this);
}


std::any SPECTREParser::Sens_analyses_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSens_analyses_list(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Sens_analyses_listContext* SPECTREParser::sens_analyses_list() {
  Sens_analyses_listContext *_localctx = _tracker.createInstance<Sens_analyses_listContext>(_ctx, getState());
  enterRule(_localctx, 108, SPECTREParser::RuleSens_analyses_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1011);
    match(SPECTREParser::OPEN_ROUND);
    setState(1013); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1012);
      node_list();
      setState(1015); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0));
    setState(1017);
    match(SPECTREParser::CLOSE_ROUND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MontecarloContext ------------------------------------------------------------------

SPECTREParser::MontecarloContext::MontecarloContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Montecarlo_headerContext* SPECTREParser::MontecarloContext::montecarlo_header() {
  return getRuleContext<SPECTREParser::Montecarlo_headerContext>(0);
}

SPECTREParser::Montecarlo_exportContext* SPECTREParser::MontecarloContext::montecarlo_export() {
  return getRuleContext<SPECTREParser::Montecarlo_exportContext>(0);
}

SPECTREParser::Montecarlo_footerContext* SPECTREParser::MontecarloContext::montecarlo_footer() {
  return getRuleContext<SPECTREParser::Montecarlo_footerContext>(0);
}

std::vector<SPECTREParser::Montecarlo_contentContext *> SPECTREParser::MontecarloContext::montecarlo_content() {
  return getRuleContexts<SPECTREParser::Montecarlo_contentContext>();
}

SPECTREParser::Montecarlo_contentContext* SPECTREParser::MontecarloContext::montecarlo_content(size_t i) {
  return getRuleContext<SPECTREParser::Montecarlo_contentContext>(i);
}


size_t SPECTREParser::MontecarloContext::getRuleIndex() const {
  return SPECTREParser::RuleMontecarlo;
}

void SPECTREParser::MontecarloContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMontecarlo(this);
}

void SPECTREParser::MontecarloContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMontecarlo(this);
}


std::any SPECTREParser::MontecarloContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitMontecarlo(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::MontecarloContext* SPECTREParser::montecarlo() {
  MontecarloContext *_localctx = _tracker.createInstance<MontecarloContext>(_ctx, getState());
  enterRule(_localctx, 110, SPECTREParser::RuleMontecarlo);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1019);
    montecarlo_header();
    setState(1021); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1020);
      montecarlo_content();
      setState(1023); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 17592236567932) != 0) || _la == SPECTREParser::SENS || _la == SPECTREParser::ID);
    setState(1025);
    montecarlo_export();
    setState(1026);
    montecarlo_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Montecarlo_headerContext ------------------------------------------------------------------

SPECTREParser::Montecarlo_headerContext::Montecarlo_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Montecarlo_headerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Montecarlo_headerContext::MONTECARLO() {
  return getToken(SPECTREParser::MONTECARLO, 0);
}

tree::TerminalNode* SPECTREParser::Montecarlo_headerContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Montecarlo_headerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Montecarlo_headerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Montecarlo_headerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}

std::vector<SPECTREParser::Parameter_listContext *> SPECTREParser::Montecarlo_headerContext::parameter_list() {
  return getRuleContexts<SPECTREParser::Parameter_listContext>();
}

SPECTREParser::Parameter_listContext* SPECTREParser::Montecarlo_headerContext::parameter_list(size_t i) {
  return getRuleContext<SPECTREParser::Parameter_listContext>(i);
}


size_t SPECTREParser::Montecarlo_headerContext::getRuleIndex() const {
  return SPECTREParser::RuleMontecarlo_header;
}

void SPECTREParser::Montecarlo_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMontecarlo_header(this);
}

void SPECTREParser::Montecarlo_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMontecarlo_header(this);
}


std::any SPECTREParser::Montecarlo_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitMontecarlo_header(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Montecarlo_headerContext* SPECTREParser::montecarlo_header() {
  Montecarlo_headerContext *_localctx = _tracker.createInstance<Montecarlo_headerContext>(_ctx, getState());
  enterRule(_localctx, 112, SPECTREParser::RuleMontecarlo_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1028);
    match(SPECTREParser::ID);
    setState(1029);
    match(SPECTREParser::MONTECARLO);
    setState(1033);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1030);
      match(SPECTREParser::NL);
      setState(1035);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1039);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9007749010555136) != 0) || _la == SPECTREParser::OPEN_ROUND

    || _la == SPECTREParser::ID) {
      setState(1036);
      parameter_list();
      setState(1041);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1042);
    match(SPECTREParser::OPEN_CURLY);
    setState(1050);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::GLOBAL:
      case SPECTREParser::INCLUDE:
      case SPECTREParser::CPP_INCLUDE:
      case SPECTREParser::AHDL_INCLUDE:
      case SPECTREParser::LIBRARY:
      case SPECTREParser::SECTION:
      case SPECTREParser::SUBCKT:
      case SPECTREParser::INLINE_SUBCKT:
      case SPECTREParser::SIMULATOR:
      case SPECTREParser::GLOBAL_PARAMETERS:
      case SPECTREParser::MODEL:
      case SPECTREParser::SAVE:
      case SPECTREParser::NODESET:
      case SPECTREParser::IC:
      case SPECTREParser::STATISTICS:
      case SPECTREParser::SENS:
      case SPECTREParser::ID:
      case SPECTREParser::NL: {
        setState(1046);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(1043);
          match(SPECTREParser::NL);
          setState(1048);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(1049);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Montecarlo_contentContext ------------------------------------------------------------------

SPECTREParser::Montecarlo_contentContext::Montecarlo_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Netlist_entityContext* SPECTREParser::Montecarlo_contentContext::netlist_entity() {
  return getRuleContext<SPECTREParser::Netlist_entityContext>(0);
}


size_t SPECTREParser::Montecarlo_contentContext::getRuleIndex() const {
  return SPECTREParser::RuleMontecarlo_content;
}

void SPECTREParser::Montecarlo_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMontecarlo_content(this);
}

void SPECTREParser::Montecarlo_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMontecarlo_content(this);
}


std::any SPECTREParser::Montecarlo_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitMontecarlo_content(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Montecarlo_contentContext* SPECTREParser::montecarlo_content() {
  Montecarlo_contentContext *_localctx = _tracker.createInstance<Montecarlo_contentContext>(_ctx, getState());
  enterRule(_localctx, 114, SPECTREParser::RuleMontecarlo_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1052);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Montecarlo_exportContext ------------------------------------------------------------------

SPECTREParser::Montecarlo_exportContext::Montecarlo_exportContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Montecarlo_exportContext::EXPORT() {
  return getToken(SPECTREParser::EXPORT, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::Montecarlo_exportContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

tree::TerminalNode* SPECTREParser::Montecarlo_exportContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Montecarlo_exportContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Montecarlo_exportContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Montecarlo_exportContext::getRuleIndex() const {
  return SPECTREParser::RuleMontecarlo_export;
}

void SPECTREParser::Montecarlo_exportContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMontecarlo_export(this);
}

void SPECTREParser::Montecarlo_exportContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMontecarlo_export(this);
}


std::any SPECTREParser::Montecarlo_exportContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitMontecarlo_export(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Montecarlo_exportContext* SPECTREParser::montecarlo_export() {
  Montecarlo_exportContext *_localctx = _tracker.createInstance<Montecarlo_exportContext>(_ctx, getState());
  enterRule(_localctx, 116, SPECTREParser::RuleMontecarlo_export);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1054);
    match(SPECTREParser::EXPORT);
    setState(1055);
    parameter_list();
    setState(1063);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::CLOSE_CURLY:
      case SPECTREParser::NL: {
        setState(1059);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(1056);
          match(SPECTREParser::NL);
          setState(1061);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(1062);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Montecarlo_footerContext ------------------------------------------------------------------

SPECTREParser::Montecarlo_footerContext::Montecarlo_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Montecarlo_footerContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Montecarlo_footerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Montecarlo_footerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Montecarlo_footerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Montecarlo_footerContext::getRuleIndex() const {
  return SPECTREParser::RuleMontecarlo_footer;
}

void SPECTREParser::Montecarlo_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMontecarlo_footer(this);
}

void SPECTREParser::Montecarlo_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMontecarlo_footer(this);
}


std::any SPECTREParser::Montecarlo_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitMontecarlo_footer(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Montecarlo_footerContext* SPECTREParser::montecarlo_footer() {
  Montecarlo_footerContext *_localctx = _tracker.createInstance<Montecarlo_footerContext>(_ctx, getState());
  enterRule(_localctx, 118, SPECTREParser::RuleMontecarlo_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1065);
    match(SPECTREParser::CLOSE_CURLY);
    setState(1073);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
    case 1: {
      setState(1069);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1066);
          match(SPECTREParser::NL); 
        }
        setState(1071);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
      }
      break;
    }

    case 2: {
      setState(1072);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoiseContext ------------------------------------------------------------------

SPECTREParser::NoiseContext::NoiseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::NoiseContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::NoiseContext::NOISE() {
  return getToken(SPECTREParser::NOISE, 0);
}

tree::TerminalNode* SPECTREParser::NoiseContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::NoiseContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::NoiseContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::NoiseContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::NoiseContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::NoiseContext::getRuleIndex() const {
  return SPECTREParser::RuleNoise;
}

void SPECTREParser::NoiseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoise(this);
}

void SPECTREParser::NoiseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoise(this);
}


std::any SPECTREParser::NoiseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNoise(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::NoiseContext* SPECTREParser::noise() {
  NoiseContext *_localctx = _tracker.createInstance<NoiseContext>(_ctx, getState());
  enterRule(_localctx, 120, SPECTREParser::RuleNoise);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1075);
    match(SPECTREParser::ID);
    setState(1077);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 100663297) != 0)) {
      setState(1076);
      node_list();
    }
    setState(1079);
    match(SPECTREParser::NOISE);
    setState(1081);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
    case 1: {
      setState(1080);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1090);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      setState(1086);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1083);
          match(SPECTREParser::NL); 
        }
        setState(1088);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      }
      break;
    }

    case 2: {
      setState(1089);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChecklimitContext ------------------------------------------------------------------

SPECTREParser::ChecklimitContext::ChecklimitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::ChecklimitContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::ChecklimitContext::CHECKLIMIT() {
  return getToken(SPECTREParser::CHECKLIMIT, 0);
}

tree::TerminalNode* SPECTREParser::ChecklimitContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::ChecklimitContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::ChecklimitContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::ChecklimitContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::ChecklimitContext::getRuleIndex() const {
  return SPECTREParser::RuleChecklimit;
}

void SPECTREParser::ChecklimitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecklimit(this);
}

void SPECTREParser::ChecklimitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecklimit(this);
}


std::any SPECTREParser::ChecklimitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitChecklimit(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::ChecklimitContext* SPECTREParser::checklimit() {
  ChecklimitContext *_localctx = _tracker.createInstance<ChecklimitContext>(_ctx, getState());
  enterRule(_localctx, 122, SPECTREParser::RuleChecklimit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1092);
    match(SPECTREParser::ID);
    setState(1093);
    match(SPECTREParser::CHECKLIMIT);
    setState(1095);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
    case 1: {
      setState(1094);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1104);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
    case 1: {
      setState(1100);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1097);
          match(SPECTREParser::NL); 
        }
        setState(1102);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);
      }
      break;
    }

    case 2: {
      setState(1103);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GlobalContext ------------------------------------------------------------------

SPECTREParser::GlobalContext::GlobalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::GlobalContext::GLOBAL() {
  return getToken(SPECTREParser::GLOBAL, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::GlobalContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

tree::TerminalNode* SPECTREParser::GlobalContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::GlobalContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::GlobalContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::GlobalContext::getRuleIndex() const {
  return SPECTREParser::RuleGlobal;
}

void SPECTREParser::GlobalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal(this);
}

void SPECTREParser::GlobalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal(this);
}


std::any SPECTREParser::GlobalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitGlobal(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::GlobalContext* SPECTREParser::global() {
  GlobalContext *_localctx = _tracker.createInstance<GlobalContext>(_ctx, getState());
  enterRule(_localctx, 124, SPECTREParser::RuleGlobal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1106);
    match(SPECTREParser::GLOBAL);
    setState(1107);
    node_list();
    setState(1115);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      setState(1111);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1108);
          match(SPECTREParser::NL); 
        }
        setState(1113);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx);
      }
      break;
    }

    case 2: {
      setState(1114);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModelContext ------------------------------------------------------------------

SPECTREParser::ModelContext::ModelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::ModelContext::MODEL() {
  return getToken(SPECTREParser::MODEL, 0);
}

SPECTREParser::Model_nameContext* SPECTREParser::ModelContext::model_name() {
  return getRuleContext<SPECTREParser::Model_nameContext>(0);
}

SPECTREParser::Model_masterContext* SPECTREParser::ModelContext::model_master() {
  return getRuleContext<SPECTREParser::Model_masterContext>(0);
}

tree::TerminalNode* SPECTREParser::ModelContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::ModelContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::ModelContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::ModelContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::ModelContext::getRuleIndex() const {
  return SPECTREParser::RuleModel;
}

void SPECTREParser::ModelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel(this);
}

void SPECTREParser::ModelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel(this);
}


std::any SPECTREParser::ModelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitModel(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::ModelContext* SPECTREParser::model() {
  ModelContext *_localctx = _tracker.createInstance<ModelContext>(_ctx, getState());
  enterRule(_localctx, 126, SPECTREParser::RuleModel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1117);
    match(SPECTREParser::MODEL);
    setState(1118);
    model_name();
    setState(1119);
    model_master();
    setState(1121);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
    case 1: {
      setState(1120);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1130);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
    case 1: {
      setState(1126);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1123);
          match(SPECTREParser::NL); 
        }
        setState(1128);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
      }
      break;
    }

    case 2: {
      setState(1129);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_nameContext ------------------------------------------------------------------

SPECTREParser::Model_nameContext::Model_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Model_nameContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}


size_t SPECTREParser::Model_nameContext::getRuleIndex() const {
  return SPECTREParser::RuleModel_name;
}

void SPECTREParser::Model_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_name(this);
}

void SPECTREParser::Model_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_name(this);
}


std::any SPECTREParser::Model_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitModel_name(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Model_nameContext* SPECTREParser::model_name() {
  Model_nameContext *_localctx = _tracker.createInstance<Model_nameContext>(_ctx, getState());
  enterRule(_localctx, 128, SPECTREParser::RuleModel_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1132);
    match(SPECTREParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_masterContext ------------------------------------------------------------------

SPECTREParser::Model_masterContext::Model_masterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Model_masterContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

SPECTREParser::Component_typeContext* SPECTREParser::Model_masterContext::component_type() {
  return getRuleContext<SPECTREParser::Component_typeContext>(0);
}


size_t SPECTREParser::Model_masterContext::getRuleIndex() const {
  return SPECTREParser::RuleModel_master;
}

void SPECTREParser::Model_masterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_master(this);
}

void SPECTREParser::Model_masterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_master(this);
}


std::any SPECTREParser::Model_masterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitModel_master(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Model_masterContext* SPECTREParser::model_master() {
  Model_masterContext *_localctx = _tracker.createInstance<Model_masterContext>(_ctx, getState());
  enterRule(_localctx, 130, SPECTREParser::RuleModel_master);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1136);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1134);
        match(SPECTREParser::ID);
        break;
      }

      case SPECTREParser::A2D:
      case SPECTREParser::B3SOIPD:
      case SPECTREParser::BJT:
      case SPECTREParser::BJT301:
      case SPECTREParser::BJT500:
      case SPECTREParser::BJT503:
      case SPECTREParser::BJT504:
      case SPECTREParser::BJT504T:
      case SPECTREParser::BSIM1:
      case SPECTREParser::BSIM2:
      case SPECTREParser::BSIM3:
      case SPECTREParser::BSIM3V3:
      case SPECTREParser::BSIM4:
      case SPECTREParser::BSIMSOI:
      case SPECTREParser::BTASOI:
      case SPECTREParser::CAPACITOR:
      case SPECTREParser::CCCS:
      case SPECTREParser::CCVS:
      case SPECTREParser::CKTROM:
      case SPECTREParser::CORE:
      case SPECTREParser::D2A:
      case SPECTREParser::DELAY:
      case SPECTREParser::DIO500:
      case SPECTREParser::DIODE:
      case SPECTREParser::EKV:
      case SPECTREParser::FOURIER:
      case SPECTREParser::GAAS:
      case SPECTREParser::HBT:
      case SPECTREParser::HISIM:
      case SPECTREParser::HVMOS:
      case SPECTREParser::INDUCTOR:
      case SPECTREParser::INTCAP:
      case SPECTREParser::IPROBE:
      case SPECTREParser::ISOURCE:
      case SPECTREParser::JFET:
      case SPECTREParser::JUNCAP:
      case SPECTREParser::MISNAN:
      case SPECTREParser::MOS0:
      case SPECTREParser::MOS1:
      case SPECTREParser::MOS1000:
      case SPECTREParser::MOS1100:
      case SPECTREParser::MOS11010:
      case SPECTREParser::MOS11011:
      case SPECTREParser::MOS15:
      case SPECTREParser::MOS2:
      case SPECTREParser::MOS3:
      case SPECTREParser::MOS30:
      case SPECTREParser::MOS3002:
      case SPECTREParser::MOS3100:
      case SPECTREParser::MOS40:
      case SPECTREParser::MOS705:
      case SPECTREParser::MOS902:
      case SPECTREParser::MOS903:
      case SPECTREParser::MSLINE:
      case SPECTREParser::MTLINE:
      case SPECTREParser::MUTUAL_INDUCTOR:
      case SPECTREParser::NODCAP:
      case SPECTREParser::NODE:
      case SPECTREParser::NPORT:
      case SPECTREParser::PARAMTEST:
      case SPECTREParser::PCCCS:
      case SPECTREParser::PCCVS:
      case SPECTREParser::PHY_RES:
      case SPECTREParser::PORT:
      case SPECTREParser::PSITFT:
      case SPECTREParser::PVCCS:
      case SPECTREParser::PVCVS:
      case SPECTREParser::QUANTITY:
      case SPECTREParser::RDIFF:
      case SPECTREParser::RELAY:
      case SPECTREParser::RESISTOR:
      case SPECTREParser::SCCCS:
      case SPECTREParser::SCCVS:
      case SPECTREParser::SVCCS:
      case SPECTREParser::SVCVS:
      case SPECTREParser::SWITCH:
      case SPECTREParser::TLINE:
      case SPECTREParser::TOM2:
      case SPECTREParser::TOM3:
      case SPECTREParser::TRANSFORMER:
      case SPECTREParser::VBIC:
      case SPECTREParser::VCCS:
      case SPECTREParser::VCVS:
      case SPECTREParser::VSOURCE:
      case SPECTREParser::WINDING:
      case SPECTREParser::ZCCCS:
      case SPECTREParser::ZCCVS:
      case SPECTREParser::ZVCCS:
      case SPECTREParser::ZVCVS:
      case SPECTREParser::BSOURCE: {
        enterOuterAlt(_localctx, 2);
        setState(1135);
        component_type();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ControlContext ------------------------------------------------------------------

SPECTREParser::ControlContext::ControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::AlterContext* SPECTREParser::ControlContext::alter() {
  return getRuleContext<SPECTREParser::AlterContext>(0);
}

SPECTREParser::AltergroupContext* SPECTREParser::ControlContext::altergroup() {
  return getRuleContext<SPECTREParser::AltergroupContext>(0);
}

SPECTREParser::Assert_statementContext* SPECTREParser::ControlContext::assert_statement() {
  return getRuleContext<SPECTREParser::Assert_statementContext>(0);
}

SPECTREParser::Check_statementContext* SPECTREParser::ControlContext::check_statement() {
  return getRuleContext<SPECTREParser::Check_statementContext>(0);
}

SPECTREParser::SaveContext* SPECTREParser::ControlContext::save() {
  return getRuleContext<SPECTREParser::SaveContext>(0);
}

SPECTREParser::OptionContext* SPECTREParser::ControlContext::option() {
  return getRuleContext<SPECTREParser::OptionContext>(0);
}

SPECTREParser::SetContext* SPECTREParser::ControlContext::set() {
  return getRuleContext<SPECTREParser::SetContext>(0);
}

SPECTREParser::ShellContext* SPECTREParser::ControlContext::shell() {
  return getRuleContext<SPECTREParser::ShellContext>(0);
}

SPECTREParser::InfoContext* SPECTREParser::ControlContext::info() {
  return getRuleContext<SPECTREParser::InfoContext>(0);
}

SPECTREParser::NodesetContext* SPECTREParser::ControlContext::nodeset() {
  return getRuleContext<SPECTREParser::NodesetContext>(0);
}

SPECTREParser::IcContext* SPECTREParser::ControlContext::ic() {
  return getRuleContext<SPECTREParser::IcContext>(0);
}


size_t SPECTREParser::ControlContext::getRuleIndex() const {
  return SPECTREParser::RuleControl;
}

void SPECTREParser::ControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterControl(this);
}

void SPECTREParser::ControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitControl(this);
}


std::any SPECTREParser::ControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitControl(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::ControlContext* SPECTREParser::control() {
  ControlContext *_localctx = _tracker.createInstance<ControlContext>(_ctx, getState());
  enterRule(_localctx, 132, SPECTREParser::RuleControl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1149);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1138);
      alter();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1139);
      altergroup();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1140);
      assert_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1141);
      check_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1142);
      save();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1143);
      option();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1144);
      set();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1145);
      shell();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1146);
      info();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1147);
      nodeset();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1148);
      ic();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterContext ------------------------------------------------------------------

SPECTREParser::AlterContext::AlterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::AlterContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::AlterContext::ALTER() {
  return getToken(SPECTREParser::ALTER, 0);
}

tree::TerminalNode* SPECTREParser::AlterContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::AlterContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::AlterContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::AlterContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::AlterContext::getRuleIndex() const {
  return SPECTREParser::RuleAlter;
}

void SPECTREParser::AlterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter(this);
}

void SPECTREParser::AlterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter(this);
}


std::any SPECTREParser::AlterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAlter(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::AlterContext* SPECTREParser::alter() {
  AlterContext *_localctx = _tracker.createInstance<AlterContext>(_ctx, getState());
  enterRule(_localctx, 134, SPECTREParser::RuleAlter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1151);
    match(SPECTREParser::ID);
    setState(1152);
    match(SPECTREParser::ALTER);
    setState(1154);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
    case 1: {
      setState(1153);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1163);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
    case 1: {
      setState(1159);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1156);
          match(SPECTREParser::NL); 
        }
        setState(1161);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx);
      }
      break;
    }

    case 2: {
      setState(1162);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltergroupContext ------------------------------------------------------------------

SPECTREParser::AltergroupContext::AltergroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Altergroup_headerContext* SPECTREParser::AltergroupContext::altergroup_header() {
  return getRuleContext<SPECTREParser::Altergroup_headerContext>(0);
}

SPECTREParser::Global_declarationsContext* SPECTREParser::AltergroupContext::global_declarations() {
  return getRuleContext<SPECTREParser::Global_declarationsContext>(0);
}

SPECTREParser::Altergroup_footerContext* SPECTREParser::AltergroupContext::altergroup_footer() {
  return getRuleContext<SPECTREParser::Altergroup_footerContext>(0);
}

std::vector<SPECTREParser::Altergroup_contentContext *> SPECTREParser::AltergroupContext::altergroup_content() {
  return getRuleContexts<SPECTREParser::Altergroup_contentContext>();
}

SPECTREParser::Altergroup_contentContext* SPECTREParser::AltergroupContext::altergroup_content(size_t i) {
  return getRuleContext<SPECTREParser::Altergroup_contentContext>(i);
}


size_t SPECTREParser::AltergroupContext::getRuleIndex() const {
  return SPECTREParser::RuleAltergroup;
}

void SPECTREParser::AltergroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAltergroup(this);
}

void SPECTREParser::AltergroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAltergroup(this);
}


std::any SPECTREParser::AltergroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAltergroup(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::AltergroupContext* SPECTREParser::altergroup() {
  AltergroupContext *_localctx = _tracker.createInstance<AltergroupContext>(_ctx, getState());
  enterRule(_localctx, 136, SPECTREParser::RuleAltergroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1165);
    altergroup_header();
    setState(1166);
    global_declarations();
    setState(1168); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1167);
      altergroup_content();
      setState(1170); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 17592236567932) != 0) || _la == SPECTREParser::SENS || _la == SPECTREParser::ID);
    setState(1172);
    altergroup_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Altergroup_headerContext ------------------------------------------------------------------

SPECTREParser::Altergroup_headerContext::Altergroup_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Altergroup_headerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Altergroup_headerContext::ALTERGROUP() {
  return getToken(SPECTREParser::ALTERGROUP, 0);
}

tree::TerminalNode* SPECTREParser::Altergroup_headerContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Altergroup_headerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Altergroup_headerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Altergroup_headerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Altergroup_headerContext::getRuleIndex() const {
  return SPECTREParser::RuleAltergroup_header;
}

void SPECTREParser::Altergroup_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAltergroup_header(this);
}

void SPECTREParser::Altergroup_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAltergroup_header(this);
}


std::any SPECTREParser::Altergroup_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAltergroup_header(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Altergroup_headerContext* SPECTREParser::altergroup_header() {
  Altergroup_headerContext *_localctx = _tracker.createInstance<Altergroup_headerContext>(_ctx, getState());
  enterRule(_localctx, 138, SPECTREParser::RuleAltergroup_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1174);
    match(SPECTREParser::ID);
    setState(1175);
    match(SPECTREParser::ALTERGROUP);
    setState(1179);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1176);
      match(SPECTREParser::NL);
      setState(1181);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1182);
    match(SPECTREParser::OPEN_CURLY);
    setState(1190);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::GLOBAL_PARAMETERS:
      case SPECTREParser::NL: {
        setState(1186);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(1183);
          match(SPECTREParser::NL);
          setState(1188);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(1189);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Altergroup_contentContext ------------------------------------------------------------------

SPECTREParser::Altergroup_contentContext::Altergroup_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Netlist_entityContext* SPECTREParser::Altergroup_contentContext::netlist_entity() {
  return getRuleContext<SPECTREParser::Netlist_entityContext>(0);
}


size_t SPECTREParser::Altergroup_contentContext::getRuleIndex() const {
  return SPECTREParser::RuleAltergroup_content;
}

void SPECTREParser::Altergroup_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAltergroup_content(this);
}

void SPECTREParser::Altergroup_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAltergroup_content(this);
}


std::any SPECTREParser::Altergroup_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAltergroup_content(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Altergroup_contentContext* SPECTREParser::altergroup_content() {
  Altergroup_contentContext *_localctx = _tracker.createInstance<Altergroup_contentContext>(_ctx, getState());
  enterRule(_localctx, 140, SPECTREParser::RuleAltergroup_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1192);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Altergroup_footerContext ------------------------------------------------------------------

SPECTREParser::Altergroup_footerContext::Altergroup_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Altergroup_footerContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Altergroup_footerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Altergroup_footerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Altergroup_footerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Altergroup_footerContext::getRuleIndex() const {
  return SPECTREParser::RuleAltergroup_footer;
}

void SPECTREParser::Altergroup_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAltergroup_footer(this);
}

void SPECTREParser::Altergroup_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAltergroup_footer(this);
}


std::any SPECTREParser::Altergroup_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAltergroup_footer(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Altergroup_footerContext* SPECTREParser::altergroup_footer() {
  Altergroup_footerContext *_localctx = _tracker.createInstance<Altergroup_footerContext>(_ctx, getState());
  enterRule(_localctx, 142, SPECTREParser::RuleAltergroup_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1194);
    match(SPECTREParser::CLOSE_CURLY);
    setState(1202);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      setState(1198);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1195);
          match(SPECTREParser::NL); 
        }
        setState(1200);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
      }
      break;
    }

    case 2: {
      setState(1201);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assert_statementContext ------------------------------------------------------------------

SPECTREParser::Assert_statementContext::Assert_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Assert_statementContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Assert_statementContext::ASSERT() {
  return getToken(SPECTREParser::ASSERT, 0);
}

SPECTREParser::Parameter_assignContext* SPECTREParser::Assert_statementContext::parameter_assign() {
  return getRuleContext<SPECTREParser::Parameter_assignContext>(0);
}

tree::TerminalNode* SPECTREParser::Assert_statementContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::Assert_statementContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Assert_statementContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Assert_statementContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Assert_statementContext::getRuleIndex() const {
  return SPECTREParser::RuleAssert_statement;
}

void SPECTREParser::Assert_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssert_statement(this);
}

void SPECTREParser::Assert_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssert_statement(this);
}


std::any SPECTREParser::Assert_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAssert_statement(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Assert_statementContext* SPECTREParser::assert_statement() {
  Assert_statementContext *_localctx = _tracker.createInstance<Assert_statementContext>(_ctx, getState());
  enterRule(_localctx, 144, SPECTREParser::RuleAssert_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1204);
    match(SPECTREParser::ID);
    setState(1205);
    match(SPECTREParser::ASSERT);
    setState(1206);
    parameter_assign();
    setState(1208);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      setState(1207);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1217);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
    case 1: {
      setState(1213);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1210);
          match(SPECTREParser::NL); 
        }
        setState(1215);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx);
      }
      break;
    }

    case 2: {
      setState(1216);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Check_statementContext ------------------------------------------------------------------

SPECTREParser::Check_statementContext::Check_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Check_statementContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Check_statementContext::CHECK() {
  return getToken(SPECTREParser::CHECK, 0);
}

SPECTREParser::Parameter_assignContext* SPECTREParser::Check_statementContext::parameter_assign() {
  return getRuleContext<SPECTREParser::Parameter_assignContext>(0);
}

tree::TerminalNode* SPECTREParser::Check_statementContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Check_statementContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Check_statementContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Check_statementContext::getRuleIndex() const {
  return SPECTREParser::RuleCheck_statement;
}

void SPECTREParser::Check_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheck_statement(this);
}

void SPECTREParser::Check_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheck_statement(this);
}


std::any SPECTREParser::Check_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitCheck_statement(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Check_statementContext* SPECTREParser::check_statement() {
  Check_statementContext *_localctx = _tracker.createInstance<Check_statementContext>(_ctx, getState());
  enterRule(_localctx, 146, SPECTREParser::RuleCheck_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1219);
    match(SPECTREParser::ID);
    setState(1220);
    match(SPECTREParser::CHECK);
    setState(1221);
    parameter_assign();
    setState(1229);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
    case 1: {
      setState(1225);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1222);
          match(SPECTREParser::NL); 
        }
        setState(1227);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx);
      }
      break;
    }

    case 2: {
      setState(1228);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SaveContext ------------------------------------------------------------------

SPECTREParser::SaveContext::SaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::SaveContext::SAVE() {
  return getToken(SPECTREParser::SAVE, 0);
}

tree::TerminalNode* SPECTREParser::SaveContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::SaveContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::SaveContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::SaveContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::SaveContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::SaveContext::getRuleIndex() const {
  return SPECTREParser::RuleSave;
}

void SPECTREParser::SaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSave(this);
}

void SPECTREParser::SaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSave(this);
}


std::any SPECTREParser::SaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSave(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::SaveContext* SPECTREParser::save() {
  SaveContext *_localctx = _tracker.createInstance<SaveContext>(_ctx, getState());
  enterRule(_localctx, 148, SPECTREParser::RuleSave);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1231);
    match(SPECTREParser::SAVE);
    setState(1232);
    match(SPECTREParser::ID);
    setState(1234);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {
    case 1: {
      setState(1233);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1243);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx)) {
    case 1: {
      setState(1239);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1236);
          match(SPECTREParser::NL); 
        }
        setState(1241);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx);
      }
      break;
    }

    case 2: {
      setState(1242);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionContext ------------------------------------------------------------------

SPECTREParser::OptionContext::OptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::OptionContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::OptionContext::OPTIONS() {
  return getToken(SPECTREParser::OPTIONS, 0);
}

tree::TerminalNode* SPECTREParser::OptionContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::OptionContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::OptionContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::OptionContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::OptionContext::getRuleIndex() const {
  return SPECTREParser::RuleOption;
}

void SPECTREParser::OptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption(this);
}

void SPECTREParser::OptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption(this);
}


std::any SPECTREParser::OptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitOption(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::OptionContext* SPECTREParser::option() {
  OptionContext *_localctx = _tracker.createInstance<OptionContext>(_ctx, getState());
  enterRule(_localctx, 150, SPECTREParser::RuleOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1245);
    match(SPECTREParser::ID);
    setState(1246);
    match(SPECTREParser::OPTIONS);
    setState(1248);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
    case 1: {
      setState(1247);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1257);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
    case 1: {
      setState(1253);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1250);
          match(SPECTREParser::NL); 
        }
        setState(1255);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx);
      }
      break;
    }

    case 2: {
      setState(1256);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetContext ------------------------------------------------------------------

SPECTREParser::SetContext::SetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::SetContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::SetContext::SET() {
  return getToken(SPECTREParser::SET, 0);
}

tree::TerminalNode* SPECTREParser::SetContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::SetContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::SetContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::SetContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::SetContext::getRuleIndex() const {
  return SPECTREParser::RuleSet;
}

void SPECTREParser::SetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet(this);
}

void SPECTREParser::SetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet(this);
}


std::any SPECTREParser::SetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitSet(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::SetContext* SPECTREParser::set() {
  SetContext *_localctx = _tracker.createInstance<SetContext>(_ctx, getState());
  enterRule(_localctx, 152, SPECTREParser::RuleSet);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1259);
    match(SPECTREParser::ID);
    setState(1260);
    match(SPECTREParser::SET);
    setState(1262);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
    case 1: {
      setState(1261);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1271);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
    case 1: {
      setState(1267);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1264);
          match(SPECTREParser::NL); 
        }
        setState(1269);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx);
      }
      break;
    }

    case 2: {
      setState(1270);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShellContext ------------------------------------------------------------------

SPECTREParser::ShellContext::ShellContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::ShellContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::ShellContext::SHELL() {
  return getToken(SPECTREParser::SHELL, 0);
}

tree::TerminalNode* SPECTREParser::ShellContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::ShellContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::ShellContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::ShellContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::ShellContext::getRuleIndex() const {
  return SPECTREParser::RuleShell;
}

void SPECTREParser::ShellContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShell(this);
}

void SPECTREParser::ShellContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShell(this);
}


std::any SPECTREParser::ShellContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitShell(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::ShellContext* SPECTREParser::shell() {
  ShellContext *_localctx = _tracker.createInstance<ShellContext>(_ctx, getState());
  enterRule(_localctx, 154, SPECTREParser::RuleShell);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1273);
    match(SPECTREParser::ID);
    setState(1274);
    match(SPECTREParser::SHELL);
    setState(1276);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx)) {
    case 1: {
      setState(1275);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1285);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      setState(1281);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1278);
          match(SPECTREParser::NL); 
        }
        setState(1283);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx);
      }
      break;
    }

    case 2: {
      setState(1284);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InfoContext ------------------------------------------------------------------

SPECTREParser::InfoContext::InfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::InfoContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::InfoContext::INFO() {
  return getToken(SPECTREParser::INFO, 0);
}

tree::TerminalNode* SPECTREParser::InfoContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::InfoContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::InfoContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::InfoContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::InfoContext::getRuleIndex() const {
  return SPECTREParser::RuleInfo;
}

void SPECTREParser::InfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfo(this);
}

void SPECTREParser::InfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfo(this);
}


std::any SPECTREParser::InfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitInfo(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::InfoContext* SPECTREParser::info() {
  InfoContext *_localctx = _tracker.createInstance<InfoContext>(_ctx, getState());
  enterRule(_localctx, 156, SPECTREParser::RuleInfo);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1287);
    match(SPECTREParser::ID);
    setState(1288);
    match(SPECTREParser::INFO);
    setState(1290);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
    case 1: {
      setState(1289);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1299);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
    case 1: {
      setState(1295);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1292);
          match(SPECTREParser::NL); 
        }
        setState(1297);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx);
      }
      break;
    }

    case 2: {
      setState(1298);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NodesetContext ------------------------------------------------------------------

SPECTREParser::NodesetContext::NodesetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::NodesetContext::NODESET() {
  return getToken(SPECTREParser::NODESET, 0);
}

tree::TerminalNode* SPECTREParser::NodesetContext::EQUAL() {
  return getToken(SPECTREParser::EQUAL, 0);
}

SPECTREParser::ExpressionContext* SPECTREParser::NodesetContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}

tree::TerminalNode* SPECTREParser::NodesetContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_accessContext* SPECTREParser::NodesetContext::parameter_access() {
  return getRuleContext<SPECTREParser::Parameter_accessContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::NodesetContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::NodesetContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::NodesetContext::getRuleIndex() const {
  return SPECTREParser::RuleNodeset;
}

void SPECTREParser::NodesetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNodeset(this);
}

void SPECTREParser::NodesetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNodeset(this);
}


std::any SPECTREParser::NodesetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNodeset(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::NodesetContext* SPECTREParser::nodeset() {
  NodesetContext *_localctx = _tracker.createInstance<NodesetContext>(_ctx, getState());
  enterRule(_localctx, 158, SPECTREParser::RuleNodeset);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1301);
    match(SPECTREParser::NODESET);
    setState(1303);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SPECTREParser::COLON) {
      setState(1302);
      parameter_access();
    }
    setState(1305);
    match(SPECTREParser::EQUAL);
    setState(1306);
    expression(0);
    setState(1314);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
    case 1: {
      setState(1310);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1307);
          match(SPECTREParser::NL); 
        }
        setState(1312);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx);
      }
      break;
    }

    case 2: {
      setState(1313);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IcContext ------------------------------------------------------------------

SPECTREParser::IcContext::IcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::IcContext::IC() {
  return getToken(SPECTREParser::IC, 0);
}

tree::TerminalNode* SPECTREParser::IcContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::IcContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::IcContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::IcContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::IcContext::getRuleIndex() const {
  return SPECTREParser::RuleIc;
}

void SPECTREParser::IcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIc(this);
}

void SPECTREParser::IcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIc(this);
}


std::any SPECTREParser::IcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitIc(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::IcContext* SPECTREParser::ic() {
  IcContext *_localctx = _tracker.createInstance<IcContext>(_ctx, getState());
  enterRule(_localctx, 160, SPECTREParser::RuleIc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1316);
    match(SPECTREParser::IC);
    setState(1318);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
    case 1: {
      setState(1317);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(1327);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 207, _ctx)) {
    case 1: {
      setState(1323);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1320);
          match(SPECTREParser::NL); 
        }
        setState(1325);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx);
      }
      break;
    }

    case 2: {
      setState(1326);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatisticsContext ------------------------------------------------------------------

SPECTREParser::StatisticsContext::StatisticsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Statistics_headerContext* SPECTREParser::StatisticsContext::statistics_header() {
  return getRuleContext<SPECTREParser::Statistics_headerContext>(0);
}

SPECTREParser::Statistics_footerContext* SPECTREParser::StatisticsContext::statistics_footer() {
  return getRuleContext<SPECTREParser::Statistics_footerContext>(0);
}

std::vector<SPECTREParser::Statistics_contentContext *> SPECTREParser::StatisticsContext::statistics_content() {
  return getRuleContexts<SPECTREParser::Statistics_contentContext>();
}

SPECTREParser::Statistics_contentContext* SPECTREParser::StatisticsContext::statistics_content(size_t i) {
  return getRuleContext<SPECTREParser::Statistics_contentContext>(i);
}


size_t SPECTREParser::StatisticsContext::getRuleIndex() const {
  return SPECTREParser::RuleStatistics;
}

void SPECTREParser::StatisticsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatistics(this);
}

void SPECTREParser::StatisticsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatistics(this);
}


std::any SPECTREParser::StatisticsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitStatistics(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::StatisticsContext* SPECTREParser::statistics() {
  StatisticsContext *_localctx = _tracker.createInstance<StatisticsContext>(_ctx, getState());
  enterRule(_localctx, 162, SPECTREParser::RuleStatistics);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1329);
    statistics_header();
    setState(1331); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1330);
      statistics_content();
      setState(1333); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1090715534753792) != 0));
    setState(1335);
    statistics_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statistics_headerContext ------------------------------------------------------------------

SPECTREParser::Statistics_headerContext::Statistics_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Statistics_headerContext::STATISTICS() {
  return getToken(SPECTREParser::STATISTICS, 0);
}

tree::TerminalNode* SPECTREParser::Statistics_headerContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Statistics_headerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Statistics_headerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Statistics_headerContext::getRuleIndex() const {
  return SPECTREParser::RuleStatistics_header;
}

void SPECTREParser::Statistics_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatistics_header(this);
}

void SPECTREParser::Statistics_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatistics_header(this);
}


std::any SPECTREParser::Statistics_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitStatistics_header(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Statistics_headerContext* SPECTREParser::statistics_header() {
  Statistics_headerContext *_localctx = _tracker.createInstance<Statistics_headerContext>(_ctx, getState());
  enterRule(_localctx, 164, SPECTREParser::RuleStatistics_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1337);
    match(SPECTREParser::STATISTICS);
    setState(1341);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1338);
      match(SPECTREParser::NL);
      setState(1343);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1344);
    match(SPECTREParser::OPEN_CURLY);
    setState(1348);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1345);
      match(SPECTREParser::NL);
      setState(1350);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statistics_contentContext ------------------------------------------------------------------

SPECTREParser::Statistics_contentContext::Statistics_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::ProcessContext* SPECTREParser::Statistics_contentContext::process() {
  return getRuleContext<SPECTREParser::ProcessContext>(0);
}

SPECTREParser::MismatchContext* SPECTREParser::Statistics_contentContext::mismatch() {
  return getRuleContext<SPECTREParser::MismatchContext>(0);
}

SPECTREParser::VaryContext* SPECTREParser::Statistics_contentContext::vary() {
  return getRuleContext<SPECTREParser::VaryContext>(0);
}

SPECTREParser::CorrelateContext* SPECTREParser::Statistics_contentContext::correlate() {
  return getRuleContext<SPECTREParser::CorrelateContext>(0);
}

SPECTREParser::TruncateContext* SPECTREParser::Statistics_contentContext::truncate() {
  return getRuleContext<SPECTREParser::TruncateContext>(0);
}


size_t SPECTREParser::Statistics_contentContext::getRuleIndex() const {
  return SPECTREParser::RuleStatistics_content;
}

void SPECTREParser::Statistics_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatistics_content(this);
}

void SPECTREParser::Statistics_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatistics_content(this);
}


std::any SPECTREParser::Statistics_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitStatistics_content(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Statistics_contentContext* SPECTREParser::statistics_content() {
  Statistics_contentContext *_localctx = _tracker.createInstance<Statistics_contentContext>(_ctx, getState());
  enterRule(_localctx, 166, SPECTREParser::RuleStatistics_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1356);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::PROCESS: {
        enterOuterAlt(_localctx, 1);
        setState(1351);
        process();
        break;
      }

      case SPECTREParser::MISMATCH: {
        enterOuterAlt(_localctx, 2);
        setState(1352);
        mismatch();
        break;
      }

      case SPECTREParser::VARY: {
        enterOuterAlt(_localctx, 3);
        setState(1353);
        vary();
        break;
      }

      case SPECTREParser::CORRELATE: {
        enterOuterAlt(_localctx, 4);
        setState(1354);
        correlate();
        break;
      }

      case SPECTREParser::TRUNCATE: {
        enterOuterAlt(_localctx, 5);
        setState(1355);
        truncate();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statistics_footerContext ------------------------------------------------------------------

SPECTREParser::Statistics_footerContext::Statistics_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Statistics_footerContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Statistics_footerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Statistics_footerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Statistics_footerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Statistics_footerContext::getRuleIndex() const {
  return SPECTREParser::RuleStatistics_footer;
}

void SPECTREParser::Statistics_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatistics_footer(this);
}

void SPECTREParser::Statistics_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatistics_footer(this);
}


std::any SPECTREParser::Statistics_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitStatistics_footer(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Statistics_footerContext* SPECTREParser::statistics_footer() {
  Statistics_footerContext *_localctx = _tracker.createInstance<Statistics_footerContext>(_ctx, getState());
  enterRule(_localctx, 168, SPECTREParser::RuleStatistics_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1358);
    match(SPECTREParser::CLOSE_CURLY);
    setState(1366);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx)) {
    case 1: {
      setState(1362);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1359);
          match(SPECTREParser::NL); 
        }
        setState(1364);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx);
      }
      break;
    }

    case 2: {
      setState(1365);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcessContext ------------------------------------------------------------------

SPECTREParser::ProcessContext::ProcessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::ProcessContext::PROCESS() {
  return getToken(SPECTREParser::PROCESS, 0);
}

tree::TerminalNode* SPECTREParser::ProcessContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::ProcessContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::ProcessContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::ProcessContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::ProcessContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}

std::vector<SPECTREParser::Statistics_contentContext *> SPECTREParser::ProcessContext::statistics_content() {
  return getRuleContexts<SPECTREParser::Statistics_contentContext>();
}

SPECTREParser::Statistics_contentContext* SPECTREParser::ProcessContext::statistics_content(size_t i) {
  return getRuleContext<SPECTREParser::Statistics_contentContext>(i);
}


size_t SPECTREParser::ProcessContext::getRuleIndex() const {
  return SPECTREParser::RuleProcess;
}

void SPECTREParser::ProcessContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcess(this);
}

void SPECTREParser::ProcessContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcess(this);
}


std::any SPECTREParser::ProcessContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitProcess(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::ProcessContext* SPECTREParser::process() {
  ProcessContext *_localctx = _tracker.createInstance<ProcessContext>(_ctx, getState());
  enterRule(_localctx, 170, SPECTREParser::RuleProcess);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1368);
    match(SPECTREParser::PROCESS);
    setState(1372);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1369);
      match(SPECTREParser::NL);
      setState(1374);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1375);
    match(SPECTREParser::OPEN_CURLY);
    setState(1379);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1376);
      match(SPECTREParser::NL);
      setState(1381);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1383); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1382);
      statistics_content();
      setState(1385); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1090715534753792) != 0));
    setState(1387);
    match(SPECTREParser::CLOSE_CURLY);
    setState(1395);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::PROCESS:
      case SPECTREParser::CORRELATE:
      case SPECTREParser::TRUNCATE:
      case SPECTREParser::MISMATCH:
      case SPECTREParser::VARY:
      case SPECTREParser::CLOSE_CURLY:
      case SPECTREParser::NL: {
        setState(1391);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(1388);
          match(SPECTREParser::NL);
          setState(1393);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(1394);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MismatchContext ------------------------------------------------------------------

SPECTREParser::MismatchContext::MismatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::MismatchContext::MISMATCH() {
  return getToken(SPECTREParser::MISMATCH, 0);
}

tree::TerminalNode* SPECTREParser::MismatchContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::MismatchContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::MismatchContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::MismatchContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::MismatchContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}

std::vector<SPECTREParser::Statistics_contentContext *> SPECTREParser::MismatchContext::statistics_content() {
  return getRuleContexts<SPECTREParser::Statistics_contentContext>();
}

SPECTREParser::Statistics_contentContext* SPECTREParser::MismatchContext::statistics_content(size_t i) {
  return getRuleContext<SPECTREParser::Statistics_contentContext>(i);
}


size_t SPECTREParser::MismatchContext::getRuleIndex() const {
  return SPECTREParser::RuleMismatch;
}

void SPECTREParser::MismatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMismatch(this);
}

void SPECTREParser::MismatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMismatch(this);
}


std::any SPECTREParser::MismatchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitMismatch(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::MismatchContext* SPECTREParser::mismatch() {
  MismatchContext *_localctx = _tracker.createInstance<MismatchContext>(_ctx, getState());
  enterRule(_localctx, 172, SPECTREParser::RuleMismatch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1397);
    match(SPECTREParser::MISMATCH);
    setState(1401);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1398);
      match(SPECTREParser::NL);
      setState(1403);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1404);
    match(SPECTREParser::OPEN_CURLY);
    setState(1408);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1405);
      match(SPECTREParser::NL);
      setState(1410);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1412); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1411);
      statistics_content();
      setState(1414); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1090715534753792) != 0));
    setState(1416);
    match(SPECTREParser::CLOSE_CURLY);
    setState(1424);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::PROCESS:
      case SPECTREParser::CORRELATE:
      case SPECTREParser::TRUNCATE:
      case SPECTREParser::MISMATCH:
      case SPECTREParser::VARY:
      case SPECTREParser::CLOSE_CURLY:
      case SPECTREParser::NL: {
        setState(1420);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(1417);
          match(SPECTREParser::NL);
          setState(1422);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(1423);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CorrelateContext ------------------------------------------------------------------

SPECTREParser::CorrelateContext::CorrelateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::CorrelateContext::CORRELATE() {
  return getToken(SPECTREParser::CORRELATE, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::CorrelateContext::ID() {
  return getTokens(SPECTREParser::ID);
}

tree::TerminalNode* SPECTREParser::CorrelateContext::ID(size_t i) {
  return getToken(SPECTREParser::ID, i);
}

std::vector<tree::TerminalNode *> SPECTREParser::CorrelateContext::EQUAL() {
  return getTokens(SPECTREParser::EQUAL);
}

tree::TerminalNode* SPECTREParser::CorrelateContext::EQUAL(size_t i) {
  return getToken(SPECTREParser::EQUAL, i);
}

std::vector<tree::TerminalNode *> SPECTREParser::CorrelateContext::OPEN_SQUARE() {
  return getTokens(SPECTREParser::OPEN_SQUARE);
}

tree::TerminalNode* SPECTREParser::CorrelateContext::OPEN_SQUARE(size_t i) {
  return getToken(SPECTREParser::OPEN_SQUARE, i);
}

std::vector<tree::TerminalNode *> SPECTREParser::CorrelateContext::CLOSE_SQUARE() {
  return getTokens(SPECTREParser::CLOSE_SQUARE);
}

tree::TerminalNode* SPECTREParser::CorrelateContext::CLOSE_SQUARE(size_t i) {
  return getToken(SPECTREParser::CLOSE_SQUARE, i);
}

tree::TerminalNode* SPECTREParser::CorrelateContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<SPECTREParser::Parameter_idContext *> SPECTREParser::CorrelateContext::parameter_id() {
  return getRuleContexts<SPECTREParser::Parameter_idContext>();
}

SPECTREParser::Parameter_idContext* SPECTREParser::CorrelateContext::parameter_id(size_t i) {
  return getRuleContext<SPECTREParser::Parameter_idContext>(i);
}

std::vector<tree::TerminalNode *> SPECTREParser::CorrelateContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::CorrelateContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}

SPECTREParser::Parameter_assignContext* SPECTREParser::CorrelateContext::parameter_assign() {
  return getRuleContext<SPECTREParser::Parameter_assignContext>(0);
}


size_t SPECTREParser::CorrelateContext::getRuleIndex() const {
  return SPECTREParser::RuleCorrelate;
}

void SPECTREParser::CorrelateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCorrelate(this);
}

void SPECTREParser::CorrelateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCorrelate(this);
}


std::any SPECTREParser::CorrelateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitCorrelate(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::CorrelateContext* SPECTREParser::correlate() {
  CorrelateContext *_localctx = _tracker.createInstance<CorrelateContext>(_ctx, getState());
  enterRule(_localctx, 174, SPECTREParser::RuleCorrelate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1470);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1426);
      match(SPECTREParser::CORRELATE);
      setState(1427);
      match(SPECTREParser::ID);
      setState(1428);
      match(SPECTREParser::EQUAL);
      setState(1429);
      match(SPECTREParser::OPEN_SQUARE);
      setState(1431); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1430);
        parameter_id();
        setState(1433); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SPECTREParser::SECTION

      || _la == SPECTREParser::DC || _la == SPECTREParser::ID);
      setState(1435);
      match(SPECTREParser::CLOSE_SQUARE);
      setState(1443);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SPECTREParser::PROCESS:
        case SPECTREParser::CORRELATE:
        case SPECTREParser::TRUNCATE:
        case SPECTREParser::MISMATCH:
        case SPECTREParser::VARY:
        case SPECTREParser::CLOSE_CURLY:
        case SPECTREParser::NL: {
          setState(1439);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SPECTREParser::NL) {
            setState(1436);
            match(SPECTREParser::NL);
            setState(1441);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          break;
        }

        case SPECTREParser::EOF: {
          setState(1442);
          match(SPECTREParser::EOF);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1445);
      match(SPECTREParser::CORRELATE);
      setState(1456); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1446);
                match(SPECTREParser::ID);
                setState(1447);
                match(SPECTREParser::EQUAL);
                setState(1448);
                match(SPECTREParser::OPEN_SQUARE);
                setState(1450); 
                _errHandler->sync(this);
                _la = _input->LA(1);
                do {
                  setState(1449);
                  parameter_id();
                  setState(1452); 
                  _errHandler->sync(this);
                  _la = _input->LA(1);
                } while (_la == SPECTREParser::SECTION

                || _la == SPECTREParser::DC || _la == SPECTREParser::ID);
                setState(1454);
                match(SPECTREParser::CLOSE_SQUARE);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1458); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(1460);
      parameter_assign();
      setState(1468);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SPECTREParser::PROCESS:
        case SPECTREParser::CORRELATE:
        case SPECTREParser::TRUNCATE:
        case SPECTREParser::MISMATCH:
        case SPECTREParser::VARY:
        case SPECTREParser::CLOSE_CURLY:
        case SPECTREParser::NL: {
          setState(1464);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SPECTREParser::NL) {
            setState(1461);
            match(SPECTREParser::NL);
            setState(1466);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          break;
        }

        case SPECTREParser::EOF: {
          setState(1467);
          match(SPECTREParser::EOF);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TruncateContext ------------------------------------------------------------------

SPECTREParser::TruncateContext::TruncateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::TruncateContext::TRUNCATE() {
  return getToken(SPECTREParser::TRUNCATE, 0);
}

SPECTREParser::Parameter_assignContext* SPECTREParser::TruncateContext::parameter_assign() {
  return getRuleContext<SPECTREParser::Parameter_assignContext>(0);
}

tree::TerminalNode* SPECTREParser::TruncateContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::TruncateContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::TruncateContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::TruncateContext::getRuleIndex() const {
  return SPECTREParser::RuleTruncate;
}

void SPECTREParser::TruncateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncate(this);
}

void SPECTREParser::TruncateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncate(this);
}


std::any SPECTREParser::TruncateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitTruncate(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::TruncateContext* SPECTREParser::truncate() {
  TruncateContext *_localctx = _tracker.createInstance<TruncateContext>(_ctx, getState());
  enterRule(_localctx, 176, SPECTREParser::RuleTruncate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1472);
    match(SPECTREParser::TRUNCATE);
    setState(1473);
    parameter_assign();
    setState(1481);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::PROCESS:
      case SPECTREParser::CORRELATE:
      case SPECTREParser::TRUNCATE:
      case SPECTREParser::MISMATCH:
      case SPECTREParser::VARY:
      case SPECTREParser::CLOSE_CURLY:
      case SPECTREParser::NL: {
        setState(1477);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(1474);
          match(SPECTREParser::NL);
          setState(1479);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(1480);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VaryContext ------------------------------------------------------------------

SPECTREParser::VaryContext::VaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::VaryContext::VARY() {
  return getToken(SPECTREParser::VARY, 0);
}

tree::TerminalNode* SPECTREParser::VaryContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::VaryContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::VaryContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::VaryContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::VaryContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::VaryContext::getRuleIndex() const {
  return SPECTREParser::RuleVary;
}

void SPECTREParser::VaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVary(this);
}

void SPECTREParser::VaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVary(this);
}


std::any SPECTREParser::VaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitVary(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::VaryContext* SPECTREParser::vary() {
  VaryContext *_localctx = _tracker.createInstance<VaryContext>(_ctx, getState());
  enterRule(_localctx, 178, SPECTREParser::RuleVary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1483);
    match(SPECTREParser::VARY);
    setState(1484);
    match(SPECTREParser::ID);
    setState(1486);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9007749010555136) != 0) || _la == SPECTREParser::OPEN_ROUND

    || _la == SPECTREParser::ID) {
      setState(1485);
      parameter_list();
    }
    setState(1495);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::PROCESS:
      case SPECTREParser::CORRELATE:
      case SPECTREParser::TRUNCATE:
      case SPECTREParser::MISMATCH:
      case SPECTREParser::VARY:
      case SPECTREParser::CLOSE_CURLY:
      case SPECTREParser::NL: {
        setState(1491);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(1488);
          match(SPECTREParser::NL);
          setState(1493);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(1494);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReliabilityContext ------------------------------------------------------------------

SPECTREParser::ReliabilityContext::ReliabilityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Reliability_headerContext* SPECTREParser::ReliabilityContext::reliability_header() {
  return getRuleContext<SPECTREParser::Reliability_headerContext>(0);
}

SPECTREParser::Reliability_footerContext* SPECTREParser::ReliabilityContext::reliability_footer() {
  return getRuleContext<SPECTREParser::Reliability_footerContext>(0);
}

std::vector<SPECTREParser::Reliability_contentContext *> SPECTREParser::ReliabilityContext::reliability_content() {
  return getRuleContexts<SPECTREParser::Reliability_contentContext>();
}

SPECTREParser::Reliability_contentContext* SPECTREParser::ReliabilityContext::reliability_content(size_t i) {
  return getRuleContext<SPECTREParser::Reliability_contentContext>(i);
}


size_t SPECTREParser::ReliabilityContext::getRuleIndex() const {
  return SPECTREParser::RuleReliability;
}

void SPECTREParser::ReliabilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReliability(this);
}

void SPECTREParser::ReliabilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReliability(this);
}


std::any SPECTREParser::ReliabilityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitReliability(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::ReliabilityContext* SPECTREParser::reliability() {
  ReliabilityContext *_localctx = _tracker.createInstance<ReliabilityContext>(_ctx, getState());
  enterRule(_localctx, 180, SPECTREParser::RuleReliability);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1497);
    reliability_header();
    setState(1499); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1498);
      reliability_content();
      setState(1501); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 17592236567932) != 0) || _la == SPECTREParser::SENS || _la == SPECTREParser::ID);
    setState(1503);
    reliability_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reliability_headerContext ------------------------------------------------------------------

SPECTREParser::Reliability_headerContext::Reliability_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Reliability_headerContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Reliability_headerContext::RELIABILITY() {
  return getToken(SPECTREParser::RELIABILITY, 0);
}

tree::TerminalNode* SPECTREParser::Reliability_headerContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::Reliability_headerContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Reliability_headerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Reliability_headerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Reliability_headerContext::getRuleIndex() const {
  return SPECTREParser::RuleReliability_header;
}

void SPECTREParser::Reliability_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReliability_header(this);
}

void SPECTREParser::Reliability_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReliability_header(this);
}


std::any SPECTREParser::Reliability_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitReliability_header(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Reliability_headerContext* SPECTREParser::reliability_header() {
  Reliability_headerContext *_localctx = _tracker.createInstance<Reliability_headerContext>(_ctx, getState());
  enterRule(_localctx, 182, SPECTREParser::RuleReliability_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1505);
    match(SPECTREParser::ID);
    setState(1506);
    match(SPECTREParser::RELIABILITY);
    setState(1508);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9007749010555136) != 0) || _la == SPECTREParser::OPEN_ROUND

    || _la == SPECTREParser::ID) {
      setState(1507);
      parameter_list();
    }
    setState(1513);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1510);
      match(SPECTREParser::NL);
      setState(1515);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1516);
    match(SPECTREParser::OPEN_CURLY);
    setState(1520);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SPECTREParser::NL) {
      setState(1517);
      match(SPECTREParser::NL);
      setState(1522);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reliability_contentContext ------------------------------------------------------------------

SPECTREParser::Reliability_contentContext::Reliability_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Reliability_controlContext* SPECTREParser::Reliability_contentContext::reliability_control() {
  return getRuleContext<SPECTREParser::Reliability_controlContext>(0);
}

SPECTREParser::Netlist_entityContext* SPECTREParser::Reliability_contentContext::netlist_entity() {
  return getRuleContext<SPECTREParser::Netlist_entityContext>(0);
}


size_t SPECTREParser::Reliability_contentContext::getRuleIndex() const {
  return SPECTREParser::RuleReliability_content;
}

void SPECTREParser::Reliability_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReliability_content(this);
}

void SPECTREParser::Reliability_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReliability_content(this);
}


std::any SPECTREParser::Reliability_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitReliability_content(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Reliability_contentContext* SPECTREParser::reliability_content() {
  Reliability_contentContext *_localctx = _tracker.createInstance<Reliability_contentContext>(_ctx, getState());
  enterRule(_localctx, 184, SPECTREParser::RuleReliability_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1525);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1523);
      reliability_control();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1524);
      netlist_entity();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reliability_footerContext ------------------------------------------------------------------

SPECTREParser::Reliability_footerContext::Reliability_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Reliability_footerContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Reliability_footerContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Reliability_footerContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Reliability_footerContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Reliability_footerContext::getRuleIndex() const {
  return SPECTREParser::RuleReliability_footer;
}

void SPECTREParser::Reliability_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReliability_footer(this);
}

void SPECTREParser::Reliability_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReliability_footer(this);
}


std::any SPECTREParser::Reliability_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitReliability_footer(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Reliability_footerContext* SPECTREParser::reliability_footer() {
  Reliability_footerContext *_localctx = _tracker.createInstance<Reliability_footerContext>(_ctx, getState());
  enterRule(_localctx, 186, SPECTREParser::RuleReliability_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1527);
    match(SPECTREParser::CLOSE_CURLY);
    setState(1535);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      setState(1531);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1528);
          match(SPECTREParser::NL); 
        }
        setState(1533);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
      }
      break;
    }

    case 2: {
      setState(1534);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reliability_controlContext ------------------------------------------------------------------

SPECTREParser::Reliability_controlContext::Reliability_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Reliability_controlContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

SPECTREParser::Parameter_listContext* SPECTREParser::Reliability_controlContext::parameter_list() {
  return getRuleContext<SPECTREParser::Parameter_listContext>(0);
}

tree::TerminalNode* SPECTREParser::Reliability_controlContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Reliability_controlContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Reliability_controlContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Reliability_controlContext::getRuleIndex() const {
  return SPECTREParser::RuleReliability_control;
}

void SPECTREParser::Reliability_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReliability_control(this);
}

void SPECTREParser::Reliability_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReliability_control(this);
}


std::any SPECTREParser::Reliability_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitReliability_control(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Reliability_controlContext* SPECTREParser::reliability_control() {
  Reliability_controlContext *_localctx = _tracker.createInstance<Reliability_controlContext>(_ctx, getState());
  enterRule(_localctx, 188, SPECTREParser::RuleReliability_control);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1537);
    match(SPECTREParser::ID);
    setState(1538);
    parameter_list();
    setState(1546);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::GLOBAL:
      case SPECTREParser::INCLUDE:
      case SPECTREParser::CPP_INCLUDE:
      case SPECTREParser::AHDL_INCLUDE:
      case SPECTREParser::LIBRARY:
      case SPECTREParser::SECTION:
      case SPECTREParser::SUBCKT:
      case SPECTREParser::INLINE_SUBCKT:
      case SPECTREParser::SIMULATOR:
      case SPECTREParser::GLOBAL_PARAMETERS:
      case SPECTREParser::MODEL:
      case SPECTREParser::SAVE:
      case SPECTREParser::NODESET:
      case SPECTREParser::IC:
      case SPECTREParser::STATISTICS:
      case SPECTREParser::SENS:
      case SPECTREParser::CLOSE_CURLY:
      case SPECTREParser::ID:
      case SPECTREParser::NL: {
        setState(1542);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SPECTREParser::NL) {
          setState(1539);
          match(SPECTREParser::NL);
          setState(1544);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SPECTREParser::EOF: {
        setState(1545);
        match(SPECTREParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_declarationsContext ------------------------------------------------------------------

SPECTREParser::Global_declarationsContext::Global_declarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Global_declarationsContext::GLOBAL_PARAMETERS() {
  return getToken(SPECTREParser::GLOBAL_PARAMETERS, 0);
}

tree::TerminalNode* SPECTREParser::Global_declarationsContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Global_declarationsContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Global_declarationsContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

std::vector<SPECTREParser::Parameter_list_itemContext *> SPECTREParser::Global_declarationsContext::parameter_list_item() {
  return getRuleContexts<SPECTREParser::Parameter_list_itemContext>();
}

SPECTREParser::Parameter_list_itemContext* SPECTREParser::Global_declarationsContext::parameter_list_item(size_t i) {
  return getRuleContext<SPECTREParser::Parameter_list_itemContext>(i);
}

std::vector<tree::TerminalNode *> SPECTREParser::Global_declarationsContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::Global_declarationsContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::Global_declarationsContext::getRuleIndex() const {
  return SPECTREParser::RuleGlobal_declarations;
}

void SPECTREParser::Global_declarationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_declarations(this);
}

void SPECTREParser::Global_declarationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_declarations(this);
}


std::any SPECTREParser::Global_declarationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitGlobal_declarations(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Global_declarationsContext* SPECTREParser::global_declarations() {
  Global_declarationsContext *_localctx = _tracker.createInstance<Global_declarationsContext>(_ctx, getState());
  enterRule(_localctx, 190, SPECTREParser::RuleGlobal_declarations);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1580);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1548);
      match(SPECTREParser::GLOBAL_PARAMETERS);
      setState(1549);
      match(SPECTREParser::OPEN_ROUND);
      setState(1551); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1550);
        parameter_list_item();
        setState(1553); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SPECTREParser::SECTION

      || _la == SPECTREParser::DC || _la == SPECTREParser::ID);
      setState(1555);
      match(SPECTREParser::CLOSE_ROUND);
      setState(1563);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
      case 1: {
        setState(1559);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1556);
            match(SPECTREParser::NL); 
          }
          setState(1561);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx);
        }
        break;
      }

      case 2: {
        setState(1562);
        match(SPECTREParser::EOF);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1565);
      match(SPECTREParser::GLOBAL_PARAMETERS);
      setState(1567); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1566);
                parameter_list_item();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1569); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(1578);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
      case 1: {
        setState(1574);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1571);
            match(SPECTREParser::NL); 
          }
          setState(1576);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx);
        }
        break;
      }

      case 2: {
        setState(1577);
        match(SPECTREParser::EOF);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentContext ------------------------------------------------------------------

SPECTREParser::ComponentContext::ComponentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Component_idContext* SPECTREParser::ComponentContext::component_id() {
  return getRuleContext<SPECTREParser::Component_idContext>(0);
}

SPECTREParser::Component_masterContext* SPECTREParser::ComponentContext::component_master() {
  return getRuleContext<SPECTREParser::Component_masterContext>(0);
}

tree::TerminalNode* SPECTREParser::ComponentContext::EOF() {
  return getToken(SPECTREParser::EOF, 0);
}

SPECTREParser::Node_listContext* SPECTREParser::ComponentContext::node_list() {
  return getRuleContext<SPECTREParser::Node_listContext>(0);
}

std::vector<SPECTREParser::Component_attributeContext *> SPECTREParser::ComponentContext::component_attribute() {
  return getRuleContexts<SPECTREParser::Component_attributeContext>();
}

SPECTREParser::Component_attributeContext* SPECTREParser::ComponentContext::component_attribute(size_t i) {
  return getRuleContext<SPECTREParser::Component_attributeContext>(i);
}

std::vector<tree::TerminalNode *> SPECTREParser::ComponentContext::NL() {
  return getTokens(SPECTREParser::NL);
}

tree::TerminalNode* SPECTREParser::ComponentContext::NL(size_t i) {
  return getToken(SPECTREParser::NL, i);
}


size_t SPECTREParser::ComponentContext::getRuleIndex() const {
  return SPECTREParser::RuleComponent;
}

void SPECTREParser::ComponentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent(this);
}

void SPECTREParser::ComponentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent(this);
}


std::any SPECTREParser::ComponentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitComponent(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::ComponentContext* SPECTREParser::component() {
  ComponentContext *_localctx = _tracker.createInstance<ComponentContext>(_ctx, getState());
  enterRule(_localctx, 192, SPECTREParser::RuleComponent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1582);
    component_id();
    setState(1584);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
    case 1: {
      setState(1583);
      node_list();
      break;
    }

    default:
      break;
    }
    setState(1586);
    component_master();
    setState(1590);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1587);
        component_attribute(); 
      }
      setState(1592);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx);
    }
    setState(1600);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
    case 1: {
      setState(1596);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1593);
          match(SPECTREParser::NL); 
        }
        setState(1598);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx);
      }
      break;
    }

    case 2: {
      setState(1599);
      match(SPECTREParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_idContext ------------------------------------------------------------------

SPECTREParser::Component_idContext::Component_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Component_idContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}


size_t SPECTREParser::Component_idContext::getRuleIndex() const {
  return SPECTREParser::RuleComponent_id;
}

void SPECTREParser::Component_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_id(this);
}

void SPECTREParser::Component_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_id(this);
}


std::any SPECTREParser::Component_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitComponent_id(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Component_idContext* SPECTREParser::component_id() {
  Component_idContext *_localctx = _tracker.createInstance<Component_idContext>(_ctx, getState());
  enterRule(_localctx, 194, SPECTREParser::RuleComponent_id);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1602);
    match(SPECTREParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_masterContext ------------------------------------------------------------------

SPECTREParser::Component_masterContext::Component_masterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Component_masterContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

SPECTREParser::Component_typeContext* SPECTREParser::Component_masterContext::component_type() {
  return getRuleContext<SPECTREParser::Component_typeContext>(0);
}


size_t SPECTREParser::Component_masterContext::getRuleIndex() const {
  return SPECTREParser::RuleComponent_master;
}

void SPECTREParser::Component_masterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_master(this);
}

void SPECTREParser::Component_masterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_master(this);
}


std::any SPECTREParser::Component_masterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitComponent_master(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Component_masterContext* SPECTREParser::component_master() {
  Component_masterContext *_localctx = _tracker.createInstance<Component_masterContext>(_ctx, getState());
  enterRule(_localctx, 196, SPECTREParser::RuleComponent_master);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1606);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1604);
        match(SPECTREParser::ID);
        break;
      }

      case SPECTREParser::A2D:
      case SPECTREParser::B3SOIPD:
      case SPECTREParser::BJT:
      case SPECTREParser::BJT301:
      case SPECTREParser::BJT500:
      case SPECTREParser::BJT503:
      case SPECTREParser::BJT504:
      case SPECTREParser::BJT504T:
      case SPECTREParser::BSIM1:
      case SPECTREParser::BSIM2:
      case SPECTREParser::BSIM3:
      case SPECTREParser::BSIM3V3:
      case SPECTREParser::BSIM4:
      case SPECTREParser::BSIMSOI:
      case SPECTREParser::BTASOI:
      case SPECTREParser::CAPACITOR:
      case SPECTREParser::CCCS:
      case SPECTREParser::CCVS:
      case SPECTREParser::CKTROM:
      case SPECTREParser::CORE:
      case SPECTREParser::D2A:
      case SPECTREParser::DELAY:
      case SPECTREParser::DIO500:
      case SPECTREParser::DIODE:
      case SPECTREParser::EKV:
      case SPECTREParser::FOURIER:
      case SPECTREParser::GAAS:
      case SPECTREParser::HBT:
      case SPECTREParser::HISIM:
      case SPECTREParser::HVMOS:
      case SPECTREParser::INDUCTOR:
      case SPECTREParser::INTCAP:
      case SPECTREParser::IPROBE:
      case SPECTREParser::ISOURCE:
      case SPECTREParser::JFET:
      case SPECTREParser::JUNCAP:
      case SPECTREParser::MISNAN:
      case SPECTREParser::MOS0:
      case SPECTREParser::MOS1:
      case SPECTREParser::MOS1000:
      case SPECTREParser::MOS1100:
      case SPECTREParser::MOS11010:
      case SPECTREParser::MOS11011:
      case SPECTREParser::MOS15:
      case SPECTREParser::MOS2:
      case SPECTREParser::MOS3:
      case SPECTREParser::MOS30:
      case SPECTREParser::MOS3002:
      case SPECTREParser::MOS3100:
      case SPECTREParser::MOS40:
      case SPECTREParser::MOS705:
      case SPECTREParser::MOS902:
      case SPECTREParser::MOS903:
      case SPECTREParser::MSLINE:
      case SPECTREParser::MTLINE:
      case SPECTREParser::MUTUAL_INDUCTOR:
      case SPECTREParser::NODCAP:
      case SPECTREParser::NODE:
      case SPECTREParser::NPORT:
      case SPECTREParser::PARAMTEST:
      case SPECTREParser::PCCCS:
      case SPECTREParser::PCCVS:
      case SPECTREParser::PHY_RES:
      case SPECTREParser::PORT:
      case SPECTREParser::PSITFT:
      case SPECTREParser::PVCCS:
      case SPECTREParser::PVCVS:
      case SPECTREParser::QUANTITY:
      case SPECTREParser::RDIFF:
      case SPECTREParser::RELAY:
      case SPECTREParser::RESISTOR:
      case SPECTREParser::SCCCS:
      case SPECTREParser::SCCVS:
      case SPECTREParser::SVCCS:
      case SPECTREParser::SVCVS:
      case SPECTREParser::SWITCH:
      case SPECTREParser::TLINE:
      case SPECTREParser::TOM2:
      case SPECTREParser::TOM3:
      case SPECTREParser::TRANSFORMER:
      case SPECTREParser::VBIC:
      case SPECTREParser::VCCS:
      case SPECTREParser::VCVS:
      case SPECTREParser::VSOURCE:
      case SPECTREParser::WINDING:
      case SPECTREParser::ZCCCS:
      case SPECTREParser::ZCCVS:
      case SPECTREParser::ZVCCS:
      case SPECTREParser::ZVCVS:
      case SPECTREParser::BSOURCE: {
        enterOuterAlt(_localctx, 2);
        setState(1605);
        component_type();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_attributeContext ------------------------------------------------------------------

SPECTREParser::Component_attributeContext::Component_attributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Component_valueContext* SPECTREParser::Component_attributeContext::component_value() {
  return getRuleContext<SPECTREParser::Component_valueContext>(0);
}

SPECTREParser::Component_value_listContext* SPECTREParser::Component_attributeContext::component_value_list() {
  return getRuleContext<SPECTREParser::Component_value_listContext>(0);
}

SPECTREParser::Component_analysisContext* SPECTREParser::Component_attributeContext::component_analysis() {
  return getRuleContext<SPECTREParser::Component_analysisContext>(0);
}

SPECTREParser::Parameter_assignContext* SPECTREParser::Component_attributeContext::parameter_assign() {
  return getRuleContext<SPECTREParser::Parameter_assignContext>(0);
}


size_t SPECTREParser::Component_attributeContext::getRuleIndex() const {
  return SPECTREParser::RuleComponent_attribute;
}

void SPECTREParser::Component_attributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_attribute(this);
}

void SPECTREParser::Component_attributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_attribute(this);
}


std::any SPECTREParser::Component_attributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitComponent_attribute(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Component_attributeContext* SPECTREParser::component_attribute() {
  Component_attributeContext *_localctx = _tracker.createInstance<Component_attributeContext>(_ctx, getState());
  enterRule(_localctx, 198, SPECTREParser::RuleComponent_attribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1612);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1608);
      component_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1609);
      component_value_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1610);
      component_analysis();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1611);
      parameter_assign();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_valueContext ------------------------------------------------------------------

SPECTREParser::Component_valueContext::Component_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Component_valueContext::STRING() {
  return getToken(SPECTREParser::STRING, 0);
}

SPECTREParser::ExpressionContext* SPECTREParser::Component_valueContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}

tree::TerminalNode* SPECTREParser::Component_valueContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Component_valueContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}


size_t SPECTREParser::Component_valueContext::getRuleIndex() const {
  return SPECTREParser::RuleComponent_value;
}

void SPECTREParser::Component_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_value(this);
}

void SPECTREParser::Component_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_value(this);
}


std::any SPECTREParser::Component_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitComponent_value(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Component_valueContext* SPECTREParser::component_value() {
  Component_valueContext *_localctx = _tracker.createInstance<Component_valueContext>(_ctx, getState());
  enterRule(_localctx, 200, SPECTREParser::RuleComponent_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1615);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
    case 1: {
      setState(1614);
      match(SPECTREParser::OPEN_CURLY);
      break;
    }

    default:
      break;
    }
    setState(1619);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
    case 1: {
      setState(1617);
      match(SPECTREParser::STRING);
      break;
    }

    case 2: {
      setState(1618);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(1622);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      setState(1621);
      match(SPECTREParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_value_listContext ------------------------------------------------------------------

SPECTREParser::Component_value_listContext::Component_value_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::PWL() {
  return getToken(SPECTREParser::PWL, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::SIN() {
  return getToken(SPECTREParser::SIN, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::SFFM() {
  return getToken(SPECTREParser::SFFM, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::PULSE() {
  return getToken(SPECTREParser::PULSE, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::WAVE() {
  return getToken(SPECTREParser::WAVE, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::COEFFS() {
  return getToken(SPECTREParser::COEFFS, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::EQUAL() {
  return getToken(SPECTREParser::EQUAL, 0);
}

std::vector<SPECTREParser::Time_pairContext *> SPECTREParser::Component_value_listContext::time_pair() {
  return getRuleContexts<SPECTREParser::Time_pairContext>();
}

SPECTREParser::Time_pairContext* SPECTREParser::Component_value_listContext::time_pair(size_t i) {
  return getRuleContext<SPECTREParser::Time_pairContext>(i);
}

std::vector<SPECTREParser::ExpressionContext *> SPECTREParser::Component_value_listContext::expression() {
  return getRuleContexts<SPECTREParser::ExpressionContext>();
}

SPECTREParser::ExpressionContext* SPECTREParser::Component_value_listContext::expression(size_t i) {
  return getRuleContext<SPECTREParser::ExpressionContext>(i);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::OPEN_SQUARE() {
  return getToken(SPECTREParser::OPEN_SQUARE, 0);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::CLOSE_SQUARE() {
  return getToken(SPECTREParser::CLOSE_SQUARE, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Component_value_listContext::OPEN_CURLY() {
  return getTokens(SPECTREParser::OPEN_CURLY);
}

tree::TerminalNode* SPECTREParser::Component_value_listContext::OPEN_CURLY(size_t i) {
  return getToken(SPECTREParser::OPEN_CURLY, i);
}


size_t SPECTREParser::Component_value_listContext::getRuleIndex() const {
  return SPECTREParser::RuleComponent_value_list;
}

void SPECTREParser::Component_value_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_value_list(this);
}

void SPECTREParser::Component_value_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_value_list(this);
}


std::any SPECTREParser::Component_value_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitComponent_value_list(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Component_value_listContext* SPECTREParser::component_value_list() {
  Component_value_listContext *_localctx = _tracker.createInstance<Component_value_listContext>(_ctx, getState());
  enterRule(_localctx, 202, SPECTREParser::RuleComponent_value_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1681);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1624);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 67645734912) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1626);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SPECTREParser::EQUAL) {
        setState(1625);
        match(SPECTREParser::EQUAL);
      }
      setState(1628);
      match(SPECTREParser::OPEN_ROUND);
      setState(1639);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
      case 1: {
        setState(1630); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1629);
          time_pair();
          setState(1632); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -262144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & -5764606423522607105) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & 60833797) != 0));
        break;
      }

      case 2: {
        setState(1635); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1634);
          expression(0);
          setState(1637); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -262144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & -5764606423522607105) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & 60833797) != 0));
        break;
      }

      default:
        break;
      }
      setState(1641);
      match(SPECTREParser::CLOSE_ROUND);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1643);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 67645734912) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1645);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SPECTREParser::EQUAL) {
        setState(1644);
        match(SPECTREParser::EQUAL);
      }
      setState(1647);
      match(SPECTREParser::OPEN_SQUARE);
      setState(1658);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx)) {
      case 1: {
        setState(1649); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1648);
          time_pair();
          setState(1651); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -262144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & -5764606423522607105) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & 60833797) != 0));
        break;
      }

      case 2: {
        setState(1654); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1653);
          expression(0);
          setState(1656); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -262144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & -5764606423522607105) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & 60833797) != 0));
        break;
      }

      default:
        break;
      }
      setState(1660);
      match(SPECTREParser::CLOSE_SQUARE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1662);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 67645734912) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1664);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SPECTREParser::EQUAL) {
        setState(1663);
        match(SPECTREParser::EQUAL);
      }
      setState(1666);
      match(SPECTREParser::OPEN_CURLY);
      setState(1677);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
      case 1: {
        setState(1668); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1667);
                  time_pair();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1670); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case 2: {
        setState(1673); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1672);
                  expression(0);
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1675); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      default:
        break;
      }
      setState(1679);
      match(SPECTREParser::OPEN_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_analysisContext ------------------------------------------------------------------

SPECTREParser::Component_analysisContext::Component_analysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Component_analysisContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Component_analysisContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Component_analysisContext::AC() {
  return getToken(SPECTREParser::AC, 0);
}

tree::TerminalNode* SPECTREParser::Component_analysisContext::DC() {
  return getToken(SPECTREParser::DC, 0);
}

SPECTREParser::ExpressionContext* SPECTREParser::Component_analysisContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}


size_t SPECTREParser::Component_analysisContext::getRuleIndex() const {
  return SPECTREParser::RuleComponent_analysis;
}

void SPECTREParser::Component_analysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_analysis(this);
}

void SPECTREParser::Component_analysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_analysis(this);
}


std::any SPECTREParser::Component_analysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitComponent_analysis(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Component_analysisContext* SPECTREParser::component_analysis() {
  Component_analysisContext *_localctx = _tracker.createInstance<Component_analysisContext>(_ctx, getState());
  enterRule(_localctx, 204, SPECTREParser::RuleComponent_analysis);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1693);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1683);
      _la = _input->LA(1);
      if (!(_la == SPECTREParser::AC

      || _la == SPECTREParser::DC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1684);
      match(SPECTREParser::OPEN_CURLY);
      setState(1686);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -262144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & -5764606423522607105) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & 60833797) != 0)) {
        setState(1685);
        expression(0);
      }
      setState(1688);
      match(SPECTREParser::CLOSE_CURLY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1689);
      _la = _input->LA(1);
      if (!(_la == SPECTREParser::AC

      || _la == SPECTREParser::DC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1691);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
      case 1: {
        setState(1690);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_listContext ------------------------------------------------------------------

SPECTREParser::Node_listContext::Node_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SPECTREParser::Node_list_itemContext *> SPECTREParser::Node_listContext::node_list_item() {
  return getRuleContexts<SPECTREParser::Node_list_itemContext>();
}

SPECTREParser::Node_list_itemContext* SPECTREParser::Node_listContext::node_list_item(size_t i) {
  return getRuleContext<SPECTREParser::Node_list_itemContext>(i);
}

tree::TerminalNode* SPECTREParser::Node_listContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Node_listContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}


size_t SPECTREParser::Node_listContext::getRuleIndex() const {
  return SPECTREParser::RuleNode_list;
}

void SPECTREParser::Node_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_list(this);
}

void SPECTREParser::Node_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_list(this);
}


std::any SPECTREParser::Node_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNode_list(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Node_listContext* SPECTREParser::node_list() {
  Node_listContext *_localctx = _tracker.createInstance<Node_listContext>(_ctx, getState());
  enterRule(_localctx, 206, SPECTREParser::RuleNode_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1708);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SPECTREParser::NUMBER:
      case SPECTREParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1696); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1695);
                  node_list_item();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1698); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case SPECTREParser::OPEN_ROUND: {
        enterOuterAlt(_localctx, 2);
        setState(1700);
        match(SPECTREParser::OPEN_ROUND);
        setState(1702); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1701);
          node_list_item();
          setState(1704); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == SPECTREParser::NUMBER

        || _la == SPECTREParser::ID);
        setState(1706);
        match(SPECTREParser::CLOSE_ROUND);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_list_itemContext ------------------------------------------------------------------

SPECTREParser::Node_list_itemContext::Node_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::NodeContext* SPECTREParser::Node_list_itemContext::node() {
  return getRuleContext<SPECTREParser::NodeContext>(0);
}

SPECTREParser::Node_mappingContext* SPECTREParser::Node_list_itemContext::node_mapping() {
  return getRuleContext<SPECTREParser::Node_mappingContext>(0);
}

SPECTREParser::Node_branchContext* SPECTREParser::Node_list_itemContext::node_branch() {
  return getRuleContext<SPECTREParser::Node_branchContext>(0);
}


size_t SPECTREParser::Node_list_itemContext::getRuleIndex() const {
  return SPECTREParser::RuleNode_list_item;
}

void SPECTREParser::Node_list_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_list_item(this);
}

void SPECTREParser::Node_list_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_list_item(this);
}


std::any SPECTREParser::Node_list_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNode_list_item(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Node_list_itemContext* SPECTREParser::node_list_item() {
  Node_list_itemContext *_localctx = _tracker.createInstance<Node_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 208, SPECTREParser::RuleNode_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1713);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1710);
      node();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1711);
      node_mapping();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1712);
      node_branch();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_mappingContext ------------------------------------------------------------------

SPECTREParser::Node_mappingContext::Node_mappingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SPECTREParser::NodeContext *> SPECTREParser::Node_mappingContext::node() {
  return getRuleContexts<SPECTREParser::NodeContext>();
}

SPECTREParser::NodeContext* SPECTREParser::Node_mappingContext::node(size_t i) {
  return getRuleContext<SPECTREParser::NodeContext>(i);
}

tree::TerminalNode* SPECTREParser::Node_mappingContext::EQUAL() {
  return getToken(SPECTREParser::EQUAL, 0);
}


size_t SPECTREParser::Node_mappingContext::getRuleIndex() const {
  return SPECTREParser::RuleNode_mapping;
}

void SPECTREParser::Node_mappingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_mapping(this);
}

void SPECTREParser::Node_mappingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_mapping(this);
}


std::any SPECTREParser::Node_mappingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNode_mapping(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Node_mappingContext* SPECTREParser::node_mapping() {
  Node_mappingContext *_localctx = _tracker.createInstance<Node_mappingContext>(_ctx, getState());
  enterRule(_localctx, 210, SPECTREParser::RuleNode_mapping);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1715);
    node();
    setState(1716);
    match(SPECTREParser::EQUAL);
    setState(1717);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_pairContext ------------------------------------------------------------------

SPECTREParser::Node_pairContext::Node_pairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SPECTREParser::NodeContext *> SPECTREParser::Node_pairContext::node() {
  return getRuleContexts<SPECTREParser::NodeContext>();
}

SPECTREParser::NodeContext* SPECTREParser::Node_pairContext::node(size_t i) {
  return getRuleContext<SPECTREParser::NodeContext>(i);
}

tree::TerminalNode* SPECTREParser::Node_pairContext::COMMA() {
  return getToken(SPECTREParser::COMMA, 0);
}


size_t SPECTREParser::Node_pairContext::getRuleIndex() const {
  return SPECTREParser::RuleNode_pair;
}

void SPECTREParser::Node_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_pair(this);
}

void SPECTREParser::Node_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_pair(this);
}


std::any SPECTREParser::Node_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNode_pair(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Node_pairContext* SPECTREParser::node_pair() {
  Node_pairContext *_localctx = _tracker.createInstance<Node_pairContext>(_ctx, getState());
  enterRule(_localctx, 212, SPECTREParser::RuleNode_pair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1719);
    node();
    setState(1720);
    match(SPECTREParser::COMMA);
    setState(1721);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_branchContext ------------------------------------------------------------------

SPECTREParser::Node_branchContext::Node_branchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SPECTREParser::NodeContext *> SPECTREParser::Node_branchContext::node() {
  return getRuleContexts<SPECTREParser::NodeContext>();
}

SPECTREParser::NodeContext* SPECTREParser::Node_branchContext::node(size_t i) {
  return getRuleContext<SPECTREParser::NodeContext>(i);
}

tree::TerminalNode* SPECTREParser::Node_branchContext::COLON() {
  return getToken(SPECTREParser::COLON, 0);
}


size_t SPECTREParser::Node_branchContext::getRuleIndex() const {
  return SPECTREParser::RuleNode_branch;
}

void SPECTREParser::Node_branchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_branch(this);
}

void SPECTREParser::Node_branchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_branch(this);
}


std::any SPECTREParser::Node_branchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNode_branch(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Node_branchContext* SPECTREParser::node_branch() {
  Node_branchContext *_localctx = _tracker.createInstance<Node_branchContext>(_ctx, getState());
  enterRule(_localctx, 214, SPECTREParser::RuleNode_branch);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1723);
    node();
    setState(1724);
    match(SPECTREParser::COLON);
    setState(1725);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NodeContext ------------------------------------------------------------------

SPECTREParser::NodeContext::NodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::NodeContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::NodeContext::NUMBER() {
  return getToken(SPECTREParser::NUMBER, 0);
}

tree::TerminalNode* SPECTREParser::NodeContext::DOT() {
  return getToken(SPECTREParser::DOT, 0);
}

SPECTREParser::NodeContext* SPECTREParser::NodeContext::node() {
  return getRuleContext<SPECTREParser::NodeContext>(0);
}


size_t SPECTREParser::NodeContext::getRuleIndex() const {
  return SPECTREParser::RuleNode;
}

void SPECTREParser::NodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode(this);
}

void SPECTREParser::NodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode(this);
}


std::any SPECTREParser::NodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitNode(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::NodeContext* SPECTREParser::node() {
  NodeContext *_localctx = _tracker.createInstance<NodeContext>(_ctx, getState());
  enterRule(_localctx, 216, SPECTREParser::RuleNode);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1727);
    _la = _input->LA(1);
    if (!(_la == SPECTREParser::NUMBER

    || _la == SPECTREParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1730);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SPECTREParser::DOT) {
      setState(1728);
      match(SPECTREParser::DOT);
      setState(1729);
      node();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

SPECTREParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Expression_unaryContext* SPECTREParser::ExpressionContext::expression_unary() {
  return getRuleContext<SPECTREParser::Expression_unaryContext>(0);
}

SPECTREParser::Expression_function_callContext* SPECTREParser::ExpressionContext::expression_function_call() {
  return getRuleContext<SPECTREParser::Expression_function_callContext>(0);
}

SPECTREParser::Expression_scopeContext* SPECTREParser::ExpressionContext::expression_scope() {
  return getRuleContext<SPECTREParser::Expression_scopeContext>(0);
}

SPECTREParser::Expression_atomContext* SPECTREParser::ExpressionContext::expression_atom() {
  return getRuleContext<SPECTREParser::Expression_atomContext>(0);
}

SPECTREParser::Expression_pairContext* SPECTREParser::ExpressionContext::expression_pair() {
  return getRuleContext<SPECTREParser::Expression_pairContext>(0);
}

std::vector<SPECTREParser::ExpressionContext *> SPECTREParser::ExpressionContext::expression() {
  return getRuleContexts<SPECTREParser::ExpressionContext>();
}

SPECTREParser::ExpressionContext* SPECTREParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<SPECTREParser::ExpressionContext>(i);
}

tree::TerminalNode* SPECTREParser::ExpressionContext::QUESTION_MARK() {
  return getToken(SPECTREParser::QUESTION_MARK, 0);
}

tree::TerminalNode* SPECTREParser::ExpressionContext::COLON() {
  return getToken(SPECTREParser::COLON, 0);
}

SPECTREParser::Expression_operatorContext* SPECTREParser::ExpressionContext::expression_operator() {
  return getRuleContext<SPECTREParser::Expression_operatorContext>(0);
}


size_t SPECTREParser::ExpressionContext::getRuleIndex() const {
  return SPECTREParser::RuleExpression;
}

void SPECTREParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void SPECTREParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


std::any SPECTREParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


SPECTREParser::ExpressionContext* SPECTREParser::expression() {
   return expression(0);
}

SPECTREParser::ExpressionContext* SPECTREParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SPECTREParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  SPECTREParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 218;
  enterRecursionRule(_localctx, 218, SPECTREParser::RuleExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1738);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
    case 1: {
      setState(1733);
      expression_unary();
      break;
    }

    case 2: {
      setState(1734);
      expression_function_call();
      break;
    }

    case 3: {
      setState(1735);
      expression_scope();
      break;
    }

    case 4: {
      setState(1736);
      expression_atom();
      break;
    }

    case 5: {
      setState(1737);
      expression_pair();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1753);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1751);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(1740);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(1741);
          match(SPECTREParser::QUESTION_MARK);
          setState(1742);
          expression(0);
          setState(1743);
          match(SPECTREParser::COLON);
          setState(1744);
          expression(2);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(1746);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(1747);
          expression_operator();
          setState(1749);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
          case 1: {
            setState(1748);
            expression(0);
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(1755);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Expression_unaryContext ------------------------------------------------------------------

SPECTREParser::Expression_unaryContext::Expression_unaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::ExpressionContext* SPECTREParser::Expression_unaryContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}

tree::TerminalNode* SPECTREParser::Expression_unaryContext::PLUS() {
  return getToken(SPECTREParser::PLUS, 0);
}

tree::TerminalNode* SPECTREParser::Expression_unaryContext::MINUS() {
  return getToken(SPECTREParser::MINUS, 0);
}


size_t SPECTREParser::Expression_unaryContext::getRuleIndex() const {
  return SPECTREParser::RuleExpression_unary;
}

void SPECTREParser::Expression_unaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_unary(this);
}

void SPECTREParser::Expression_unaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_unary(this);
}


std::any SPECTREParser::Expression_unaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitExpression_unary(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Expression_unaryContext* SPECTREParser::expression_unary() {
  Expression_unaryContext *_localctx = _tracker.createInstance<Expression_unaryContext>(_ctx, getState());
  enterRule(_localctx, 220, SPECTREParser::RuleExpression_unary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1756);
    _la = _input->LA(1);
    if (!(_la == SPECTREParser::PLUS

    || _la == SPECTREParser::MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1757);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_function_callContext ------------------------------------------------------------------

SPECTREParser::Expression_function_callContext::Expression_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Expression_function_callContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Expression_function_callContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Expression_function_callContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}

std::vector<SPECTREParser::ExpressionContext *> SPECTREParser::Expression_function_callContext::expression() {
  return getRuleContexts<SPECTREParser::ExpressionContext>();
}

SPECTREParser::ExpressionContext* SPECTREParser::Expression_function_callContext::expression(size_t i) {
  return getRuleContext<SPECTREParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SPECTREParser::Expression_function_callContext::COMMA() {
  return getTokens(SPECTREParser::COMMA);
}

tree::TerminalNode* SPECTREParser::Expression_function_callContext::COMMA(size_t i) {
  return getToken(SPECTREParser::COMMA, i);
}


size_t SPECTREParser::Expression_function_callContext::getRuleIndex() const {
  return SPECTREParser::RuleExpression_function_call;
}

void SPECTREParser::Expression_function_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_function_call(this);
}

void SPECTREParser::Expression_function_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_function_call(this);
}


std::any SPECTREParser::Expression_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitExpression_function_call(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Expression_function_callContext* SPECTREParser::expression_function_call() {
  Expression_function_callContext *_localctx = _tracker.createInstance<Expression_function_callContext>(_ctx, getState());
  enterRule(_localctx, 222, SPECTREParser::RuleExpression_function_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1759);
    match(SPECTREParser::ID);
    setState(1760);
    match(SPECTREParser::OPEN_ROUND);
    setState(1765); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1761);
      expression(0);
      setState(1763);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SPECTREParser::COMMA) {
        setState(1762);
        match(SPECTREParser::COMMA);
      }
      setState(1767); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -262144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -1) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -5764606423522607105) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 60833797) != 0));
    setState(1769);
    match(SPECTREParser::CLOSE_ROUND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_pairContext ------------------------------------------------------------------

SPECTREParser::Expression_pairContext::Expression_pairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SPECTREParser::Expression_atomContext *> SPECTREParser::Expression_pairContext::expression_atom() {
  return getRuleContexts<SPECTREParser::Expression_atomContext>();
}

SPECTREParser::Expression_atomContext* SPECTREParser::Expression_pairContext::expression_atom(size_t i) {
  return getRuleContext<SPECTREParser::Expression_atomContext>(i);
}

tree::TerminalNode* SPECTREParser::Expression_pairContext::COMMA() {
  return getToken(SPECTREParser::COMMA, 0);
}


size_t SPECTREParser::Expression_pairContext::getRuleIndex() const {
  return SPECTREParser::RuleExpression_pair;
}

void SPECTREParser::Expression_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_pair(this);
}

void SPECTREParser::Expression_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_pair(this);
}


std::any SPECTREParser::Expression_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitExpression_pair(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Expression_pairContext* SPECTREParser::expression_pair() {
  Expression_pairContext *_localctx = _tracker.createInstance<Expression_pairContext>(_ctx, getState());
  enterRule(_localctx, 224, SPECTREParser::RuleExpression_pair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1771);
    expression_atom();
    setState(1772);
    match(SPECTREParser::COMMA);
    setState(1773);
    expression_atom();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_scopeContext ------------------------------------------------------------------

SPECTREParser::Expression_scopeContext::Expression_scopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Expression_scopeContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Expression_scopeContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Expression_scopeContext::APEX() {
  return getTokens(SPECTREParser::APEX);
}

tree::TerminalNode* SPECTREParser::Expression_scopeContext::APEX(size_t i) {
  return getToken(SPECTREParser::APEX, i);
}

tree::TerminalNode* SPECTREParser::Expression_scopeContext::OPEN_SQUARE() {
  return getToken(SPECTREParser::OPEN_SQUARE, 0);
}

tree::TerminalNode* SPECTREParser::Expression_scopeContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Expression_scopeContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Expression_scopeContext::CLOSE_SQUARE() {
  return getToken(SPECTREParser::CLOSE_SQUARE, 0);
}

std::vector<SPECTREParser::ExpressionContext *> SPECTREParser::Expression_scopeContext::expression() {
  return getRuleContexts<SPECTREParser::ExpressionContext>();
}

SPECTREParser::ExpressionContext* SPECTREParser::Expression_scopeContext::expression(size_t i) {
  return getRuleContext<SPECTREParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> SPECTREParser::Expression_scopeContext::COMMA() {
  return getTokens(SPECTREParser::COMMA);
}

tree::TerminalNode* SPECTREParser::Expression_scopeContext::COMMA(size_t i) {
  return getToken(SPECTREParser::COMMA, i);
}


size_t SPECTREParser::Expression_scopeContext::getRuleIndex() const {
  return SPECTREParser::RuleExpression_scope;
}

void SPECTREParser::Expression_scopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_scope(this);
}

void SPECTREParser::Expression_scopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_scope(this);
}


std::any SPECTREParser::Expression_scopeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitExpression_scope(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Expression_scopeContext* SPECTREParser::expression_scope() {
  Expression_scopeContext *_localctx = _tracker.createInstance<Expression_scopeContext>(_ctx, getState());
  enterRule(_localctx, 226, SPECTREParser::RuleExpression_scope);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1775);
    _la = _input->LA(1);
    if (!(((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 65557) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1780); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1776);
              expression(0);
              setState(1778);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == SPECTREParser::COMMA) {
                setState(1777);
                match(SPECTREParser::COMMA);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1782); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(1784);
    _la = _input->LA(1);
    if (!(((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & 32789) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_operatorContext ------------------------------------------------------------------

SPECTREParser::Expression_operatorContext::Expression_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::EQUAL() {
  return getToken(SPECTREParser::EQUAL, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::PLUS() {
  return getToken(SPECTREParser::PLUS, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::MINUS() {
  return getToken(SPECTREParser::MINUS, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::STAR() {
  return getToken(SPECTREParser::STAR, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::SLASH() {
  return getToken(SPECTREParser::SLASH, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LOGIC_AND() {
  return getToken(SPECTREParser::LOGIC_AND, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LOGIC_BITWISE_AND() {
  return getToken(SPECTREParser::LOGIC_BITWISE_AND, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LOGIC_OR() {
  return getToken(SPECTREParser::LOGIC_OR, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LOGIC_BITWISE_OR() {
  return getToken(SPECTREParser::LOGIC_BITWISE_OR, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LOGIC_EQUAL() {
  return getToken(SPECTREParser::LOGIC_EQUAL, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LOGIC_NOT_EQUAL() {
  return getToken(SPECTREParser::LOGIC_NOT_EQUAL, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LOGIC_XOR() {
  return getToken(SPECTREParser::LOGIC_XOR, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LESS_THAN() {
  return getToken(SPECTREParser::LESS_THAN, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::LESS_THAN_EQUAL() {
  return getToken(SPECTREParser::LESS_THAN_EQUAL, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::GREATER_THAN() {
  return getToken(SPECTREParser::GREATER_THAN, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::GREATER_THAN_EQUAL() {
  return getToken(SPECTREParser::GREATER_THAN_EQUAL, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::EXCLAMATION_MARK() {
  return getToken(SPECTREParser::EXCLAMATION_MARK, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::BITWISE_SHIFT_LEFT() {
  return getToken(SPECTREParser::BITWISE_SHIFT_LEFT, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::BITWISE_SHIFT_RIGHT() {
  return getToken(SPECTREParser::BITWISE_SHIFT_RIGHT, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::POWER_OPERATOR() {
  return getToken(SPECTREParser::POWER_OPERATOR, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::CARET() {
  return getToken(SPECTREParser::CARET, 0);
}

tree::TerminalNode* SPECTREParser::Expression_operatorContext::PERCENT() {
  return getToken(SPECTREParser::PERCENT, 0);
}


size_t SPECTREParser::Expression_operatorContext::getRuleIndex() const {
  return SPECTREParser::RuleExpression_operator;
}

void SPECTREParser::Expression_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_operator(this);
}

void SPECTREParser::Expression_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_operator(this);
}


std::any SPECTREParser::Expression_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitExpression_operator(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Expression_operatorContext* SPECTREParser::expression_operator() {
  Expression_operatorContext *_localctx = _tracker.createInstance<Expression_operatorContext>(_ctx, getState());
  enterRule(_localctx, 228, SPECTREParser::RuleExpression_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1786);
    _la = _input->LA(1);
    if (!(((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 13469024845823) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_atomContext ------------------------------------------------------------------

SPECTREParser::Expression_atomContext::Expression_atomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Expression_atomContext::NUMBER() {
  return getToken(SPECTREParser::NUMBER, 0);
}

tree::TerminalNode* SPECTREParser::Expression_atomContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Expression_atomContext::STRING() {
  return getToken(SPECTREParser::STRING, 0);
}

tree::TerminalNode* SPECTREParser::Expression_atomContext::PERCENTAGE() {
  return getToken(SPECTREParser::PERCENTAGE, 0);
}

SPECTREParser::KeywordContext* SPECTREParser::Expression_atomContext::keyword() {
  return getRuleContext<SPECTREParser::KeywordContext>(0);
}

SPECTREParser::Analysis_typeContext* SPECTREParser::Expression_atomContext::analysis_type() {
  return getRuleContext<SPECTREParser::Analysis_typeContext>(0);
}

SPECTREParser::Component_typeContext* SPECTREParser::Expression_atomContext::component_type() {
  return getRuleContext<SPECTREParser::Component_typeContext>(0);
}


size_t SPECTREParser::Expression_atomContext::getRuleIndex() const {
  return SPECTREParser::RuleExpression_atom;
}

void SPECTREParser::Expression_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_atom(this);
}

void SPECTREParser::Expression_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_atom(this);
}


std::any SPECTREParser::Expression_atomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitExpression_atom(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Expression_atomContext* SPECTREParser::expression_atom() {
  Expression_atomContext *_localctx = _tracker.createInstance<Expression_atomContext>(_ctx, getState());
  enterRule(_localctx, 230, SPECTREParser::RuleExpression_atom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1796);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1788);
      match(SPECTREParser::NUMBER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1789);
      match(SPECTREParser::ID);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1790);
      match(SPECTREParser::STRING);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1791);
      match(SPECTREParser::PERCENTAGE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1792);
      match(SPECTREParser::STRING);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1793);
      keyword();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1794);
      analysis_type();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1795);
      component_type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_listContext ------------------------------------------------------------------

SPECTREParser::Parameter_listContext::Parameter_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Parameter_listContext::PARAMETERS() {
  return getToken(SPECTREParser::PARAMETERS, 0);
}

tree::TerminalNode* SPECTREParser::Parameter_listContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

std::vector<SPECTREParser::Parameter_list_itemContext *> SPECTREParser::Parameter_listContext::parameter_list_item() {
  return getRuleContexts<SPECTREParser::Parameter_list_itemContext>();
}

SPECTREParser::Parameter_list_itemContext* SPECTREParser::Parameter_listContext::parameter_list_item(size_t i) {
  return getRuleContext<SPECTREParser::Parameter_list_itemContext>(i);
}

tree::TerminalNode* SPECTREParser::Parameter_listContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}


size_t SPECTREParser::Parameter_listContext::getRuleIndex() const {
  return SPECTREParser::RuleParameter_list;
}

void SPECTREParser::Parameter_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_list(this);
}

void SPECTREParser::Parameter_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_list(this);
}


std::any SPECTREParser::Parameter_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitParameter_list(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Parameter_listContext* SPECTREParser::parameter_list() {
  Parameter_listContext *_localctx = _tracker.createInstance<Parameter_listContext>(_ctx, getState());
  enterRule(_localctx, 232, SPECTREParser::RuleParameter_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1799);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SPECTREParser::PARAMETERS) {
      setState(1798);
      match(SPECTREParser::PARAMETERS);
    }
    setState(1802);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SPECTREParser::OPEN_ROUND) {
      setState(1801);
      match(SPECTREParser::OPEN_ROUND);
    }
    setState(1805); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1804);
              parameter_list_item();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1807); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(1810);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SPECTREParser::CLOSE_ROUND) {
      setState(1809);
      match(SPECTREParser::CLOSE_ROUND);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_list_itemContext ------------------------------------------------------------------

SPECTREParser::Parameter_list_itemContext::Parameter_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Parameter_assignContext* SPECTREParser::Parameter_list_itemContext::parameter_assign() {
  return getRuleContext<SPECTREParser::Parameter_assignContext>(0);
}

SPECTREParser::Parameter_idContext* SPECTREParser::Parameter_list_itemContext::parameter_id() {
  return getRuleContext<SPECTREParser::Parameter_idContext>(0);
}


size_t SPECTREParser::Parameter_list_itemContext::getRuleIndex() const {
  return SPECTREParser::RuleParameter_list_item;
}

void SPECTREParser::Parameter_list_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_list_item(this);
}

void SPECTREParser::Parameter_list_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_list_item(this);
}


std::any SPECTREParser::Parameter_list_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitParameter_list_item(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Parameter_list_itemContext* SPECTREParser::parameter_list_item() {
  Parameter_list_itemContext *_localctx = _tracker.createInstance<Parameter_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 234, SPECTREParser::RuleParameter_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1814);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1812);
      parameter_assign();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1813);
      parameter_id();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_assignContext ------------------------------------------------------------------

SPECTREParser::Parameter_assignContext::Parameter_assignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Parameter_idContext* SPECTREParser::Parameter_assignContext::parameter_id() {
  return getRuleContext<SPECTREParser::Parameter_idContext>(0);
}

tree::TerminalNode* SPECTREParser::Parameter_assignContext::EQUAL() {
  return getToken(SPECTREParser::EQUAL, 0);
}

SPECTREParser::ExpressionContext* SPECTREParser::Parameter_assignContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}

SPECTREParser::FilepathContext* SPECTREParser::Parameter_assignContext::filepath() {
  return getRuleContext<SPECTREParser::FilepathContext>(0);
}


size_t SPECTREParser::Parameter_assignContext::getRuleIndex() const {
  return SPECTREParser::RuleParameter_assign;
}

void SPECTREParser::Parameter_assignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_assign(this);
}

void SPECTREParser::Parameter_assignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_assign(this);
}


std::any SPECTREParser::Parameter_assignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitParameter_assign(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Parameter_assignContext* SPECTREParser::parameter_assign() {
  Parameter_assignContext *_localctx = _tracker.createInstance<Parameter_assignContext>(_ctx, getState());
  enterRule(_localctx, 236, SPECTREParser::RuleParameter_assign);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1824);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1816);
      parameter_id();
      setState(1817);
      match(SPECTREParser::EQUAL);
      setState(1818);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1820);
      parameter_id();
      setState(1821);
      match(SPECTREParser::EQUAL);
      setState(1822);
      filepath();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_idContext ------------------------------------------------------------------

SPECTREParser::Parameter_idContext::Parameter_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Parameter_idContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Parameter_idContext::SECTION() {
  return getToken(SPECTREParser::SECTION, 0);
}

tree::TerminalNode* SPECTREParser::Parameter_idContext::DC() {
  return getToken(SPECTREParser::DC, 0);
}

SPECTREParser::Expression_scopeContext* SPECTREParser::Parameter_idContext::expression_scope() {
  return getRuleContext<SPECTREParser::Expression_scopeContext>(0);
}


size_t SPECTREParser::Parameter_idContext::getRuleIndex() const {
  return SPECTREParser::RuleParameter_id;
}

void SPECTREParser::Parameter_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_id(this);
}

void SPECTREParser::Parameter_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_id(this);
}


std::any SPECTREParser::Parameter_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitParameter_id(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Parameter_idContext* SPECTREParser::parameter_id() {
  Parameter_idContext *_localctx = _tracker.createInstance<Parameter_idContext>(_ctx, getState());
  enterRule(_localctx, 238, SPECTREParser::RuleParameter_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1826);
    _la = _input->LA(1);
    if (!(_la == SPECTREParser::SECTION

    || _la == SPECTREParser::DC || _la == SPECTREParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1828);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
    case 1: {
      setState(1827);
      expression_scope();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_accessContext ------------------------------------------------------------------

SPECTREParser::Parameter_accessContext::Parameter_accessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Parameter_accessContext::COLON() {
  return getToken(SPECTREParser::COLON, 0);
}

tree::TerminalNode* SPECTREParser::Parameter_accessContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Parameter_accessContext::NUMBER() {
  return getToken(SPECTREParser::NUMBER, 0);
}


size_t SPECTREParser::Parameter_accessContext::getRuleIndex() const {
  return SPECTREParser::RuleParameter_access;
}

void SPECTREParser::Parameter_accessContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_access(this);
}

void SPECTREParser::Parameter_accessContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_access(this);
}


std::any SPECTREParser::Parameter_accessContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitParameter_access(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Parameter_accessContext* SPECTREParser::parameter_access() {
  Parameter_accessContext *_localctx = _tracker.createInstance<Parameter_accessContext>(_ctx, getState());
  enterRule(_localctx, 240, SPECTREParser::RuleParameter_access);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1830);
    match(SPECTREParser::COLON);
    setState(1831);
    _la = _input->LA(1);
    if (!(_la == SPECTREParser::NUMBER

    || _la == SPECTREParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_accessContext ------------------------------------------------------------------

SPECTREParser::Value_accessContext::Value_accessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Value_accessContext::OPEN_ROUND() {
  return getToken(SPECTREParser::OPEN_ROUND, 0);
}

tree::TerminalNode* SPECTREParser::Value_accessContext::CLOSE_ROUND() {
  return getToken(SPECTREParser::CLOSE_ROUND, 0);
}

SPECTREParser::ExpressionContext* SPECTREParser::Value_accessContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}

SPECTREParser::Node_pairContext* SPECTREParser::Value_accessContext::node_pair() {
  return getRuleContext<SPECTREParser::Node_pairContext>(0);
}

SPECTREParser::NodeContext* SPECTREParser::Value_accessContext::node() {
  return getRuleContext<SPECTREParser::NodeContext>(0);
}

tree::TerminalNode* SPECTREParser::Value_accessContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}


size_t SPECTREParser::Value_accessContext::getRuleIndex() const {
  return SPECTREParser::RuleValue_access;
}

void SPECTREParser::Value_accessContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_access(this);
}

void SPECTREParser::Value_accessContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_access(this);
}


std::any SPECTREParser::Value_accessContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitValue_access(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Value_accessContext* SPECTREParser::value_access() {
  Value_accessContext *_localctx = _tracker.createInstance<Value_accessContext>(_ctx, getState());
  enterRule(_localctx, 242, SPECTREParser::RuleValue_access);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1834);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SPECTREParser::ID) {
      setState(1833);
      match(SPECTREParser::ID);
    }
    setState(1836);
    match(SPECTREParser::OPEN_ROUND);
    setState(1840);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
    case 1: {
      setState(1837);
      expression(0);
      break;
    }

    case 2: {
      setState(1838);
      node_pair();
      break;
    }

    case 3: {
      setState(1839);
      node();
      break;
    }

    default:
      break;
    }
    setState(1842);
    match(SPECTREParser::CLOSE_ROUND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_access_assignContext ------------------------------------------------------------------

SPECTREParser::Value_access_assignContext::Value_access_assignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Value_accessContext* SPECTREParser::Value_access_assignContext::value_access() {
  return getRuleContext<SPECTREParser::Value_accessContext>(0);
}

tree::TerminalNode* SPECTREParser::Value_access_assignContext::EQUAL() {
  return getToken(SPECTREParser::EQUAL, 0);
}

SPECTREParser::ExpressionContext* SPECTREParser::Value_access_assignContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}


size_t SPECTREParser::Value_access_assignContext::getRuleIndex() const {
  return SPECTREParser::RuleValue_access_assign;
}

void SPECTREParser::Value_access_assignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_access_assign(this);
}

void SPECTREParser::Value_access_assignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_access_assign(this);
}


std::any SPECTREParser::Value_access_assignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitValue_access_assign(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Value_access_assignContext* SPECTREParser::value_access_assign() {
  Value_access_assignContext *_localctx = _tracker.createInstance<Value_access_assignContext>(_ctx, getState());
  enterRule(_localctx, 244, SPECTREParser::RuleValue_access_assign);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1844);
    value_access();
    setState(1845);
    match(SPECTREParser::EQUAL);
    setState(1846);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Time_pairContext ------------------------------------------------------------------

SPECTREParser::Time_pairContext::Time_pairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Time_pointContext* SPECTREParser::Time_pairContext::time_point() {
  return getRuleContext<SPECTREParser::Time_pointContext>(0);
}

SPECTREParser::ExpressionContext* SPECTREParser::Time_pairContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}

tree::TerminalNode* SPECTREParser::Time_pairContext::OPEN_CURLY() {
  return getToken(SPECTREParser::OPEN_CURLY, 0);
}

tree::TerminalNode* SPECTREParser::Time_pairContext::CLOSE_CURLY() {
  return getToken(SPECTREParser::CLOSE_CURLY, 0);
}


size_t SPECTREParser::Time_pairContext::getRuleIndex() const {
  return SPECTREParser::RuleTime_pair;
}

void SPECTREParser::Time_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime_pair(this);
}

void SPECTREParser::Time_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime_pair(this);
}


std::any SPECTREParser::Time_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitTime_pair(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Time_pairContext* SPECTREParser::time_pair() {
  Time_pairContext *_localctx = _tracker.createInstance<Time_pairContext>(_ctx, getState());
  enterRule(_localctx, 246, SPECTREParser::RuleTime_pair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1856);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1848);
      time_point();
      setState(1849);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1851);
      time_point();
      setState(1852);
      match(SPECTREParser::OPEN_CURLY);
      setState(1853);
      expression(0);
      setState(1854);
      match(SPECTREParser::CLOSE_CURLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Time_pointContext ------------------------------------------------------------------

SPECTREParser::Time_pointContext::Time_pointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::ExpressionContext* SPECTREParser::Time_pointContext::expression() {
  return getRuleContext<SPECTREParser::ExpressionContext>(0);
}


size_t SPECTREParser::Time_pointContext::getRuleIndex() const {
  return SPECTREParser::RuleTime_point;
}

void SPECTREParser::Time_pointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTime_point(this);
}

void SPECTREParser::Time_pointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTime_point(this);
}


std::any SPECTREParser::Time_pointContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitTime_point(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Time_pointContext* SPECTREParser::time_point() {
  Time_pointContext *_localctx = _tracker.createInstance<Time_pointContext>(_ctx, getState());
  enterRule(_localctx, 248, SPECTREParser::RuleTime_point);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1858);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilepathContext ------------------------------------------------------------------

SPECTREParser::FilepathContext::FilepathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SPECTREParser::Filepath_elementContext* SPECTREParser::FilepathContext::filepath_element() {
  return getRuleContext<SPECTREParser::Filepath_elementContext>(0);
}


size_t SPECTREParser::FilepathContext::getRuleIndex() const {
  return SPECTREParser::RuleFilepath;
}

void SPECTREParser::FilepathContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilepath(this);
}

void SPECTREParser::FilepathContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilepath(this);
}


std::any SPECTREParser::FilepathContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitFilepath(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::FilepathContext* SPECTREParser::filepath() {
  FilepathContext *_localctx = _tracker.createInstance<FilepathContext>(_ctx, getState());
  enterRule(_localctx, 250, SPECTREParser::RuleFilepath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1860);
    filepath_element();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Filepath_elementContext ------------------------------------------------------------------

SPECTREParser::Filepath_elementContext::Filepath_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Filepath_elementContext::ID() {
  return getToken(SPECTREParser::ID, 0);
}

tree::TerminalNode* SPECTREParser::Filepath_elementContext::STRING() {
  return getToken(SPECTREParser::STRING, 0);
}

SPECTREParser::Filepath_elementContext* SPECTREParser::Filepath_elementContext::filepath_element() {
  return getRuleContext<SPECTREParser::Filepath_elementContext>(0);
}

std::vector<tree::TerminalNode *> SPECTREParser::Filepath_elementContext::APEX() {
  return getTokens(SPECTREParser::APEX);
}

tree::TerminalNode* SPECTREParser::Filepath_elementContext::APEX(size_t i) {
  return getToken(SPECTREParser::APEX, i);
}

tree::TerminalNode* SPECTREParser::Filepath_elementContext::SLASH() {
  return getToken(SPECTREParser::SLASH, 0);
}

tree::TerminalNode* SPECTREParser::Filepath_elementContext::DOT() {
  return getToken(SPECTREParser::DOT, 0);
}

tree::TerminalNode* SPECTREParser::Filepath_elementContext::MINUS() {
  return getToken(SPECTREParser::MINUS, 0);
}

tree::TerminalNode* SPECTREParser::Filepath_elementContext::DOLLAR() {
  return getToken(SPECTREParser::DOLLAR, 0);
}


size_t SPECTREParser::Filepath_elementContext::getRuleIndex() const {
  return SPECTREParser::RuleFilepath_element;
}

void SPECTREParser::Filepath_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilepath_element(this);
}

void SPECTREParser::Filepath_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilepath_element(this);
}


std::any SPECTREParser::Filepath_elementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitFilepath_element(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Filepath_elementContext* SPECTREParser::filepath_element() {
  Filepath_elementContext *_localctx = _tracker.createInstance<Filepath_elementContext>(_ctx, getState());
  enterRule(_localctx, 252, SPECTREParser::RuleFilepath_element);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1878);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1862);
      match(SPECTREParser::ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1863);
      match(SPECTREParser::STRING);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1864);
      match(SPECTREParser::ID);
      setState(1865);
      filepath_element();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1866);
      match(SPECTREParser::APEX);
      setState(1867);
      filepath_element();
      setState(1868);
      match(SPECTREParser::APEX);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1870);
      match(SPECTREParser::SLASH);
      setState(1871);
      filepath_element();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1872);
      match(SPECTREParser::DOT);
      setState(1873);
      filepath_element();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1874);
      match(SPECTREParser::MINUS);
      setState(1875);
      filepath_element();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1876);
      match(SPECTREParser::DOLLAR);
      setState(1877);
      filepath_element();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

SPECTREParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::KeywordContext::ALTER() {
  return getToken(SPECTREParser::ALTER, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::ALTERGROUP() {
  return getToken(SPECTREParser::ALTERGROUP, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::OPTIONS() {
  return getToken(SPECTREParser::OPTIONS, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::SET() {
  return getToken(SPECTREParser::SET, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::SHELL() {
  return getToken(SPECTREParser::SHELL, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::INFO() {
  return getToken(SPECTREParser::INFO, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::NODESET() {
  return getToken(SPECTREParser::NODESET, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::IC() {
  return getToken(SPECTREParser::IC, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::ASSERT() {
  return getToken(SPECTREParser::ASSERT, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::CHECK() {
  return getToken(SPECTREParser::CHECK, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::LANGUAGE() {
  return getToken(SPECTREParser::LANGUAGE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::PORTS() {
  return getToken(SPECTREParser::PORTS, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::WAVE() {
  return getToken(SPECTREParser::WAVE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::PWL() {
  return getToken(SPECTREParser::PWL, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::SIN() {
  return getToken(SPECTREParser::SIN, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::SFFM() {
  return getToken(SPECTREParser::SFFM, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::PULSE() {
  return getToken(SPECTREParser::PULSE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::COEFFS() {
  return getToken(SPECTREParser::COEFFS, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::INSENSITIVE() {
  return getToken(SPECTREParser::INSENSITIVE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::IF() {
  return getToken(SPECTREParser::IF, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::ELSE() {
  return getToken(SPECTREParser::ELSE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::PARAMETERS() {
  return getToken(SPECTREParser::PARAMETERS, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::ANALOGMODEL() {
  return getToken(SPECTREParser::ANALOGMODEL, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::CHECKPOINT() {
  return getToken(SPECTREParser::CHECKPOINT, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::SPECTRE() {
  return getToken(SPECTREParser::SPECTRE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::SPICE() {
  return getToken(SPECTREParser::SPICE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::STATISTICS() {
  return getToken(SPECTREParser::STATISTICS, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::PROCESS() {
  return getToken(SPECTREParser::PROCESS, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::CORRELATE() {
  return getToken(SPECTREParser::CORRELATE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::TRUNCATE() {
  return getToken(SPECTREParser::TRUNCATE, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::MISMATCH() {
  return getToken(SPECTREParser::MISMATCH, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::VARY() {
  return getToken(SPECTREParser::VARY, 0);
}

tree::TerminalNode* SPECTREParser::KeywordContext::RELIABILITY() {
  return getToken(SPECTREParser::RELIABILITY, 0);
}


size_t SPECTREParser::KeywordContext::getRuleIndex() const {
  return SPECTREParser::RuleKeyword;
}

void SPECTREParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void SPECTREParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}


std::any SPECTREParser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitKeyword(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::KeywordContext* SPECTREParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 254, SPECTREParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1880);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2251799813423104) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analysis_typeContext ------------------------------------------------------------------

SPECTREParser::Analysis_typeContext::Analysis_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::AC() {
  return getToken(SPECTREParser::AC, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::ACMATCH() {
  return getToken(SPECTREParser::ACMATCH, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::DC() {
  return getToken(SPECTREParser::DC, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::DCMATCH() {
  return getToken(SPECTREParser::DCMATCH, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::ENVLP() {
  return getToken(SPECTREParser::ENVLP, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::SP() {
  return getToken(SPECTREParser::SP, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::STB() {
  return getToken(SPECTREParser::STB, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::SWEEP() {
  return getToken(SPECTREParser::SWEEP, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::TDR() {
  return getToken(SPECTREParser::TDR, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::TRAN() {
  return getToken(SPECTREParser::TRAN, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::XF() {
  return getToken(SPECTREParser::XF, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::PAC() {
  return getToken(SPECTREParser::PAC, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::PDISTO() {
  return getToken(SPECTREParser::PDISTO, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::PNOISE() {
  return getToken(SPECTREParser::PNOISE, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::PSP() {
  return getToken(SPECTREParser::PSP, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::PSS() {
  return getToken(SPECTREParser::PSS, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::PXF() {
  return getToken(SPECTREParser::PXF, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::PZ() {
  return getToken(SPECTREParser::PZ, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::QPAC() {
  return getToken(SPECTREParser::QPAC, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::QPNOISE() {
  return getToken(SPECTREParser::QPNOISE, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::QPSP() {
  return getToken(SPECTREParser::QPSP, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::QPSS() {
  return getToken(SPECTREParser::QPSS, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::QPXF() {
  return getToken(SPECTREParser::QPXF, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::SENS() {
  return getToken(SPECTREParser::SENS, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::MONTECARLO() {
  return getToken(SPECTREParser::MONTECARLO, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::NOISE() {
  return getToken(SPECTREParser::NOISE, 0);
}

tree::TerminalNode* SPECTREParser::Analysis_typeContext::CHECKLIMIT() {
  return getToken(SPECTREParser::CHECKLIMIT, 0);
}


size_t SPECTREParser::Analysis_typeContext::getRuleIndex() const {
  return SPECTREParser::RuleAnalysis_type;
}

void SPECTREParser::Analysis_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalysis_type(this);
}

void SPECTREParser::Analysis_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalysis_type(this);
}


std::any SPECTREParser::Analysis_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitAnalysis_type(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Analysis_typeContext* SPECTREParser::analysis_type() {
  Analysis_typeContext *_localctx = _tracker.createInstance<Analysis_typeContext>(_ctx, getState());
  enterRule(_localctx, 256, SPECTREParser::RuleAnalysis_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1882);
    _la = _input->LA(1);
    if (!(((((_la - 51) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 51)) & 134217727) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_typeContext ------------------------------------------------------------------

SPECTREParser::Component_typeContext::Component_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SPECTREParser::Component_typeContext::A2D() {
  return getToken(SPECTREParser::A2D, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::B3SOIPD() {
  return getToken(SPECTREParser::B3SOIPD, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BJT() {
  return getToken(SPECTREParser::BJT, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BJT301() {
  return getToken(SPECTREParser::BJT301, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BJT500() {
  return getToken(SPECTREParser::BJT500, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BJT503() {
  return getToken(SPECTREParser::BJT503, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BJT504() {
  return getToken(SPECTREParser::BJT504, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BJT504T() {
  return getToken(SPECTREParser::BJT504T, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BSIM1() {
  return getToken(SPECTREParser::BSIM1, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BSIM2() {
  return getToken(SPECTREParser::BSIM2, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BSIM3() {
  return getToken(SPECTREParser::BSIM3, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BSIM3V3() {
  return getToken(SPECTREParser::BSIM3V3, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BSIM4() {
  return getToken(SPECTREParser::BSIM4, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BSIMSOI() {
  return getToken(SPECTREParser::BSIMSOI, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BTASOI() {
  return getToken(SPECTREParser::BTASOI, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::CAPACITOR() {
  return getToken(SPECTREParser::CAPACITOR, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::CCCS() {
  return getToken(SPECTREParser::CCCS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::CCVS() {
  return getToken(SPECTREParser::CCVS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::CKTROM() {
  return getToken(SPECTREParser::CKTROM, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::CORE() {
  return getToken(SPECTREParser::CORE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::D2A() {
  return getToken(SPECTREParser::D2A, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::DELAY() {
  return getToken(SPECTREParser::DELAY, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::DIO500() {
  return getToken(SPECTREParser::DIO500, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::DIODE() {
  return getToken(SPECTREParser::DIODE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::EKV() {
  return getToken(SPECTREParser::EKV, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::FOURIER() {
  return getToken(SPECTREParser::FOURIER, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::GAAS() {
  return getToken(SPECTREParser::GAAS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::HBT() {
  return getToken(SPECTREParser::HBT, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::HISIM() {
  return getToken(SPECTREParser::HISIM, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::HVMOS() {
  return getToken(SPECTREParser::HVMOS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::INDUCTOR() {
  return getToken(SPECTREParser::INDUCTOR, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::INTCAP() {
  return getToken(SPECTREParser::INTCAP, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::IPROBE() {
  return getToken(SPECTREParser::IPROBE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::ISOURCE() {
  return getToken(SPECTREParser::ISOURCE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::JFET() {
  return getToken(SPECTREParser::JFET, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::JUNCAP() {
  return getToken(SPECTREParser::JUNCAP, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MISNAN() {
  return getToken(SPECTREParser::MISNAN, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS0() {
  return getToken(SPECTREParser::MOS0, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS1() {
  return getToken(SPECTREParser::MOS1, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS1000() {
  return getToken(SPECTREParser::MOS1000, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS1100() {
  return getToken(SPECTREParser::MOS1100, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS11010() {
  return getToken(SPECTREParser::MOS11010, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS11011() {
  return getToken(SPECTREParser::MOS11011, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS15() {
  return getToken(SPECTREParser::MOS15, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS2() {
  return getToken(SPECTREParser::MOS2, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS3() {
  return getToken(SPECTREParser::MOS3, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS30() {
  return getToken(SPECTREParser::MOS30, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS3002() {
  return getToken(SPECTREParser::MOS3002, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS3100() {
  return getToken(SPECTREParser::MOS3100, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS40() {
  return getToken(SPECTREParser::MOS40, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS705() {
  return getToken(SPECTREParser::MOS705, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS902() {
  return getToken(SPECTREParser::MOS902, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MOS903() {
  return getToken(SPECTREParser::MOS903, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MSLINE() {
  return getToken(SPECTREParser::MSLINE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MTLINE() {
  return getToken(SPECTREParser::MTLINE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::MUTUAL_INDUCTOR() {
  return getToken(SPECTREParser::MUTUAL_INDUCTOR, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::NODCAP() {
  return getToken(SPECTREParser::NODCAP, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::NODE() {
  return getToken(SPECTREParser::NODE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::NPORT() {
  return getToken(SPECTREParser::NPORT, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::PARAMTEST() {
  return getToken(SPECTREParser::PARAMTEST, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::PCCCS() {
  return getToken(SPECTREParser::PCCCS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::PCCVS() {
  return getToken(SPECTREParser::PCCVS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::PHY_RES() {
  return getToken(SPECTREParser::PHY_RES, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::PORT() {
  return getToken(SPECTREParser::PORT, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::PSITFT() {
  return getToken(SPECTREParser::PSITFT, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::PVCCS() {
  return getToken(SPECTREParser::PVCCS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::PVCVS() {
  return getToken(SPECTREParser::PVCVS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::QUANTITY() {
  return getToken(SPECTREParser::QUANTITY, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::RDIFF() {
  return getToken(SPECTREParser::RDIFF, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::RELAY() {
  return getToken(SPECTREParser::RELAY, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::RESISTOR() {
  return getToken(SPECTREParser::RESISTOR, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::SCCCS() {
  return getToken(SPECTREParser::SCCCS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::SCCVS() {
  return getToken(SPECTREParser::SCCVS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::SVCCS() {
  return getToken(SPECTREParser::SVCCS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::SVCVS() {
  return getToken(SPECTREParser::SVCVS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::SWITCH() {
  return getToken(SPECTREParser::SWITCH, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::TLINE() {
  return getToken(SPECTREParser::TLINE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::TOM2() {
  return getToken(SPECTREParser::TOM2, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::TOM3() {
  return getToken(SPECTREParser::TOM3, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::TRANSFORMER() {
  return getToken(SPECTREParser::TRANSFORMER, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::VBIC() {
  return getToken(SPECTREParser::VBIC, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::VCCS() {
  return getToken(SPECTREParser::VCCS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::VCVS() {
  return getToken(SPECTREParser::VCVS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::VSOURCE() {
  return getToken(SPECTREParser::VSOURCE, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::WINDING() {
  return getToken(SPECTREParser::WINDING, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::ZCCCS() {
  return getToken(SPECTREParser::ZCCCS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::ZCCVS() {
  return getToken(SPECTREParser::ZCCVS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::ZVCCS() {
  return getToken(SPECTREParser::ZVCCS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::ZVCVS() {
  return getToken(SPECTREParser::ZVCVS, 0);
}

tree::TerminalNode* SPECTREParser::Component_typeContext::BSOURCE() {
  return getToken(SPECTREParser::BSOURCE, 0);
}


size_t SPECTREParser::Component_typeContext::getRuleIndex() const {
  return SPECTREParser::RuleComponent_type;
}

void SPECTREParser::Component_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_type(this);
}

void SPECTREParser::Component_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SPECTREParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_type(this);
}


std::any SPECTREParser::Component_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SPECTREParserVisitor*>(visitor))
    return parserVisitor->visitComponent_type(this);
  else
    return visitor->visitChildren(this);
}

SPECTREParser::Component_typeContext* SPECTREParser::component_type() {
  Component_typeContext *_localctx = _tracker.createInstance<Component_typeContext>(_ctx, getState());
  enterRule(_localctx, 258, SPECTREParser::RuleComponent_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1884);
    _la = _input->LA(1);
    if (!(((((_la - 78) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 78)) & -1) != 0) || ((((_la - 142) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 142)) & 67108863) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool SPECTREParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 109: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool SPECTREParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);
    case 1: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

void SPECTREParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  spectreparserParserInitialize();
#else
  ::antlr4::internal::call_once(spectreparserParserOnceFlag, spectreparserParserInitialize);
#endif
}
