
// Generated from g4files/ELDOParser.g4 by ANTLR 4.13.2


#include "ELDOParserListener.h"
#include "ELDOParserVisitor.h"

#include "ELDOParser.h"


using namespace antlrcpp;
using namespace edacurry;

using namespace antlr4;

namespace {

struct ELDOParserStaticData final {
  ELDOParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  ELDOParserStaticData(const ELDOParserStaticData&) = delete;
  ELDOParserStaticData(ELDOParserStaticData&&) = delete;
  ELDOParserStaticData& operator=(const ELDOParserStaticData&) = delete;
  ELDOParserStaticData& operator=(ELDOParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag eldoparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<ELDOParserStaticData> eldoparserParserStaticData = nullptr;

void eldoparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (eldoparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(eldoparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<ELDOParserStaticData>(
    std::vector<std::string>{
      "netlist", "netlist_title", "netlist_entity", "include", "standard_include", 
      "verilog_include", "dspf_include", "library", "library_key", "library_path", 
      "library_name", "library_def", "library_def_header", "library_def_content", 
      "library_def_footer", "subckt", "subckt_header", "subckt_content", 
      "subckt_footer", "analysis", "ac", "ac_parameter_driven", "ac_data_driven", 
      "ac_list_driven", "ac_adaptive", "age", "checksoa", "dc", "dc_component_analysis", 
      "dc_source_analysis", "dc_temperature_analysis", "dc_parameter_analysis", 
      "dc_data_driven_analysis", "dchiz", "dcmismatch", "dex", "dsp", "dspmod", 
      "four", "lstb", "mc", "noise", "noisetran", "op", "op_selective", 
      "op_time_based", "op_dc_based", "optfour", "optimize", "optnoise", 
      "pz", "ramp", "sens", "sensac", "sensparam", "snf", "solve", "solve_parameter", 
      "solve_object", "solve_component", "tf", "tran", "tran_point_driven", 
      "tran_parameterized", "tran_data_driven", "wcase", "extract", "global", 
      "model", "model_lib", "model_name", "model_master", "model_lib_type", 
      "control", "alter", "alter_definition", "alter_header", "alter_content", 
      "alter_footer", "save", "save_file", "save_when", "option", "nodeset", 
      "call_tcl", "call_tcl_when", "use_tcl", "defmac", "chrent", "chrent_behaviour", 
      "chrent_point", "chrent_pair", "ic", "ic_content", "ic_subckt", "print", 
      "plot", "ffile", "ffile_tabulation", "ffile_singleline", "ffile_unit", 
      "ffile_storage_format", "probe", "defwave", "temp", "meas", "meas_info", 
      "meas_vect", "meas_catvect", "meas_label_name", "meas_configuration", 
      "meas_find", "meas_at", "meas_when", "meas_derivative", "meas_param", 
      "meas_trig", "meas_targ", "connect", "global_declarations", "component", 
      "component_type", "component_attribute", "component_value", "component_parameter_list", 
      "component_analysis", "component_positional_keywork", "component_pin_list", 
      "component_port_list", "component_net_list", "component_coupling_list", 
      "component_table", "component_value_list", "interp_type", "resistor", 
      "capacitor", "inductor", "coupled_inductor", "diffusion_resistor", 
      "transmission_line", "lossy_transmission_line", "ltl_w_model", "ltl_u_model", 
      "junction_diode", "bjt", "jfet", "mosfet", "subckt_instance", "ivsource", 
      "icsource", "vcvs", "cccs", "vccs", "ccvs", "noise_function", "sw", 
      "operational_amplifier", "two_input_gate", "end", "expression", "expression_unary", 
      "expression_function_call", "expression_list", "expression_operator", 
      "expression_atom", "node_list", "node_list_item", "node_mapping", 
      "node", "parameter_list", "parameter_list_item", "parameter", "parameter_lhs", 
      "parameter_rhs", "filepath", "filepath_element", "end_of_line"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'='", 
      "'!'", "'<'", "'>'", "", "", "", "", "", "", "", "", "", "", "", "", 
      "'and'", "'or'", "':'", "';'", "'+'", "'-'", "'*'", "'('", "')'", 
      "'['", "']'", "'{'", "'}'", "'\\u003F'", "','", "'$'", "'&'", "'.'", 
      "'_'", "'@'", "'#'", "'\\'", "'/'", "'''", "'\"'", "'|'", "'%'", "'^'", 
      "'~'"
    },
    std::vector<std::string>{
      "", "COMMENT", "INCLUDE", "DSPF_INCLUDE", "LIB", "LIB_END", "SUBCKT", 
      "SUBCKT_END", "NETLIST_END", "GLOBAL", "MODEL_DEF", "VERILOG", "GLOBAL_PARAM", 
      "ALTER", "SAVE", "OPTION", "OPT", "NODESET", "CALL_TCL", "CHRENT", 
      "CONNECT", "DEFMAC", "DEFWAVE", "FFILE", "IC", "MEAS", "PLOT", "PRINT", 
      "PROBE", "TEMP_SET", "USE_TCL", "PARAM", "TEMP", "KEY", "NONOISE", 
      "TABLE", "PWL", "EXP", "SIN", "SFFM", "PULSE", "INTERP", "MOD", "MODEL", 
      "WHEN", "FIND", "PP", "TRIG", "TARG", "AT", "DERIVATIVE", "VECT", 
      "CATVECT", "PARAM_LIST_START", "PIN_LIST_START", "NET_LIST_START", 
      "PORT_LIST_START", "COUPLING_LIST_START", "GENERIC_LIST_START", "AC", 
      "AGE", "CHECKSOA", "DC", "DCHIZ", "DCMISMATCH", "DEX", "DSP", "DSPMOD", 
      "FOUR", "LSTB", "MC", "NOISE", "NOISETRAN", "OP", "OPTFOUR", "OPTIMIZE", 
      "OPTNOISE", "PZ", "RAMP", "SENS", "SENSAC", "SENSPARAM", "SNF", "SOLVE", 
      "TF", "TRAN", "WCASE", "EXTRACT", "RESISTOR", "CAPACITOR", "INDUCTOR", 
      "COUPLED_INDUCTOR", "DIFFUSION_RESISTOR", "TRANSMISSION_LINE", "LOSSY_TRANSMISSION_LINE", 
      "LTL_W_MODEL", "LTL_U_MODEL", "JUNCTION_DIODE", "BJT", "JFET", "MOSFET", 
      "S_DOMAIN_FILTER", "Z_DOMAIN_FILTER", "SUBCK_INSTANCE", "IVSOURCE", 
      "ICSOURCE", "VCVS", "CCCS", "VCCS", "CCVS", "OPA", "SW", "NOISE_FUNCTION", 
      "DIG_NAND", "DIG_AND", "DIG_NOR", "DIG_OR", "DIG_XOR", "EQUAL", "EXCLAMATION_MARK", 
      "LESS_THAN", "GREATER_THAN", "LESS_THAN_EQUAL", "GREATER_THAN_EQUAL", 
      "LOGIC_EQUAL", "LOGIC_NOT_EQUAL", "LOGIC_AND", "LOGIC_OR", "LOGIC_BITWISE_AND", 
      "LOGIC_BITWISE_OR", "LOGIC_XOR", "BITWISE_SHIFT_LEFT", "BITWISE_SHIFT_RIGHT", 
      "POWER_OPERATOR", "AND", "OR", "COLON", "SEMICOLON", "PLUS", "MINUS", 
      "STAR", "OPEN_ROUND", "CLOSE_ROUND", "OPEN_SQUARE", "CLOSE_SQUARE", 
      "OPEN_CURLY", "CLOSE_CURLY", "QUESTION_MARK", "COMMA", "DOLLAR", "AMPERSAND", 
      "DOT", "UNDERSCORE", "AT_SIGN", "POUND_SIGN", "BACKSLASH", "SLASH", 
      "APEX", "QUOTES", "PIPE", "PERCENT", "CARET", "TILDE", "ARROW", "PERCENTAGE", 
      "COMPLEX", "NUMBER", "ID", "STRING", "NL", "WS", "CNL"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,171,1583,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,1,0,3,0,356,8,0,1,0,1,0,5,0,360,8,0,10,0,12,0,363,9,0,1,0,3,0,366,
  	8,0,1,0,1,0,1,1,4,1,371,8,1,11,1,12,1,372,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
  	1,2,1,2,1,2,3,2,385,8,2,1,3,1,3,1,3,3,3,390,8,3,1,4,1,4,1,4,1,4,1,5,1,
  	5,1,5,1,5,1,6,1,6,1,6,3,6,403,8,6,1,6,1,6,3,6,407,8,6,1,6,1,6,1,7,1,7,
  	3,7,413,8,7,1,7,1,7,3,7,417,8,7,1,7,1,7,1,8,1,8,1,8,1,8,1,9,1,9,1,10,
  	1,10,1,11,1,11,4,11,431,8,11,11,11,12,11,432,1,11,1,11,1,11,1,12,1,12,
  	1,12,1,12,1,13,1,13,1,14,1,14,3,14,446,8,14,1,15,1,15,4,15,450,8,15,11,
  	15,12,15,451,1,15,1,15,1,16,1,16,1,16,3,16,459,8,16,1,16,3,16,462,8,16,
  	1,16,3,16,465,8,16,1,16,1,16,1,17,1,17,1,18,1,18,3,18,473,8,18,1,18,1,
  	18,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,
  	19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,
  	19,1,19,3,19,506,8,19,1,20,1,20,1,20,1,20,1,20,3,20,513,8,20,1,20,1,20,
  	1,21,1,21,1,21,1,21,1,21,3,21,522,8,21,1,22,1,22,3,22,526,8,22,1,23,1,
  	23,3,23,530,8,23,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,
  	26,1,26,1,26,1,27,1,27,1,27,1,27,1,27,1,27,3,27,551,8,27,1,27,1,27,1,
  	28,1,28,3,28,557,8,28,1,28,3,28,560,8,28,1,28,1,28,1,28,1,28,3,28,566,
  	8,28,1,29,1,29,3,29,570,8,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,
  	579,8,29,1,29,3,29,582,8,29,1,30,1,30,1,30,1,30,1,30,3,30,589,8,30,1,
  	31,1,31,1,31,3,31,594,8,31,1,31,1,31,1,31,1,31,3,31,600,8,31,1,32,1,32,
  	3,32,604,8,32,1,33,1,33,1,33,1,33,1,34,1,34,3,34,612,8,34,1,34,1,34,1,
  	35,1,35,1,35,1,35,3,35,620,8,35,1,35,1,35,1,36,1,36,1,36,3,36,627,8,36,
  	1,36,3,36,630,8,36,1,36,1,36,3,36,634,8,36,1,36,1,36,1,37,1,37,1,37,1,
  	37,3,37,642,8,37,1,37,1,37,1,38,1,38,1,38,1,38,3,38,650,8,38,1,38,1,38,
  	1,39,1,39,1,39,1,39,1,40,1,40,1,40,3,40,661,8,40,1,40,1,40,1,41,1,41,
  	1,41,1,41,1,41,1,41,1,42,1,42,1,42,1,42,1,42,3,42,676,8,42,1,42,1,42,
  	1,43,1,43,1,43,1,43,3,43,684,8,43,1,43,1,43,1,44,3,44,689,8,44,1,44,5,
  	44,692,8,44,10,44,12,44,695,9,44,1,45,1,45,3,45,699,8,45,1,45,3,45,702,
  	8,45,1,46,1,46,3,46,706,8,46,1,46,3,46,709,8,46,1,46,3,46,712,8,46,1,
  	47,1,47,3,47,716,8,47,1,47,1,47,1,48,1,48,3,48,722,8,48,1,48,1,48,1,49,
  	1,49,3,49,728,8,49,1,49,1,49,1,50,1,50,1,50,1,50,1,51,1,51,1,51,1,51,
  	3,51,740,8,51,1,51,3,51,743,8,51,1,51,1,51,1,52,1,52,1,52,1,52,1,53,1,
  	53,1,53,1,53,1,54,1,54,1,54,1,54,3,54,759,8,54,1,54,1,54,1,55,1,55,1,
  	55,1,55,3,55,767,8,55,1,55,1,55,1,56,1,56,1,56,1,56,3,56,775,8,56,1,56,
  	1,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,58,1,58,1,58,3,58,789,8,58,
  	1,58,1,58,1,58,1,58,1,58,1,59,1,59,1,59,3,59,799,8,59,1,59,1,59,1,59,
  	1,59,1,59,1,60,1,60,1,60,1,60,1,60,1,61,1,61,1,61,1,61,3,61,815,8,61,
  	1,61,1,61,1,62,1,62,1,62,1,62,3,62,823,8,62,3,62,825,8,62,1,62,3,62,828,
  	8,62,1,63,1,63,1,63,4,63,833,8,63,11,63,12,63,834,1,63,3,63,838,8,63,
  	1,64,1,64,1,65,1,65,1,65,3,65,845,8,65,1,65,1,65,1,66,1,66,3,66,851,8,
  	66,1,66,1,66,1,67,1,67,3,67,857,8,67,1,67,1,67,1,68,1,68,1,68,3,68,864,
  	8,68,1,68,3,68,867,8,68,1,68,3,68,870,8,68,1,68,1,68,1,68,1,68,1,68,1,
  	68,1,68,3,68,879,8,68,1,68,1,68,3,68,883,8,68,1,69,1,69,1,70,1,70,1,71,
  	1,71,1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,3,73,910,8,73,1,74,4,74,913,8,74,11,74,
  	12,74,914,1,74,1,74,1,74,1,75,1,75,4,75,922,8,75,11,75,12,75,923,1,76,
  	1,76,5,76,928,8,76,10,76,12,76,931,9,76,1,76,1,76,1,77,1,77,1,78,1,78,
  	1,79,1,79,3,79,941,8,79,1,79,1,79,3,79,945,8,79,1,79,1,79,1,80,1,80,3,
  	80,951,8,80,1,80,1,80,1,81,1,81,3,81,957,8,81,1,82,1,82,1,82,1,82,1,83,
  	1,83,1,83,1,83,1,84,1,84,3,84,969,8,84,1,84,3,84,972,8,84,1,84,3,84,975,
  	8,84,1,84,3,84,978,8,84,1,84,3,84,981,8,84,1,84,1,84,1,85,1,85,1,85,1,
  	85,1,86,1,86,1,86,1,86,1,87,1,87,1,87,1,87,1,88,1,88,1,88,1,88,3,88,1001,
  	8,88,1,88,1,88,1,89,4,89,1006,8,89,11,89,12,89,1007,1,90,4,90,1011,8,
  	90,11,90,12,90,1012,1,90,3,90,1016,8,90,1,91,1,91,1,91,1,92,1,92,4,92,
  	1023,8,92,11,92,12,92,1024,1,92,1,92,1,93,1,93,3,93,1031,8,93,1,94,1,
  	94,1,94,1,94,1,95,1,95,3,95,1039,8,95,1,95,1,95,1,95,1,96,1,96,3,96,1046,
  	8,96,1,96,1,96,1,96,1,97,1,97,1,97,3,97,1054,8,97,1,97,1,97,3,97,1058,
  	8,97,1,97,3,97,1061,8,97,1,97,1,97,1,98,1,98,1,99,1,99,1,100,1,100,1,
  	101,1,101,1,102,1,102,3,102,1075,8,102,1,102,3,102,1078,8,102,1,102,1,
  	102,1,103,1,103,3,103,1084,8,103,1,103,3,103,1087,8,103,1,103,1,103,1,
  	103,1,104,1,104,4,104,1094,8,104,11,104,12,104,1095,1,104,1,104,1,105,
  	1,105,3,105,1102,8,105,1,105,3,105,1105,8,105,1,105,3,105,1108,8,105,
  	1,105,1,105,4,105,1112,8,105,11,105,12,105,1113,1,105,3,105,1117,8,105,
  	1,105,1,105,1,106,1,106,1,107,1,107,1,108,1,108,1,109,1,109,1,110,1,110,
  	1,110,1,110,1,110,1,110,1,110,1,110,3,110,1137,8,110,1,111,1,111,1,111,
  	1,112,1,112,3,112,1144,8,112,1,112,1,112,1,113,1,113,1,113,1,114,1,114,
  	1,114,1,115,1,115,3,115,1156,8,115,1,115,1,115,1,116,1,116,1,116,1,117,
  	1,117,1,117,1,118,1,118,1,118,1,118,1,118,1,119,1,119,1,119,1,119,1,120,
  	1,120,5,120,1177,8,120,10,120,12,120,1180,9,120,1,120,1,120,1,121,1,121,
  	1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,
  	1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,3,121,1208,
  	8,121,1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,
  	3,122,1221,8,122,1,123,1,123,1,123,3,123,1226,8,123,1,123,1,123,1,123,
  	3,123,1231,8,123,3,123,1233,8,123,1,124,1,124,1,124,3,124,1238,8,124,
  	1,124,3,124,1241,8,124,1,125,1,125,1,125,3,125,1246,8,125,1,125,1,125,
  	1,125,3,125,1251,8,125,3,125,1253,8,125,1,126,1,126,1,127,1,127,1,127,
  	1,128,1,128,1,128,1,129,1,129,1,129,1,130,1,130,4,130,1268,8,130,11,130,
  	12,130,1269,1,131,1,131,1,131,1,131,4,131,1276,8,131,11,131,12,131,1277,
  	1,132,1,132,1,132,1,132,3,132,1284,8,132,4,132,1286,8,132,11,132,12,132,
  	1287,1,132,1,132,1,133,1,133,1,133,1,133,1,134,1,134,1,134,1,134,3,134,
  	1300,8,134,1,135,1,135,1,135,1,135,3,135,1306,8,135,1,136,1,136,1,136,
  	1,136,1,137,1,137,1,137,1,137,1,138,1,138,1,138,1,138,3,138,1320,8,138,
  	1,138,1,138,1,139,1,139,1,139,1,139,1,139,1,139,1,140,1,140,1,141,1,141,
  	1,142,1,142,1,143,1,143,1,143,1,143,1,144,1,144,1,144,1,144,1,144,1,145,
  	1,145,1,145,1,145,1,145,1,145,1,146,1,146,1,146,1,146,3,146,1355,8,146,
  	1,146,1,146,1,147,1,147,1,147,1,147,1,147,1,147,1,147,3,147,1366,8,147,
  	1,147,3,147,1369,8,147,1,148,1,148,1,148,1,148,1,149,1,149,1,149,1,149,
  	1,150,1,150,1,150,1,150,1,151,1,151,1,151,1,151,1,152,1,152,1,152,1,152,
  	1,153,1,153,1,153,1,153,1,154,1,154,1,155,1,155,1,155,1,155,1,155,3,155,
  	1402,8,155,1,155,1,155,3,155,1406,8,155,3,155,1408,8,155,1,156,1,156,
  	1,156,1,156,1,156,1,156,3,156,1416,8,156,1,157,1,157,1,157,1,157,1,157,
  	1,157,3,157,1424,8,157,1,157,3,157,1427,8,157,1,157,1,157,1,158,1,158,
  	1,158,1,159,1,159,1,159,1,159,1,159,3,159,1439,8,159,1,159,1,159,1,159,
  	1,159,1,159,1,159,1,159,1,159,1,159,1,159,1,159,1,159,1,159,1,159,3,159,
  	1455,8,159,5,159,1457,8,159,10,159,12,159,1460,9,159,1,160,1,160,1,160,
  	1,161,1,161,1,161,1,161,3,161,1469,8,161,4,161,1471,8,161,11,161,12,161,
  	1472,1,161,1,161,1,162,1,162,1,162,3,162,1480,8,162,4,162,1482,8,162,
  	11,162,12,162,1483,1,162,1,162,1,163,1,163,1,164,1,164,1,165,1,165,3,
  	165,1494,8,165,4,165,1496,8,165,11,165,12,165,1497,1,165,1,165,1,165,
  	3,165,1503,8,165,4,165,1505,8,165,11,165,12,165,1506,1,165,1,165,3,165,
  	1511,8,165,1,166,1,166,3,166,1515,8,166,1,167,1,167,1,167,1,167,1,168,
  	1,168,1,168,3,168,1524,8,168,1,169,3,169,1527,8,169,1,169,3,169,1530,
  	8,169,1,169,4,169,1533,8,169,11,169,12,169,1534,1,169,3,169,1538,8,169,
  	1,170,1,170,1,171,1,171,3,171,1544,8,171,1,172,1,172,1,172,3,172,1549,
  	8,172,1,173,1,173,1,173,1,174,1,174,1,175,1,175,1,175,1,175,1,175,1,175,
  	1,175,1,175,1,175,1,175,1,175,1,175,1,175,1,175,1,175,1,175,3,175,1572,
  	8,175,1,176,5,176,1575,8,176,10,176,12,176,1578,9,176,1,176,3,176,1581,
  	8,176,1,176,0,1,318,177,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,
  	34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,
  	80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,
  	120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,
  	156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,
  	192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,
  	228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,
  	264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,
  	300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,
  	336,338,340,342,344,346,348,350,352,0,13,1,0,15,16,2,0,53,53,58,58,2,
  	0,59,59,62,62,1,0,36,40,1,0,42,43,1,0,113,117,1,0,138,139,2,0,42,43,167,
  	167,3,0,141,141,143,143,145,145,3,0,142,142,144,144,146,146,4,0,118,133,
  	138,140,156,156,160,161,2,0,164,164,166,168,1,0,166,167,1673,0,355,1,
  	0,0,0,2,370,1,0,0,0,4,384,1,0,0,0,6,389,1,0,0,0,8,391,1,0,0,0,10,395,
  	1,0,0,0,12,399,1,0,0,0,14,410,1,0,0,0,16,420,1,0,0,0,18,424,1,0,0,0,20,
  	426,1,0,0,0,22,428,1,0,0,0,24,437,1,0,0,0,26,441,1,0,0,0,28,443,1,0,0,
  	0,30,447,1,0,0,0,32,455,1,0,0,0,34,468,1,0,0,0,36,470,1,0,0,0,38,505,
  	1,0,0,0,40,507,1,0,0,0,42,516,1,0,0,0,44,523,1,0,0,0,46,527,1,0,0,0,48,
  	531,1,0,0,0,50,536,1,0,0,0,52,540,1,0,0,0,54,544,1,0,0,0,56,554,1,0,0,
  	0,58,567,1,0,0,0,60,583,1,0,0,0,62,590,1,0,0,0,64,601,1,0,0,0,66,605,
  	1,0,0,0,68,609,1,0,0,0,70,615,1,0,0,0,72,623,1,0,0,0,74,637,1,0,0,0,76,
  	645,1,0,0,0,78,653,1,0,0,0,80,657,1,0,0,0,82,664,1,0,0,0,84,670,1,0,0,
  	0,86,679,1,0,0,0,88,693,1,0,0,0,90,696,1,0,0,0,92,703,1,0,0,0,94,713,
  	1,0,0,0,96,719,1,0,0,0,98,725,1,0,0,0,100,731,1,0,0,0,102,735,1,0,0,0,
  	104,746,1,0,0,0,106,750,1,0,0,0,108,754,1,0,0,0,110,762,1,0,0,0,112,770,
  	1,0,0,0,114,778,1,0,0,0,116,785,1,0,0,0,118,795,1,0,0,0,120,805,1,0,0,
  	0,122,810,1,0,0,0,124,818,1,0,0,0,126,832,1,0,0,0,128,839,1,0,0,0,130,
  	841,1,0,0,0,132,848,1,0,0,0,134,854,1,0,0,0,136,882,1,0,0,0,138,884,1,
  	0,0,0,140,886,1,0,0,0,142,888,1,0,0,0,144,890,1,0,0,0,146,909,1,0,0,0,
  	148,912,1,0,0,0,150,919,1,0,0,0,152,925,1,0,0,0,154,934,1,0,0,0,156,936,
  	1,0,0,0,158,938,1,0,0,0,160,950,1,0,0,0,162,956,1,0,0,0,164,958,1,0,0,
  	0,166,962,1,0,0,0,168,966,1,0,0,0,170,984,1,0,0,0,172,988,1,0,0,0,174,
  	992,1,0,0,0,176,996,1,0,0,0,178,1005,1,0,0,0,180,1010,1,0,0,0,182,1017,
  	1,0,0,0,184,1020,1,0,0,0,186,1028,1,0,0,0,188,1032,1,0,0,0,190,1036,1,
  	0,0,0,192,1043,1,0,0,0,194,1050,1,0,0,0,196,1064,1,0,0,0,198,1066,1,0,
  	0,0,200,1068,1,0,0,0,202,1070,1,0,0,0,204,1072,1,0,0,0,206,1081,1,0,0,
  	0,208,1091,1,0,0,0,210,1099,1,0,0,0,212,1120,1,0,0,0,214,1122,1,0,0,0,
  	216,1124,1,0,0,0,218,1126,1,0,0,0,220,1136,1,0,0,0,222,1138,1,0,0,0,224,
  	1141,1,0,0,0,226,1147,1,0,0,0,228,1150,1,0,0,0,230,1153,1,0,0,0,232,1159,
  	1,0,0,0,234,1162,1,0,0,0,236,1165,1,0,0,0,238,1170,1,0,0,0,240,1174,1,
  	0,0,0,242,1207,1,0,0,0,244,1220,1,0,0,0,246,1232,1,0,0,0,248,1240,1,0,
  	0,0,250,1252,1,0,0,0,252,1254,1,0,0,0,254,1256,1,0,0,0,256,1259,1,0,0,
  	0,258,1262,1,0,0,0,260,1265,1,0,0,0,262,1271,1,0,0,0,264,1279,1,0,0,0,
  	266,1291,1,0,0,0,268,1295,1,0,0,0,270,1301,1,0,0,0,272,1307,1,0,0,0,274,
  	1311,1,0,0,0,276,1315,1,0,0,0,278,1323,1,0,0,0,280,1329,1,0,0,0,282,1331,
  	1,0,0,0,284,1333,1,0,0,0,286,1335,1,0,0,0,288,1339,1,0,0,0,290,1344,1,
  	0,0,0,292,1350,1,0,0,0,294,1368,1,0,0,0,296,1370,1,0,0,0,298,1374,1,0,
  	0,0,300,1378,1,0,0,0,302,1382,1,0,0,0,304,1386,1,0,0,0,306,1390,1,0,0,
  	0,308,1394,1,0,0,0,310,1396,1,0,0,0,312,1409,1,0,0,0,314,1417,1,0,0,0,
  	316,1430,1,0,0,0,318,1438,1,0,0,0,320,1461,1,0,0,0,322,1464,1,0,0,0,324,
  	1476,1,0,0,0,326,1487,1,0,0,0,328,1489,1,0,0,0,330,1510,1,0,0,0,332,1514,
  	1,0,0,0,334,1516,1,0,0,0,336,1520,1,0,0,0,338,1526,1,0,0,0,340,1539,1,
  	0,0,0,342,1541,1,0,0,0,344,1548,1,0,0,0,346,1550,1,0,0,0,348,1553,1,0,
  	0,0,350,1571,1,0,0,0,352,1580,1,0,0,0,354,356,3,2,1,0,355,354,1,0,0,0,
  	355,356,1,0,0,0,356,357,1,0,0,0,357,361,3,352,176,0,358,360,3,4,2,0,359,
  	358,1,0,0,0,360,363,1,0,0,0,361,359,1,0,0,0,361,362,1,0,0,0,362,365,1,
  	0,0,0,363,361,1,0,0,0,364,366,3,316,158,0,365,364,1,0,0,0,365,366,1,0,
  	0,0,366,367,1,0,0,0,367,368,3,352,176,0,368,1,1,0,0,0,369,371,5,167,0,
  	0,370,369,1,0,0,0,371,372,1,0,0,0,372,370,1,0,0,0,372,373,1,0,0,0,373,
  	3,1,0,0,0,374,385,3,6,3,0,375,385,3,14,7,0,376,385,3,22,11,0,377,385,
  	3,30,15,0,378,385,3,38,19,0,379,385,3,134,67,0,380,385,3,136,68,0,381,
  	385,3,238,119,0,382,385,3,146,73,0,383,385,3,240,120,0,384,374,1,0,0,
  	0,384,375,1,0,0,0,384,376,1,0,0,0,384,377,1,0,0,0,384,378,1,0,0,0,384,
  	379,1,0,0,0,384,380,1,0,0,0,384,381,1,0,0,0,384,382,1,0,0,0,384,383,1,
  	0,0,0,385,5,1,0,0,0,386,390,3,8,4,0,387,390,3,12,6,0,388,390,3,10,5,0,
  	389,386,1,0,0,0,389,387,1,0,0,0,389,388,1,0,0,0,390,7,1,0,0,0,391,392,
  	5,2,0,0,392,393,3,348,174,0,393,394,3,352,176,0,394,9,1,0,0,0,395,396,
  	5,11,0,0,396,397,3,348,174,0,397,398,3,352,176,0,398,11,1,0,0,0,399,402,
  	5,3,0,0,400,401,5,167,0,0,401,403,5,118,0,0,402,400,1,0,0,0,402,403,1,
  	0,0,0,403,404,1,0,0,0,404,406,3,348,174,0,405,407,3,338,169,0,406,405,
  	1,0,0,0,406,407,1,0,0,0,407,408,1,0,0,0,408,409,3,352,176,0,409,13,1,
  	0,0,0,410,412,5,4,0,0,411,413,3,16,8,0,412,411,1,0,0,0,412,413,1,0,0,
  	0,413,414,1,0,0,0,414,416,3,18,9,0,415,417,3,20,10,0,416,415,1,0,0,0,
  	416,417,1,0,0,0,417,418,1,0,0,0,418,419,3,352,176,0,419,15,1,0,0,0,420,
  	421,5,33,0,0,421,422,5,118,0,0,422,423,5,167,0,0,423,17,1,0,0,0,424,425,
  	3,348,174,0,425,19,1,0,0,0,426,427,5,167,0,0,427,21,1,0,0,0,428,430,3,
  	24,12,0,429,431,3,26,13,0,430,429,1,0,0,0,431,432,1,0,0,0,432,430,1,0,
  	0,0,432,433,1,0,0,0,433,434,1,0,0,0,434,435,3,28,14,0,435,436,3,352,176,
  	0,436,23,1,0,0,0,437,438,5,4,0,0,438,439,3,20,10,0,439,440,3,352,176,
  	0,440,25,1,0,0,0,441,442,3,4,2,0,442,27,1,0,0,0,443,445,5,5,0,0,444,446,
  	3,20,10,0,445,444,1,0,0,0,445,446,1,0,0,0,446,29,1,0,0,0,447,449,3,32,
  	16,0,448,450,3,34,17,0,449,448,1,0,0,0,450,451,1,0,0,0,451,449,1,0,0,
  	0,451,452,1,0,0,0,452,453,1,0,0,0,453,454,3,36,18,0,454,31,1,0,0,0,455,
  	456,5,6,0,0,456,458,5,167,0,0,457,459,3,330,165,0,458,457,1,0,0,0,458,
  	459,1,0,0,0,459,464,1,0,0,0,460,462,5,53,0,0,461,460,1,0,0,0,461,462,
  	1,0,0,0,462,463,1,0,0,0,463,465,3,338,169,0,464,461,1,0,0,0,464,465,1,
  	0,0,0,465,466,1,0,0,0,466,467,3,352,176,0,467,33,1,0,0,0,468,469,3,4,
  	2,0,469,35,1,0,0,0,470,472,5,7,0,0,471,473,5,167,0,0,472,471,1,0,0,0,
  	472,473,1,0,0,0,473,474,1,0,0,0,474,475,3,352,176,0,475,37,1,0,0,0,476,
  	506,3,40,20,0,477,506,3,50,25,0,478,506,3,52,26,0,479,506,3,54,27,0,480,
  	506,3,66,33,0,481,506,3,68,34,0,482,506,3,70,35,0,483,506,3,72,36,0,484,
  	506,3,74,37,0,485,506,3,76,38,0,486,506,3,78,39,0,487,506,3,80,40,0,488,
  	506,3,82,41,0,489,506,3,84,42,0,490,506,3,86,43,0,491,506,3,94,47,0,492,
  	506,3,96,48,0,493,506,3,98,49,0,494,506,3,100,50,0,495,506,3,102,51,0,
  	496,506,3,104,52,0,497,506,3,106,53,0,498,506,3,108,54,0,499,506,3,110,
  	55,0,500,506,3,112,56,0,501,506,3,120,60,0,502,506,3,122,61,0,503,506,
  	3,130,65,0,504,506,3,132,66,0,505,476,1,0,0,0,505,477,1,0,0,0,505,478,
  	1,0,0,0,505,479,1,0,0,0,505,480,1,0,0,0,505,481,1,0,0,0,505,482,1,0,0,
  	0,505,483,1,0,0,0,505,484,1,0,0,0,505,485,1,0,0,0,505,486,1,0,0,0,505,
  	487,1,0,0,0,505,488,1,0,0,0,505,489,1,0,0,0,505,490,1,0,0,0,505,491,1,
  	0,0,0,505,492,1,0,0,0,505,493,1,0,0,0,505,494,1,0,0,0,505,495,1,0,0,0,
  	505,496,1,0,0,0,505,497,1,0,0,0,505,498,1,0,0,0,505,499,1,0,0,0,505,500,
  	1,0,0,0,505,501,1,0,0,0,505,502,1,0,0,0,505,503,1,0,0,0,505,504,1,0,0,
  	0,506,39,1,0,0,0,507,512,5,59,0,0,508,513,3,42,21,0,509,513,3,44,22,0,
  	510,513,3,46,23,0,511,513,3,48,24,0,512,508,1,0,0,0,512,509,1,0,0,0,512,
  	510,1,0,0,0,512,511,1,0,0,0,513,514,1,0,0,0,514,515,3,352,176,0,515,41,
  	1,0,0,0,516,517,5,167,0,0,517,518,5,166,0,0,518,519,5,166,0,0,519,521,
  	5,166,0,0,520,522,3,338,169,0,521,520,1,0,0,0,521,522,1,0,0,0,522,43,
  	1,0,0,0,523,525,3,342,171,0,524,526,3,338,169,0,525,524,1,0,0,0,525,526,
  	1,0,0,0,526,45,1,0,0,0,527,529,5,167,0,0,528,530,3,338,169,0,529,528,
  	1,0,0,0,529,530,1,0,0,0,530,47,1,0,0,0,531,532,5,167,0,0,532,533,5,166,
  	0,0,533,534,5,166,0,0,534,535,5,166,0,0,535,49,1,0,0,0,536,537,5,60,0,
  	0,537,538,3,338,169,0,538,539,3,352,176,0,539,51,1,0,0,0,540,541,5,61,
  	0,0,541,542,3,338,169,0,542,543,3,352,176,0,543,53,1,0,0,0,544,550,5,
  	62,0,0,545,551,3,56,28,0,546,551,3,58,29,0,547,551,3,60,30,0,548,551,
  	3,62,31,0,549,551,3,64,32,0,550,545,1,0,0,0,550,546,1,0,0,0,550,547,1,
  	0,0,0,550,548,1,0,0,0,550,549,1,0,0,0,550,551,1,0,0,0,551,552,1,0,0,0,
  	552,553,3,352,176,0,553,55,1,0,0,0,554,556,5,167,0,0,555,557,5,167,0,
  	0,556,555,1,0,0,0,556,557,1,0,0,0,557,559,1,0,0,0,558,560,5,167,0,0,559,
  	558,1,0,0,0,559,560,1,0,0,0,560,561,1,0,0,0,561,562,5,166,0,0,562,563,
  	5,166,0,0,563,565,5,166,0,0,564,566,3,338,169,0,565,564,1,0,0,0,565,566,
  	1,0,0,0,566,57,1,0,0,0,567,569,5,167,0,0,568,570,5,167,0,0,569,568,1,
  	0,0,0,569,570,1,0,0,0,570,571,1,0,0,0,571,572,5,166,0,0,572,573,5,166,
  	0,0,573,578,5,166,0,0,574,575,5,167,0,0,575,576,5,166,0,0,576,577,5,166,
  	0,0,577,579,5,166,0,0,578,574,1,0,0,0,578,579,1,0,0,0,579,581,1,0,0,0,
  	580,582,3,338,169,0,581,580,1,0,0,0,581,582,1,0,0,0,582,59,1,0,0,0,583,
  	584,5,32,0,0,584,585,5,166,0,0,585,586,5,166,0,0,586,588,5,166,0,0,587,
  	589,3,338,169,0,588,587,1,0,0,0,588,589,1,0,0,0,589,61,1,0,0,0,590,591,
  	5,31,0,0,591,593,5,167,0,0,592,594,5,167,0,0,593,592,1,0,0,0,593,594,
  	1,0,0,0,594,595,1,0,0,0,595,596,5,166,0,0,596,597,5,166,0,0,597,599,5,
  	166,0,0,598,600,3,338,169,0,599,598,1,0,0,0,599,600,1,0,0,0,600,63,1,
  	0,0,0,601,603,3,342,171,0,602,604,3,338,169,0,603,602,1,0,0,0,603,604,
  	1,0,0,0,604,65,1,0,0,0,605,606,5,63,0,0,606,607,3,342,171,0,607,608,3,
  	352,176,0,608,67,1,0,0,0,609,611,5,64,0,0,610,612,3,338,169,0,611,610,
  	1,0,0,0,611,612,1,0,0,0,612,613,1,0,0,0,613,614,3,352,176,0,614,69,1,
  	0,0,0,615,616,5,65,0,0,616,617,3,342,171,0,617,619,3,342,171,0,618,620,
  	3,338,169,0,619,618,1,0,0,0,619,620,1,0,0,0,620,621,1,0,0,0,621,622,3,
  	352,176,0,622,71,1,0,0,0,623,624,5,66,0,0,624,626,3,342,171,0,625,627,
  	3,342,171,0,626,625,1,0,0,0,626,627,1,0,0,0,627,629,1,0,0,0,628,630,3,
  	342,171,0,629,628,1,0,0,0,629,630,1,0,0,0,630,631,1,0,0,0,631,633,5,167,
  	0,0,632,634,3,338,169,0,633,632,1,0,0,0,633,634,1,0,0,0,634,635,1,0,0,
  	0,635,636,3,352,176,0,636,73,1,0,0,0,637,638,5,67,0,0,638,639,3,342,171,
  	0,639,641,3,342,171,0,640,642,3,338,169,0,641,640,1,0,0,0,641,642,1,0,
  	0,0,642,643,1,0,0,0,643,644,3,352,176,0,644,75,1,0,0,0,645,646,5,68,0,
  	0,646,647,3,342,171,0,647,649,5,167,0,0,648,650,3,338,169,0,649,648,1,
  	0,0,0,649,650,1,0,0,0,650,651,1,0,0,0,651,652,3,352,176,0,652,77,1,0,
  	0,0,653,654,5,69,0,0,654,655,3,348,174,0,655,656,3,352,176,0,656,79,1,
  	0,0,0,657,658,5,70,0,0,658,660,5,166,0,0,659,661,3,338,169,0,660,659,
  	1,0,0,0,660,661,1,0,0,0,661,662,1,0,0,0,662,663,3,352,176,0,663,81,1,
  	0,0,0,664,665,5,71,0,0,665,666,3,342,171,0,666,667,3,342,171,0,667,668,
  	5,166,0,0,668,669,3,352,176,0,669,83,1,0,0,0,670,671,5,72,0,0,671,672,
  	3,342,171,0,672,673,3,342,171,0,673,675,3,342,171,0,674,676,3,338,169,
  	0,675,674,1,0,0,0,675,676,1,0,0,0,676,677,1,0,0,0,677,678,3,352,176,0,
  	678,85,1,0,0,0,679,683,5,73,0,0,680,684,3,88,44,0,681,684,3,90,45,0,682,
  	684,3,92,46,0,683,680,1,0,0,0,683,681,1,0,0,0,683,682,1,0,0,0,684,685,
  	1,0,0,0,685,686,3,352,176,0,686,87,1,0,0,0,687,689,5,167,0,0,688,687,
  	1,0,0,0,688,689,1,0,0,0,689,690,1,0,0,0,690,692,3,318,159,0,691,688,1,
  	0,0,0,692,695,1,0,0,0,693,691,1,0,0,0,693,694,1,0,0,0,694,89,1,0,0,0,
  	695,693,1,0,0,0,696,698,3,342,171,0,697,699,3,342,171,0,698,697,1,0,0,
  	0,698,699,1,0,0,0,699,701,1,0,0,0,700,702,3,342,171,0,701,700,1,0,0,0,
  	701,702,1,0,0,0,702,91,1,0,0,0,703,705,3,342,171,0,704,706,3,342,171,
  	0,705,704,1,0,0,0,705,706,1,0,0,0,706,708,1,0,0,0,707,709,3,342,171,0,
  	708,707,1,0,0,0,708,709,1,0,0,0,709,711,1,0,0,0,710,712,3,342,171,0,711,
  	710,1,0,0,0,711,712,1,0,0,0,712,93,1,0,0,0,713,715,5,74,0,0,714,716,3,
  	338,169,0,715,714,1,0,0,0,715,716,1,0,0,0,716,717,1,0,0,0,717,718,3,352,
  	176,0,718,95,1,0,0,0,719,721,5,75,0,0,720,722,3,338,169,0,721,720,1,0,
  	0,0,721,722,1,0,0,0,722,723,1,0,0,0,723,724,3,352,176,0,724,97,1,0,0,
  	0,725,727,5,76,0,0,726,728,3,338,169,0,727,726,1,0,0,0,727,728,1,0,0,
  	0,728,729,1,0,0,0,729,730,3,352,176,0,730,99,1,0,0,0,731,732,5,77,0,0,
  	732,733,3,348,174,0,733,734,3,352,176,0,734,101,1,0,0,0,735,736,5,78,
  	0,0,736,737,5,167,0,0,737,739,5,166,0,0,738,740,5,166,0,0,739,738,1,0,
  	0,0,739,740,1,0,0,0,740,742,1,0,0,0,741,743,5,167,0,0,742,741,1,0,0,0,
  	742,743,1,0,0,0,743,744,1,0,0,0,744,745,3,352,176,0,745,103,1,0,0,0,746,
  	747,5,79,0,0,747,748,3,338,169,0,748,749,3,352,176,0,749,105,1,0,0,0,
  	750,751,5,80,0,0,751,752,3,338,169,0,752,753,3,352,176,0,753,107,1,0,
  	0,0,754,755,5,81,0,0,755,756,3,342,171,0,756,758,3,342,171,0,757,759,
  	3,338,169,0,758,757,1,0,0,0,758,759,1,0,0,0,759,760,1,0,0,0,760,761,3,
  	352,176,0,761,109,1,0,0,0,762,763,5,82,0,0,763,764,3,342,171,0,764,766,
  	3,342,171,0,765,767,3,338,169,0,766,765,1,0,0,0,766,767,1,0,0,0,767,768,
  	1,0,0,0,768,769,3,352,176,0,769,111,1,0,0,0,770,774,5,83,0,0,771,775,
  	3,114,57,0,772,775,3,116,58,0,773,775,3,118,59,0,774,771,1,0,0,0,774,
  	772,1,0,0,0,774,773,1,0,0,0,775,776,1,0,0,0,776,777,3,352,176,0,777,113,
  	1,0,0,0,778,779,5,31,0,0,779,780,5,167,0,0,780,781,5,166,0,0,781,782,
  	5,166,0,0,782,783,3,338,169,0,783,784,3,352,176,0,784,115,1,0,0,0,785,
  	786,5,31,0,0,786,788,5,167,0,0,787,789,5,167,0,0,788,787,1,0,0,0,788,
  	789,1,0,0,0,789,790,1,0,0,0,790,791,5,166,0,0,791,792,5,166,0,0,792,793,
  	3,338,169,0,793,794,3,352,176,0,794,117,1,0,0,0,795,796,5,31,0,0,796,
  	798,5,167,0,0,797,799,5,167,0,0,798,797,1,0,0,0,798,799,1,0,0,0,799,800,
  	1,0,0,0,800,801,5,166,0,0,801,802,5,166,0,0,802,803,3,338,169,0,803,804,
  	3,352,176,0,804,119,1,0,0,0,805,806,5,84,0,0,806,807,3,342,171,0,807,
  	808,3,342,171,0,808,809,3,352,176,0,809,121,1,0,0,0,810,814,5,85,0,0,
  	811,815,3,124,62,0,812,815,3,126,63,0,813,815,3,128,64,0,814,811,1,0,
  	0,0,814,812,1,0,0,0,814,813,1,0,0,0,815,816,1,0,0,0,816,817,3,352,176,
  	0,817,123,1,0,0,0,818,819,5,166,0,0,819,824,5,166,0,0,820,822,5,166,0,
  	0,821,823,5,166,0,0,822,821,1,0,0,0,822,823,1,0,0,0,823,825,1,0,0,0,824,
  	820,1,0,0,0,824,825,1,0,0,0,825,827,1,0,0,0,826,828,3,338,169,0,827,826,
  	1,0,0,0,827,828,1,0,0,0,828,125,1,0,0,0,829,830,3,318,159,0,830,831,3,
  	318,159,0,831,833,1,0,0,0,832,829,1,0,0,0,833,834,1,0,0,0,834,832,1,0,
  	0,0,834,835,1,0,0,0,835,837,1,0,0,0,836,838,3,338,169,0,837,836,1,0,0,
  	0,837,838,1,0,0,0,838,127,1,0,0,0,839,840,3,338,169,0,840,129,1,0,0,0,
  	841,842,5,86,0,0,842,844,5,167,0,0,843,845,3,338,169,0,844,843,1,0,0,
  	0,844,845,1,0,0,0,845,846,1,0,0,0,846,847,3,352,176,0,847,131,1,0,0,0,
  	848,850,5,87,0,0,849,851,3,338,169,0,850,849,1,0,0,0,850,851,1,0,0,0,
  	851,852,1,0,0,0,852,853,3,352,176,0,853,133,1,0,0,0,854,856,5,9,0,0,855,
  	857,3,330,165,0,856,855,1,0,0,0,856,857,1,0,0,0,857,858,1,0,0,0,858,859,
  	3,352,176,0,859,135,1,0,0,0,860,861,5,10,0,0,861,863,3,140,70,0,862,864,
  	3,142,71,0,863,862,1,0,0,0,863,864,1,0,0,0,864,866,1,0,0,0,865,867,5,
  	34,0,0,866,865,1,0,0,0,866,867,1,0,0,0,867,869,1,0,0,0,868,870,3,338,
  	169,0,869,868,1,0,0,0,869,870,1,0,0,0,870,871,1,0,0,0,871,872,3,352,176,
  	0,872,883,1,0,0,0,873,874,5,10,0,0,874,875,3,138,69,0,875,876,3,348,174,
  	0,876,878,3,140,70,0,877,879,3,144,72,0,878,877,1,0,0,0,878,879,1,0,0,
  	0,879,880,1,0,0,0,880,881,3,352,176,0,881,883,1,0,0,0,882,860,1,0,0,0,
  	882,873,1,0,0,0,883,137,1,0,0,0,884,885,5,167,0,0,885,139,1,0,0,0,886,
  	887,5,167,0,0,887,141,1,0,0,0,888,889,5,167,0,0,889,143,1,0,0,0,890,891,
  	5,167,0,0,891,145,1,0,0,0,892,910,3,148,74,0,893,910,3,158,79,0,894,910,
  	3,164,82,0,895,910,3,166,83,0,896,910,3,168,84,0,897,910,3,172,86,0,898,
  	910,3,174,87,0,899,910,3,176,88,0,900,910,3,184,92,0,901,910,3,190,95,
  	0,902,910,3,192,96,0,903,910,3,194,97,0,904,910,3,204,102,0,905,910,3,
  	206,103,0,906,910,3,208,104,0,907,910,3,210,105,0,908,910,3,236,118,0,
  	909,892,1,0,0,0,909,893,1,0,0,0,909,894,1,0,0,0,909,895,1,0,0,0,909,896,
  	1,0,0,0,909,897,1,0,0,0,909,898,1,0,0,0,909,899,1,0,0,0,909,900,1,0,0,
  	0,909,901,1,0,0,0,909,902,1,0,0,0,909,903,1,0,0,0,909,904,1,0,0,0,909,
  	905,1,0,0,0,909,906,1,0,0,0,909,907,1,0,0,0,909,908,1,0,0,0,910,147,1,
  	0,0,0,911,913,3,150,75,0,912,911,1,0,0,0,913,914,1,0,0,0,914,912,1,0,
  	0,0,914,915,1,0,0,0,915,916,1,0,0,0,916,917,3,156,78,0,917,918,3,352,
  	176,0,918,149,1,0,0,0,919,921,3,152,76,0,920,922,3,154,77,0,921,920,1,
  	0,0,0,922,923,1,0,0,0,923,921,1,0,0,0,923,924,1,0,0,0,924,151,1,0,0,0,
  	925,929,5,13,0,0,926,928,5,167,0,0,927,926,1,0,0,0,928,931,1,0,0,0,929,
  	927,1,0,0,0,929,930,1,0,0,0,930,932,1,0,0,0,931,929,1,0,0,0,932,933,3,
  	352,176,0,933,153,1,0,0,0,934,935,3,4,2,0,935,155,1,0,0,0,936,937,5,8,
  	0,0,937,157,1,0,0,0,938,940,5,14,0,0,939,941,3,160,80,0,940,939,1,0,0,
  	0,940,941,1,0,0,0,941,942,1,0,0,0,942,944,3,162,81,0,943,945,3,338,169,
  	0,944,943,1,0,0,0,944,945,1,0,0,0,945,946,1,0,0,0,946,947,3,352,176,0,
  	947,159,1,0,0,0,948,949,5,167,0,0,949,951,5,118,0,0,950,948,1,0,0,0,950,
  	951,1,0,0,0,951,952,1,0,0,0,952,953,3,348,174,0,953,161,1,0,0,0,954,957,
  	5,167,0,0,955,957,3,342,171,0,956,954,1,0,0,0,956,955,1,0,0,0,957,163,
  	1,0,0,0,958,959,7,0,0,0,959,960,3,338,169,0,960,961,3,352,176,0,961,165,
  	1,0,0,0,962,963,5,17,0,0,963,964,3,338,169,0,964,965,3,352,176,0,965,
  	167,1,0,0,0,966,968,5,18,0,0,967,969,5,167,0,0,968,967,1,0,0,0,968,969,
  	1,0,0,0,969,971,1,0,0,0,970,972,3,170,85,0,971,970,1,0,0,0,971,972,1,
  	0,0,0,972,974,1,0,0,0,973,975,3,338,169,0,974,973,1,0,0,0,974,975,1,0,
  	0,0,975,977,1,0,0,0,976,978,3,318,159,0,977,976,1,0,0,0,977,978,1,0,0,
  	0,978,980,1,0,0,0,979,981,5,167,0,0,980,979,1,0,0,0,980,981,1,0,0,0,981,
  	982,1,0,0,0,982,983,3,352,176,0,983,169,1,0,0,0,984,985,5,44,0,0,985,
  	986,5,118,0,0,986,987,5,167,0,0,987,171,1,0,0,0,988,989,5,30,0,0,989,
  	990,3,348,174,0,990,991,3,352,176,0,991,173,1,0,0,0,992,993,5,21,0,0,
  	993,994,3,342,171,0,994,995,3,352,176,0,995,175,1,0,0,0,996,997,5,19,
  	0,0,997,998,3,336,168,0,998,1000,3,178,89,0,999,1001,5,167,0,0,1000,999,
  	1,0,0,0,1000,1001,1,0,0,0,1001,1002,1,0,0,0,1002,1003,3,352,176,0,1003,
  	177,1,0,0,0,1004,1006,3,180,90,0,1005,1004,1,0,0,0,1006,1007,1,0,0,0,
  	1007,1005,1,0,0,0,1007,1008,1,0,0,0,1008,179,1,0,0,0,1009,1011,3,182,
  	91,0,1010,1009,1,0,0,0,1011,1012,1,0,0,0,1012,1010,1,0,0,0,1012,1013,
  	1,0,0,0,1013,1015,1,0,0,0,1014,1016,5,166,0,0,1015,1014,1,0,0,0,1015,
  	1016,1,0,0,0,1016,181,1,0,0,0,1017,1018,5,166,0,0,1018,1019,5,166,0,0,
  	1019,183,1,0,0,0,1020,1022,5,24,0,0,1021,1023,3,186,93,0,1022,1021,1,
  	0,0,0,1023,1024,1,0,0,0,1024,1022,1,0,0,0,1024,1025,1,0,0,0,1025,1026,
  	1,0,0,0,1026,1027,3,352,176,0,1027,185,1,0,0,0,1028,1030,3,342,171,0,
  	1029,1031,3,188,94,0,1030,1029,1,0,0,0,1030,1031,1,0,0,0,1031,187,1,0,
  	0,0,1032,1033,5,6,0,0,1033,1034,5,118,0,0,1034,1035,5,167,0,0,1035,189,
  	1,0,0,0,1036,1038,5,27,0,0,1037,1039,5,167,0,0,1038,1037,1,0,0,0,1038,
  	1039,1,0,0,0,1039,1040,1,0,0,0,1040,1041,3,338,169,0,1041,1042,3,352,
  	176,0,1042,191,1,0,0,0,1043,1045,5,26,0,0,1044,1046,5,167,0,0,1045,1044,
  	1,0,0,0,1045,1046,1,0,0,0,1046,1047,1,0,0,0,1047,1048,3,338,169,0,1048,
  	1049,3,352,176,0,1049,193,1,0,0,0,1050,1051,5,23,0,0,1051,1053,3,196,
  	98,0,1052,1054,3,198,99,0,1053,1052,1,0,0,0,1053,1054,1,0,0,0,1054,1055,
  	1,0,0,0,1055,1057,3,348,174,0,1056,1058,3,200,100,0,1057,1056,1,0,0,0,
  	1057,1058,1,0,0,0,1058,1060,1,0,0,0,1059,1061,3,202,101,0,1060,1059,1,
  	0,0,0,1060,1061,1,0,0,0,1061,1062,1,0,0,0,1062,1063,3,352,176,0,1063,
  	195,1,0,0,0,1064,1065,5,167,0,0,1065,197,1,0,0,0,1066,1067,5,167,0,0,
  	1067,199,1,0,0,0,1068,1069,5,167,0,0,1069,201,1,0,0,0,1070,1071,5,167,
  	0,0,1071,203,1,0,0,0,1072,1074,5,28,0,0,1073,1075,5,167,0,0,1074,1073,
  	1,0,0,0,1074,1075,1,0,0,0,1075,1077,1,0,0,0,1076,1078,3,338,169,0,1077,
  	1076,1,0,0,0,1077,1078,1,0,0,0,1078,1079,1,0,0,0,1079,1080,3,352,176,
  	0,1080,205,1,0,0,0,1081,1083,5,22,0,0,1082,1084,5,167,0,0,1083,1082,1,
  	0,0,0,1083,1084,1,0,0,0,1084,1086,1,0,0,0,1085,1087,5,167,0,0,1086,1085,
  	1,0,0,0,1086,1087,1,0,0,0,1087,1088,1,0,0,0,1088,1089,3,342,171,0,1089,
  	1090,3,352,176,0,1090,207,1,0,0,0,1091,1093,5,29,0,0,1092,1094,5,166,
  	0,0,1093,1092,1,0,0,0,1094,1095,1,0,0,0,1095,1093,1,0,0,0,1095,1096,1,
  	0,0,0,1096,1097,1,0,0,0,1097,1098,3,352,176,0,1098,209,1,0,0,0,1099,1101,
  	5,25,0,0,1100,1102,3,212,106,0,1101,1100,1,0,0,0,1101,1102,1,0,0,0,1102,
  	1104,1,0,0,0,1103,1105,3,214,107,0,1104,1103,1,0,0,0,1104,1105,1,0,0,
  	0,1105,1107,1,0,0,0,1106,1108,3,216,108,0,1107,1106,1,0,0,0,1107,1108,
  	1,0,0,0,1108,1109,1,0,0,0,1109,1111,3,218,109,0,1110,1112,3,220,110,0,
  	1111,1110,1,0,0,0,1112,1113,1,0,0,0,1113,1111,1,0,0,0,1113,1114,1,0,0,
  	0,1114,1116,1,0,0,0,1115,1117,3,338,169,0,1116,1115,1,0,0,0,1116,1117,
  	1,0,0,0,1117,1118,1,0,0,0,1118,1119,3,352,176,0,1119,211,1,0,0,0,1120,
  	1121,5,167,0,0,1121,213,1,0,0,0,1122,1123,5,51,0,0,1123,215,1,0,0,0,1124,
  	1125,5,52,0,0,1125,217,1,0,0,0,1126,1127,5,167,0,0,1127,219,1,0,0,0,1128,
  	1137,3,222,111,0,1129,1137,3,224,112,0,1130,1137,3,226,113,0,1131,1137,
  	3,228,114,0,1132,1137,3,230,115,0,1133,1134,3,232,116,0,1134,1135,3,234,
  	117,0,1135,1137,1,0,0,0,1136,1128,1,0,0,0,1136,1129,1,0,0,0,1136,1130,
  	1,0,0,0,1136,1131,1,0,0,0,1136,1132,1,0,0,0,1136,1133,1,0,0,0,1137,221,
  	1,0,0,0,1138,1139,5,45,0,0,1139,1140,3,318,159,0,1140,223,1,0,0,0,1141,
  	1143,5,49,0,0,1142,1144,5,118,0,0,1143,1142,1,0,0,0,1143,1144,1,0,0,0,
  	1144,1145,1,0,0,0,1145,1146,3,318,159,0,1146,225,1,0,0,0,1147,1148,5,
  	44,0,0,1148,1149,3,318,159,0,1149,227,1,0,0,0,1150,1151,5,50,0,0,1151,
  	1152,3,318,159,0,1152,229,1,0,0,0,1153,1155,5,31,0,0,1154,1156,5,118,
  	0,0,1155,1154,1,0,0,0,1155,1156,1,0,0,0,1156,1157,1,0,0,0,1157,1158,3,
  	318,159,0,1158,231,1,0,0,0,1159,1160,5,47,0,0,1160,1161,3,338,169,0,1161,
  	233,1,0,0,0,1162,1163,5,48,0,0,1163,1164,3,338,169,0,1164,235,1,0,0,0,
  	1165,1166,5,20,0,0,1166,1167,3,318,159,0,1167,1168,3,318,159,0,1168,1169,
  	3,352,176,0,1169,237,1,0,0,0,1170,1171,5,12,0,0,1171,1172,3,338,169,0,
  	1172,1173,3,352,176,0,1173,239,1,0,0,0,1174,1178,3,242,121,0,1175,1177,
  	3,244,122,0,1176,1175,1,0,0,0,1177,1180,1,0,0,0,1178,1176,1,0,0,0,1178,
  	1179,1,0,0,0,1179,1181,1,0,0,0,1180,1178,1,0,0,0,1181,1182,3,352,176,
  	0,1182,241,1,0,0,0,1183,1208,3,268,134,0,1184,1208,3,270,135,0,1185,1208,
  	3,272,136,0,1186,1208,3,274,137,0,1187,1208,3,276,138,0,1188,1208,3,278,
  	139,0,1189,1208,3,280,140,0,1190,1208,3,282,141,0,1191,1208,3,284,142,
  	0,1192,1208,3,286,143,0,1193,1208,3,288,144,0,1194,1208,3,290,145,0,1195,
  	1208,3,292,146,0,1196,1208,3,294,147,0,1197,1208,3,296,148,0,1198,1208,
  	3,298,149,0,1199,1208,3,300,150,0,1200,1208,3,302,151,0,1201,1208,3,304,
  	152,0,1202,1208,3,306,153,0,1203,1208,3,308,154,0,1204,1208,3,310,155,
  	0,1205,1208,3,312,156,0,1206,1208,3,314,157,0,1207,1183,1,0,0,0,1207,
  	1184,1,0,0,0,1207,1185,1,0,0,0,1207,1186,1,0,0,0,1207,1187,1,0,0,0,1207,
  	1188,1,0,0,0,1207,1189,1,0,0,0,1207,1190,1,0,0,0,1207,1191,1,0,0,0,1207,
  	1192,1,0,0,0,1207,1193,1,0,0,0,1207,1194,1,0,0,0,1207,1195,1,0,0,0,1207,
  	1196,1,0,0,0,1207,1197,1,0,0,0,1207,1198,1,0,0,0,1207,1199,1,0,0,0,1207,
  	1200,1,0,0,0,1207,1201,1,0,0,0,1207,1202,1,0,0,0,1207,1203,1,0,0,0,1207,
  	1204,1,0,0,0,1207,1205,1,0,0,0,1207,1206,1,0,0,0,1208,243,1,0,0,0,1209,
  	1221,3,248,124,0,1210,1221,3,246,123,0,1211,1221,3,250,125,0,1212,1221,
  	3,254,127,0,1213,1221,3,256,128,0,1214,1221,3,258,129,0,1215,1221,3,260,
  	130,0,1216,1221,3,264,132,0,1217,1221,3,262,131,0,1218,1221,3,252,126,
  	0,1219,1221,3,266,133,0,1220,1209,1,0,0,0,1220,1210,1,0,0,0,1220,1211,
  	1,0,0,0,1220,1212,1,0,0,0,1220,1213,1,0,0,0,1220,1214,1,0,0,0,1220,1215,
  	1,0,0,0,1220,1216,1,0,0,0,1220,1217,1,0,0,0,1220,1218,1,0,0,0,1220,1219,
  	1,0,0,0,1221,245,1,0,0,0,1222,1225,5,145,0,0,1223,1226,5,168,0,0,1224,
  	1226,3,318,159,0,1225,1223,1,0,0,0,1225,1224,1,0,0,0,1226,1227,1,0,0,
  	0,1227,1233,5,146,0,0,1228,1231,5,168,0,0,1229,1231,3,318,159,0,1230,
  	1228,1,0,0,0,1230,1229,1,0,0,0,1231,1233,1,0,0,0,1232,1222,1,0,0,0,1232,
  	1230,1,0,0,0,1233,247,1,0,0,0,1234,1241,5,53,0,0,1235,1241,5,58,0,0,1236,
  	1238,7,1,0,0,1237,1236,1,0,0,0,1237,1238,1,0,0,0,1238,1239,1,0,0,0,1239,
  	1241,3,338,169,0,1240,1234,1,0,0,0,1240,1235,1,0,0,0,1240,1237,1,0,0,
  	0,1241,249,1,0,0,0,1242,1243,7,2,0,0,1243,1245,5,145,0,0,1244,1246,3,
  	318,159,0,1245,1244,1,0,0,0,1245,1246,1,0,0,0,1246,1247,1,0,0,0,1247,
  	1253,5,146,0,0,1248,1250,7,2,0,0,1249,1251,3,318,159,0,1250,1249,1,0,
  	0,0,1250,1251,1,0,0,0,1251,1253,1,0,0,0,1252,1242,1,0,0,0,1252,1248,1,
  	0,0,0,1253,251,1,0,0,0,1254,1255,5,71,0,0,1255,253,1,0,0,0,1256,1257,
  	5,54,0,0,1257,1258,3,330,165,0,1258,255,1,0,0,0,1259,1260,5,56,0,0,1260,
  	1261,3,330,165,0,1261,257,1,0,0,0,1262,1263,5,55,0,0,1263,1264,3,330,
  	165,0,1264,259,1,0,0,0,1265,1267,5,57,0,0,1266,1268,3,318,159,0,1267,
  	1266,1,0,0,0,1268,1269,1,0,0,0,1269,1267,1,0,0,0,1269,1270,1,0,0,0,1270,
  	261,1,0,0,0,1271,1272,5,35,0,0,1272,1273,3,318,159,0,1273,1275,5,118,
  	0,0,1274,1276,3,324,162,0,1275,1274,1,0,0,0,1276,1277,1,0,0,0,1277,1275,
  	1,0,0,0,1277,1278,1,0,0,0,1278,263,1,0,0,0,1279,1280,7,3,0,0,1280,1285,
  	5,141,0,0,1281,1283,3,318,159,0,1282,1284,5,148,0,0,1283,1282,1,0,0,0,
  	1283,1284,1,0,0,0,1284,1286,1,0,0,0,1285,1281,1,0,0,0,1286,1287,1,0,0,
  	0,1287,1285,1,0,0,0,1287,1288,1,0,0,0,1288,1289,1,0,0,0,1289,1290,5,142,
  	0,0,1290,265,1,0,0,0,1291,1292,5,41,0,0,1292,1293,5,118,0,0,1293,1294,
  	5,167,0,0,1294,267,1,0,0,0,1295,1296,5,88,0,0,1296,1297,3,336,168,0,1297,
  	1299,3,336,168,0,1298,1300,5,167,0,0,1299,1298,1,0,0,0,1299,1300,1,0,
  	0,0,1300,269,1,0,0,0,1301,1302,5,89,0,0,1302,1303,3,336,168,0,1303,1305,
  	3,336,168,0,1304,1306,5,167,0,0,1305,1304,1,0,0,0,1305,1306,1,0,0,0,1306,
  	271,1,0,0,0,1307,1308,5,90,0,0,1308,1309,3,336,168,0,1309,1310,3,336,
  	168,0,1310,273,1,0,0,0,1311,1312,5,91,0,0,1312,1313,5,167,0,0,1313,1314,
  	5,167,0,0,1314,275,1,0,0,0,1315,1316,5,92,0,0,1316,1317,3,336,168,0,1317,
  	1319,3,336,168,0,1318,1320,3,336,168,0,1319,1318,1,0,0,0,1319,1320,1,
  	0,0,0,1320,1321,1,0,0,0,1321,1322,5,167,0,0,1322,277,1,0,0,0,1323,1324,
  	5,93,0,0,1324,1325,3,336,168,0,1325,1326,3,336,168,0,1326,1327,3,336,
  	168,0,1327,1328,3,336,168,0,1328,279,1,0,0,0,1329,1330,5,94,0,0,1330,
  	281,1,0,0,0,1331,1332,5,95,0,0,1332,283,1,0,0,0,1333,1334,5,96,0,0,1334,
  	285,1,0,0,0,1335,1336,5,97,0,0,1336,1337,3,336,168,0,1337,1338,3,336,
  	168,0,1338,287,1,0,0,0,1339,1340,5,98,0,0,1340,1341,3,336,168,0,1341,
  	1342,3,336,168,0,1342,1343,3,336,168,0,1343,289,1,0,0,0,1344,1345,5,99,
  	0,0,1345,1346,3,336,168,0,1346,1347,3,336,168,0,1347,1348,3,336,168,0,
  	1348,1349,5,167,0,0,1349,291,1,0,0,0,1350,1351,5,100,0,0,1351,1354,3,
  	330,165,0,1352,1353,7,4,0,0,1353,1355,5,118,0,0,1354,1352,1,0,0,0,1354,
  	1355,1,0,0,0,1355,1356,1,0,0,0,1356,1357,5,167,0,0,1357,293,1,0,0,0,1358,
  	1359,5,103,0,0,1359,1360,3,330,165,0,1360,1361,5,167,0,0,1361,1369,1,
  	0,0,0,1362,1365,5,103,0,0,1363,1364,5,43,0,0,1364,1366,5,136,0,0,1365,
  	1363,1,0,0,0,1365,1366,1,0,0,0,1366,1367,1,0,0,0,1367,1369,5,167,0,0,
  	1368,1358,1,0,0,0,1368,1362,1,0,0,0,1369,295,1,0,0,0,1370,1371,5,104,
  	0,0,1371,1372,3,336,168,0,1372,1373,3,336,168,0,1373,297,1,0,0,0,1374,
  	1375,5,105,0,0,1375,1376,3,336,168,0,1376,1377,3,336,168,0,1377,299,1,
  	0,0,0,1378,1379,5,106,0,0,1379,1380,3,336,168,0,1380,1381,3,336,168,0,
  	1381,301,1,0,0,0,1382,1383,5,107,0,0,1383,1384,3,336,168,0,1384,1385,
  	3,336,168,0,1385,303,1,0,0,0,1386,1387,5,108,0,0,1387,1388,3,336,168,
  	0,1388,1389,3,336,168,0,1389,305,1,0,0,0,1390,1391,5,109,0,0,1391,1392,
  	3,336,168,0,1392,1393,3,336,168,0,1393,307,1,0,0,0,1394,1395,5,71,0,0,
  	1395,309,1,0,0,0,1396,1397,5,111,0,0,1397,1398,3,336,168,0,1398,1399,
  	3,336,168,0,1399,1401,3,336,168,0,1400,1402,5,167,0,0,1401,1400,1,0,0,
  	0,1401,1402,1,0,0,0,1402,1407,1,0,0,0,1403,1405,3,328,164,0,1404,1406,
  	3,328,164,0,1405,1404,1,0,0,0,1405,1406,1,0,0,0,1406,1408,1,0,0,0,1407,
  	1403,1,0,0,0,1407,1408,1,0,0,0,1408,311,1,0,0,0,1409,1410,5,110,0,0,1410,
  	1411,3,336,168,0,1411,1412,3,336,168,0,1412,1413,3,336,168,0,1413,1415,
  	3,336,168,0,1414,1416,5,167,0,0,1415,1414,1,0,0,0,1415,1416,1,0,0,0,1416,
  	313,1,0,0,0,1417,1418,7,5,0,0,1418,1419,3,336,168,0,1419,1420,3,336,168,
  	0,1420,1423,3,336,168,0,1421,1422,5,167,0,0,1422,1424,5,167,0,0,1423,
  	1421,1,0,0,0,1423,1424,1,0,0,0,1424,1426,1,0,0,0,1425,1427,5,167,0,0,
  	1426,1425,1,0,0,0,1426,1427,1,0,0,0,1427,1428,1,0,0,0,1428,1429,3,338,
  	169,0,1429,315,1,0,0,0,1430,1431,5,8,0,0,1431,1432,3,352,176,0,1432,317,
  	1,0,0,0,1433,1434,6,159,-1,0,1434,1439,3,320,160,0,1435,1439,3,322,161,
  	0,1436,1439,3,324,162,0,1437,1439,3,328,164,0,1438,1433,1,0,0,0,1438,
  	1435,1,0,0,0,1438,1436,1,0,0,0,1438,1437,1,0,0,0,1439,1458,1,0,0,0,1440,
  	1441,10,1,0,0,1441,1442,5,147,0,0,1442,1443,3,318,159,0,1443,1444,5,136,
  	0,0,1444,1445,3,318,159,2,1445,1457,1,0,0,0,1446,1447,10,3,0,0,1447,1448,
  	5,145,0,0,1448,1449,3,318,159,0,1449,1450,5,146,0,0,1450,1457,1,0,0,0,
  	1451,1452,10,2,0,0,1452,1454,3,326,163,0,1453,1455,3,318,159,0,1454,1453,
  	1,0,0,0,1454,1455,1,0,0,0,1455,1457,1,0,0,0,1456,1440,1,0,0,0,1456,1446,
  	1,0,0,0,1456,1451,1,0,0,0,1457,1460,1,0,0,0,1458,1456,1,0,0,0,1458,1459,
  	1,0,0,0,1459,319,1,0,0,0,1460,1458,1,0,0,0,1461,1462,7,6,0,0,1462,1463,
  	3,318,159,0,1463,321,1,0,0,0,1464,1465,7,7,0,0,1465,1470,7,8,0,0,1466,
  	1468,3,318,159,0,1467,1469,5,148,0,0,1468,1467,1,0,0,0,1468,1469,1,0,
  	0,0,1469,1471,1,0,0,0,1470,1466,1,0,0,0,1471,1472,1,0,0,0,1472,1470,1,
  	0,0,0,1472,1473,1,0,0,0,1473,1474,1,0,0,0,1474,1475,7,9,0,0,1475,323,
  	1,0,0,0,1476,1481,7,8,0,0,1477,1479,3,318,159,0,1478,1480,5,148,0,0,1479,
  	1478,1,0,0,0,1479,1480,1,0,0,0,1480,1482,1,0,0,0,1481,1477,1,0,0,0,1482,
  	1483,1,0,0,0,1483,1481,1,0,0,0,1483,1484,1,0,0,0,1484,1485,1,0,0,0,1485,
  	1486,7,9,0,0,1486,325,1,0,0,0,1487,1488,7,10,0,0,1488,327,1,0,0,0,1489,
  	1490,7,11,0,0,1490,329,1,0,0,0,1491,1493,3,332,166,0,1492,1494,5,148,
  	0,0,1493,1492,1,0,0,0,1493,1494,1,0,0,0,1494,1496,1,0,0,0,1495,1491,1,
  	0,0,0,1496,1497,1,0,0,0,1497,1495,1,0,0,0,1497,1498,1,0,0,0,1498,1511,
  	1,0,0,0,1499,1504,5,141,0,0,1500,1502,3,332,166,0,1501,1503,5,148,0,0,
  	1502,1501,1,0,0,0,1502,1503,1,0,0,0,1503,1505,1,0,0,0,1504,1500,1,0,0,
  	0,1505,1506,1,0,0,0,1506,1504,1,0,0,0,1506,1507,1,0,0,0,1507,1508,1,0,
  	0,0,1508,1509,5,142,0,0,1509,1511,1,0,0,0,1510,1495,1,0,0,0,1510,1499,
  	1,0,0,0,1511,331,1,0,0,0,1512,1515,3,336,168,0,1513,1515,3,334,167,0,
  	1514,1512,1,0,0,0,1514,1513,1,0,0,0,1515,333,1,0,0,0,1516,1517,3,336,
  	168,0,1517,1518,5,118,0,0,1518,1519,3,336,168,0,1519,335,1,0,0,0,1520,
  	1523,7,12,0,0,1521,1522,5,151,0,0,1522,1524,3,336,168,0,1523,1521,1,0,
  	0,0,1523,1524,1,0,0,0,1524,337,1,0,0,0,1525,1527,5,53,0,0,1526,1525,1,
  	0,0,0,1526,1527,1,0,0,0,1527,1529,1,0,0,0,1528,1530,5,141,0,0,1529,1528,
  	1,0,0,0,1529,1530,1,0,0,0,1530,1532,1,0,0,0,1531,1533,3,340,170,0,1532,
  	1531,1,0,0,0,1533,1534,1,0,0,0,1534,1532,1,0,0,0,1534,1535,1,0,0,0,1535,
  	1537,1,0,0,0,1536,1538,5,142,0,0,1537,1536,1,0,0,0,1537,1538,1,0,0,0,
  	1538,339,1,0,0,0,1539,1540,3,342,171,0,1540,341,1,0,0,0,1541,1543,3,344,
  	172,0,1542,1544,3,346,173,0,1543,1542,1,0,0,0,1543,1544,1,0,0,0,1544,
  	343,1,0,0,0,1545,1549,3,322,161,0,1546,1549,3,324,162,0,1547,1549,7,7,
  	0,0,1548,1545,1,0,0,0,1548,1546,1,0,0,0,1548,1547,1,0,0,0,1549,345,1,
  	0,0,0,1550,1551,5,118,0,0,1551,1552,3,318,159,0,1552,347,1,0,0,0,1553,
  	1554,3,350,175,0,1554,349,1,0,0,0,1555,1572,5,167,0,0,1556,1572,5,168,
  	0,0,1557,1558,5,167,0,0,1558,1572,3,350,175,0,1559,1560,5,157,0,0,1560,
  	1561,3,350,175,0,1561,1562,5,157,0,0,1562,1572,1,0,0,0,1563,1564,5,156,
  	0,0,1564,1572,3,350,175,0,1565,1566,5,151,0,0,1566,1572,3,350,175,0,1567,
  	1568,5,139,0,0,1568,1572,3,350,175,0,1569,1570,5,149,0,0,1570,1572,3,
  	350,175,0,1571,1555,1,0,0,0,1571,1556,1,0,0,0,1571,1557,1,0,0,0,1571,
  	1559,1,0,0,0,1571,1563,1,0,0,0,1571,1565,1,0,0,0,1571,1567,1,0,0,0,1571,
  	1569,1,0,0,0,1572,351,1,0,0,0,1573,1575,5,169,0,0,1574,1573,1,0,0,0,1575,
  	1578,1,0,0,0,1576,1574,1,0,0,0,1576,1577,1,0,0,0,1577,1581,1,0,0,0,1578,
  	1576,1,0,0,0,1579,1581,5,0,0,1,1580,1576,1,0,0,0,1580,1579,1,0,0,0,1581,
  	353,1,0,0,0,162,355,361,365,372,384,389,402,406,412,416,432,445,451,458,
  	461,464,472,505,512,521,525,529,550,556,559,565,569,578,581,588,593,599,
  	603,611,619,626,629,633,641,649,660,675,683,688,693,698,701,705,708,711,
  	715,721,727,739,742,758,766,774,788,798,814,822,824,827,834,837,844,850,
  	856,863,866,869,878,882,909,914,923,929,940,944,950,956,968,971,974,977,
  	980,1000,1007,1012,1015,1024,1030,1038,1045,1053,1057,1060,1074,1077,
  	1083,1086,1095,1101,1104,1107,1113,1116,1136,1143,1155,1178,1207,1220,
  	1225,1230,1232,1237,1240,1245,1250,1252,1269,1277,1283,1287,1299,1305,
  	1319,1354,1365,1368,1401,1405,1407,1415,1423,1426,1438,1454,1456,1458,
  	1468,1472,1479,1483,1493,1497,1502,1506,1510,1514,1523,1526,1529,1534,
  	1537,1543,1548,1571,1576,1580
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  eldoparserParserStaticData = std::move(staticData);
}

}

ELDOParser::ELDOParser(TokenStream *input) : ELDOParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

ELDOParser::ELDOParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  ELDOParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *eldoparserParserStaticData->atn, eldoparserParserStaticData->decisionToDFA, eldoparserParserStaticData->sharedContextCache, options);
}

ELDOParser::~ELDOParser() {
  delete _interpreter;
}

const atn::ATN& ELDOParser::getATN() const {
  return *eldoparserParserStaticData->atn;
}

std::string ELDOParser::getGrammarFileName() const {
  return "ELDOParser.g4";
}

const std::vector<std::string>& ELDOParser::getRuleNames() const {
  return eldoparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& ELDOParser::getVocabulary() const {
  return eldoparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView ELDOParser::getSerializedATN() const {
  return eldoparserParserStaticData->serializedATN;
}


//----------------- NetlistContext ------------------------------------------------------------------

ELDOParser::NetlistContext::NetlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::End_of_lineContext *> ELDOParser::NetlistContext::end_of_line() {
  return getRuleContexts<ELDOParser::End_of_lineContext>();
}

ELDOParser::End_of_lineContext* ELDOParser::NetlistContext::end_of_line(size_t i) {
  return getRuleContext<ELDOParser::End_of_lineContext>(i);
}

ELDOParser::Netlist_titleContext* ELDOParser::NetlistContext::netlist_title() {
  return getRuleContext<ELDOParser::Netlist_titleContext>(0);
}

std::vector<ELDOParser::Netlist_entityContext *> ELDOParser::NetlistContext::netlist_entity() {
  return getRuleContexts<ELDOParser::Netlist_entityContext>();
}

ELDOParser::Netlist_entityContext* ELDOParser::NetlistContext::netlist_entity(size_t i) {
  return getRuleContext<ELDOParser::Netlist_entityContext>(i);
}

ELDOParser::EndContext* ELDOParser::NetlistContext::end() {
  return getRuleContext<ELDOParser::EndContext>(0);
}


size_t ELDOParser::NetlistContext::getRuleIndex() const {
  return ELDOParser::RuleNetlist;
}

void ELDOParser::NetlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNetlist(this);
}

void ELDOParser::NetlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNetlist(this);
}


std::any ELDOParser::NetlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNetlist(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::NetlistContext* ELDOParser::netlist() {
  NetlistContext *_localctx = _tracker.createInstance<NetlistContext>(_ctx, getState());
  enterRule(_localctx, 0, ELDOParser::RuleNetlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(355);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(354);
      netlist_title();
    }
    setState(357);
    end_of_line();
    setState(361);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576460750155940260) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 17732511215910911) != 0)) {
      setState(358);
      netlist_entity();
      setState(363);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(365);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::NETLIST_END) {
      setState(364);
      end();
    }
    setState(367);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Netlist_titleContext ------------------------------------------------------------------

ELDOParser::Netlist_titleContext::Netlist_titleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> ELDOParser::Netlist_titleContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Netlist_titleContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}


size_t ELDOParser::Netlist_titleContext::getRuleIndex() const {
  return ELDOParser::RuleNetlist_title;
}

void ELDOParser::Netlist_titleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNetlist_title(this);
}

void ELDOParser::Netlist_titleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNetlist_title(this);
}


std::any ELDOParser::Netlist_titleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNetlist_title(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Netlist_titleContext* ELDOParser::netlist_title() {
  Netlist_titleContext *_localctx = _tracker.createInstance<Netlist_titleContext>(_ctx, getState());
  enterRule(_localctx, 2, ELDOParser::RuleNetlist_title);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(370); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(369);
      match(ELDOParser::ID);
      setState(372); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Netlist_entityContext ------------------------------------------------------------------

ELDOParser::Netlist_entityContext::Netlist_entityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::IncludeContext* ELDOParser::Netlist_entityContext::include() {
  return getRuleContext<ELDOParser::IncludeContext>(0);
}

ELDOParser::LibraryContext* ELDOParser::Netlist_entityContext::library() {
  return getRuleContext<ELDOParser::LibraryContext>(0);
}

ELDOParser::Library_defContext* ELDOParser::Netlist_entityContext::library_def() {
  return getRuleContext<ELDOParser::Library_defContext>(0);
}

ELDOParser::SubcktContext* ELDOParser::Netlist_entityContext::subckt() {
  return getRuleContext<ELDOParser::SubcktContext>(0);
}

ELDOParser::AnalysisContext* ELDOParser::Netlist_entityContext::analysis() {
  return getRuleContext<ELDOParser::AnalysisContext>(0);
}

ELDOParser::GlobalContext* ELDOParser::Netlist_entityContext::global() {
  return getRuleContext<ELDOParser::GlobalContext>(0);
}

ELDOParser::ModelContext* ELDOParser::Netlist_entityContext::model() {
  return getRuleContext<ELDOParser::ModelContext>(0);
}

ELDOParser::Global_declarationsContext* ELDOParser::Netlist_entityContext::global_declarations() {
  return getRuleContext<ELDOParser::Global_declarationsContext>(0);
}

ELDOParser::ControlContext* ELDOParser::Netlist_entityContext::control() {
  return getRuleContext<ELDOParser::ControlContext>(0);
}

ELDOParser::ComponentContext* ELDOParser::Netlist_entityContext::component() {
  return getRuleContext<ELDOParser::ComponentContext>(0);
}


size_t ELDOParser::Netlist_entityContext::getRuleIndex() const {
  return ELDOParser::RuleNetlist_entity;
}

void ELDOParser::Netlist_entityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNetlist_entity(this);
}

void ELDOParser::Netlist_entityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNetlist_entity(this);
}


std::any ELDOParser::Netlist_entityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNetlist_entity(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Netlist_entityContext* ELDOParser::netlist_entity() {
  Netlist_entityContext *_localctx = _tracker.createInstance<Netlist_entityContext>(_ctx, getState());
  enterRule(_localctx, 4, ELDOParser::RuleNetlist_entity);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(384);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(374);
      include();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(375);
      library();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(376);
      library_def();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(377);
      subckt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(378);
      analysis();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(379);
      global();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(380);
      model();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(381);
      global_declarations();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(382);
      control();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(383);
      component();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncludeContext ------------------------------------------------------------------

ELDOParser::IncludeContext::IncludeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Standard_includeContext* ELDOParser::IncludeContext::standard_include() {
  return getRuleContext<ELDOParser::Standard_includeContext>(0);
}

ELDOParser::Dspf_includeContext* ELDOParser::IncludeContext::dspf_include() {
  return getRuleContext<ELDOParser::Dspf_includeContext>(0);
}

ELDOParser::Verilog_includeContext* ELDOParser::IncludeContext::verilog_include() {
  return getRuleContext<ELDOParser::Verilog_includeContext>(0);
}


size_t ELDOParser::IncludeContext::getRuleIndex() const {
  return ELDOParser::RuleInclude;
}

void ELDOParser::IncludeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInclude(this);
}

void ELDOParser::IncludeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInclude(this);
}


std::any ELDOParser::IncludeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitInclude(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::IncludeContext* ELDOParser::include() {
  IncludeContext *_localctx = _tracker.createInstance<IncludeContext>(_ctx, getState());
  enterRule(_localctx, 6, ELDOParser::RuleInclude);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(389);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ELDOParser::INCLUDE: {
        enterOuterAlt(_localctx, 1);
        setState(386);
        standard_include();
        break;
      }

      case ELDOParser::DSPF_INCLUDE: {
        enterOuterAlt(_localctx, 2);
        setState(387);
        dspf_include();
        break;
      }

      case ELDOParser::VERILOG: {
        enterOuterAlt(_localctx, 3);
        setState(388);
        verilog_include();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Standard_includeContext ------------------------------------------------------------------

ELDOParser::Standard_includeContext::Standard_includeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Standard_includeContext::INCLUDE() {
  return getToken(ELDOParser::INCLUDE, 0);
}

ELDOParser::FilepathContext* ELDOParser::Standard_includeContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Standard_includeContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::Standard_includeContext::getRuleIndex() const {
  return ELDOParser::RuleStandard_include;
}

void ELDOParser::Standard_includeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandard_include(this);
}

void ELDOParser::Standard_includeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandard_include(this);
}


std::any ELDOParser::Standard_includeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitStandard_include(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Standard_includeContext* ELDOParser::standard_include() {
  Standard_includeContext *_localctx = _tracker.createInstance<Standard_includeContext>(_ctx, getState());
  enterRule(_localctx, 8, ELDOParser::RuleStandard_include);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(391);
    match(ELDOParser::INCLUDE);
    setState(392);
    filepath();
    setState(393);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Verilog_includeContext ------------------------------------------------------------------

ELDOParser::Verilog_includeContext::Verilog_includeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Verilog_includeContext::VERILOG() {
  return getToken(ELDOParser::VERILOG, 0);
}

ELDOParser::FilepathContext* ELDOParser::Verilog_includeContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Verilog_includeContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::Verilog_includeContext::getRuleIndex() const {
  return ELDOParser::RuleVerilog_include;
}

void ELDOParser::Verilog_includeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVerilog_include(this);
}

void ELDOParser::Verilog_includeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVerilog_include(this);
}


std::any ELDOParser::Verilog_includeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitVerilog_include(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Verilog_includeContext* ELDOParser::verilog_include() {
  Verilog_includeContext *_localctx = _tracker.createInstance<Verilog_includeContext>(_ctx, getState());
  enterRule(_localctx, 10, ELDOParser::RuleVerilog_include);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(395);
    match(ELDOParser::VERILOG);
    setState(396);
    filepath();
    setState(397);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dspf_includeContext ------------------------------------------------------------------

ELDOParser::Dspf_includeContext::Dspf_includeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Dspf_includeContext::DSPF_INCLUDE() {
  return getToken(ELDOParser::DSPF_INCLUDE, 0);
}

ELDOParser::FilepathContext* ELDOParser::Dspf_includeContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Dspf_includeContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

tree::TerminalNode* ELDOParser::Dspf_includeContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::Dspf_includeContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::Dspf_includeContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Dspf_includeContext::getRuleIndex() const {
  return ELDOParser::RuleDspf_include;
}

void ELDOParser::Dspf_includeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDspf_include(this);
}

void ELDOParser::Dspf_includeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDspf_include(this);
}


std::any ELDOParser::Dspf_includeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDspf_include(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Dspf_includeContext* ELDOParser::dspf_include() {
  Dspf_includeContext *_localctx = _tracker.createInstance<Dspf_includeContext>(_ctx, getState());
  enterRule(_localctx, 12, ELDOParser::RuleDspf_include);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(399);
    match(ELDOParser::DSPF_INCLUDE);
    setState(402);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      setState(400);
      match(ELDOParser::ID);
      setState(401);
      match(ELDOParser::EQUAL);
      break;
    }

    default:
      break;
    }
    setState(404);
    filepath();
    setState(406);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(405);
      parameter_list();
    }
    setState(408);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LibraryContext ------------------------------------------------------------------

ELDOParser::LibraryContext::LibraryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::LibraryContext::LIB() {
  return getToken(ELDOParser::LIB, 0);
}

ELDOParser::Library_pathContext* ELDOParser::LibraryContext::library_path() {
  return getRuleContext<ELDOParser::Library_pathContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::LibraryContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Library_keyContext* ELDOParser::LibraryContext::library_key() {
  return getRuleContext<ELDOParser::Library_keyContext>(0);
}

ELDOParser::Library_nameContext* ELDOParser::LibraryContext::library_name() {
  return getRuleContext<ELDOParser::Library_nameContext>(0);
}


size_t ELDOParser::LibraryContext::getRuleIndex() const {
  return ELDOParser::RuleLibrary;
}

void ELDOParser::LibraryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary(this);
}

void ELDOParser::LibraryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary(this);
}


std::any ELDOParser::LibraryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLibrary(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::LibraryContext* ELDOParser::library() {
  LibraryContext *_localctx = _tracker.createInstance<LibraryContext>(_ctx, getState());
  enterRule(_localctx, 14, ELDOParser::RuleLibrary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(410);
    match(ELDOParser::LIB);
    setState(412);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::KEY) {
      setState(411);
      library_key();
    }
    setState(414);
    library_path();
    setState(416);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(415);
      library_name();
    }
    setState(418);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_keyContext ------------------------------------------------------------------

ELDOParser::Library_keyContext::Library_keyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Library_keyContext::KEY() {
  return getToken(ELDOParser::KEY, 0);
}

tree::TerminalNode* ELDOParser::Library_keyContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Library_keyContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Library_keyContext::getRuleIndex() const {
  return ELDOParser::RuleLibrary_key;
}

void ELDOParser::Library_keyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_key(this);
}

void ELDOParser::Library_keyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_key(this);
}


std::any ELDOParser::Library_keyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_key(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Library_keyContext* ELDOParser::library_key() {
  Library_keyContext *_localctx = _tracker.createInstance<Library_keyContext>(_ctx, getState());
  enterRule(_localctx, 16, ELDOParser::RuleLibrary_key);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(420);
    match(ELDOParser::KEY);
    setState(421);
    match(ELDOParser::EQUAL);
    setState(422);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_pathContext ------------------------------------------------------------------

ELDOParser::Library_pathContext::Library_pathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::FilepathContext* ELDOParser::Library_pathContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}


size_t ELDOParser::Library_pathContext::getRuleIndex() const {
  return ELDOParser::RuleLibrary_path;
}

void ELDOParser::Library_pathContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_path(this);
}

void ELDOParser::Library_pathContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_path(this);
}


std::any ELDOParser::Library_pathContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_path(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Library_pathContext* ELDOParser::library_path() {
  Library_pathContext *_localctx = _tracker.createInstance<Library_pathContext>(_ctx, getState());
  enterRule(_localctx, 18, ELDOParser::RuleLibrary_path);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(424);
    filepath();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_nameContext ------------------------------------------------------------------

ELDOParser::Library_nameContext::Library_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Library_nameContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Library_nameContext::getRuleIndex() const {
  return ELDOParser::RuleLibrary_name;
}

void ELDOParser::Library_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_name(this);
}

void ELDOParser::Library_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_name(this);
}


std::any ELDOParser::Library_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_name(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Library_nameContext* ELDOParser::library_name() {
  Library_nameContext *_localctx = _tracker.createInstance<Library_nameContext>(_ctx, getState());
  enterRule(_localctx, 20, ELDOParser::RuleLibrary_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(426);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_defContext ------------------------------------------------------------------

ELDOParser::Library_defContext::Library_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Library_def_headerContext* ELDOParser::Library_defContext::library_def_header() {
  return getRuleContext<ELDOParser::Library_def_headerContext>(0);
}

ELDOParser::Library_def_footerContext* ELDOParser::Library_defContext::library_def_footer() {
  return getRuleContext<ELDOParser::Library_def_footerContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Library_defContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

std::vector<ELDOParser::Library_def_contentContext *> ELDOParser::Library_defContext::library_def_content() {
  return getRuleContexts<ELDOParser::Library_def_contentContext>();
}

ELDOParser::Library_def_contentContext* ELDOParser::Library_defContext::library_def_content(size_t i) {
  return getRuleContext<ELDOParser::Library_def_contentContext>(i);
}


size_t ELDOParser::Library_defContext::getRuleIndex() const {
  return ELDOParser::RuleLibrary_def;
}

void ELDOParser::Library_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_def(this);
}

void ELDOParser::Library_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_def(this);
}


std::any ELDOParser::Library_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_def(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Library_defContext* ELDOParser::library_def() {
  Library_defContext *_localctx = _tracker.createInstance<Library_defContext>(_ctx, getState());
  enterRule(_localctx, 22, ELDOParser::RuleLibrary_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(428);
    library_def_header();
    setState(430); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(429);
      library_def_content();
      setState(432); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576460750155940260) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 17732511215910911) != 0));
    setState(434);
    library_def_footer();
    setState(435);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_def_headerContext ------------------------------------------------------------------

ELDOParser::Library_def_headerContext::Library_def_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Library_def_headerContext::LIB() {
  return getToken(ELDOParser::LIB, 0);
}

ELDOParser::Library_nameContext* ELDOParser::Library_def_headerContext::library_name() {
  return getRuleContext<ELDOParser::Library_nameContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Library_def_headerContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::Library_def_headerContext::getRuleIndex() const {
  return ELDOParser::RuleLibrary_def_header;
}

void ELDOParser::Library_def_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_def_header(this);
}

void ELDOParser::Library_def_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_def_header(this);
}


std::any ELDOParser::Library_def_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_def_header(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Library_def_headerContext* ELDOParser::library_def_header() {
  Library_def_headerContext *_localctx = _tracker.createInstance<Library_def_headerContext>(_ctx, getState());
  enterRule(_localctx, 24, ELDOParser::RuleLibrary_def_header);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(437);
    match(ELDOParser::LIB);
    setState(438);
    library_name();
    setState(439);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_def_contentContext ------------------------------------------------------------------

ELDOParser::Library_def_contentContext::Library_def_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Netlist_entityContext* ELDOParser::Library_def_contentContext::netlist_entity() {
  return getRuleContext<ELDOParser::Netlist_entityContext>(0);
}


size_t ELDOParser::Library_def_contentContext::getRuleIndex() const {
  return ELDOParser::RuleLibrary_def_content;
}

void ELDOParser::Library_def_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_def_content(this);
}

void ELDOParser::Library_def_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_def_content(this);
}


std::any ELDOParser::Library_def_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_def_content(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Library_def_contentContext* ELDOParser::library_def_content() {
  Library_def_contentContext *_localctx = _tracker.createInstance<Library_def_contentContext>(_ctx, getState());
  enterRule(_localctx, 26, ELDOParser::RuleLibrary_def_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(441);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_def_footerContext ------------------------------------------------------------------

ELDOParser::Library_def_footerContext::Library_def_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Library_def_footerContext::LIB_END() {
  return getToken(ELDOParser::LIB_END, 0);
}

ELDOParser::Library_nameContext* ELDOParser::Library_def_footerContext::library_name() {
  return getRuleContext<ELDOParser::Library_nameContext>(0);
}


size_t ELDOParser::Library_def_footerContext::getRuleIndex() const {
  return ELDOParser::RuleLibrary_def_footer;
}

void ELDOParser::Library_def_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLibrary_def_footer(this);
}

void ELDOParser::Library_def_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLibrary_def_footer(this);
}


std::any ELDOParser::Library_def_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_def_footer(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Library_def_footerContext* ELDOParser::library_def_footer() {
  Library_def_footerContext *_localctx = _tracker.createInstance<Library_def_footerContext>(_ctx, getState());
  enterRule(_localctx, 28, ELDOParser::RuleLibrary_def_footer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(443);
    match(ELDOParser::LIB_END);
    setState(445);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(444);
      library_name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubcktContext ------------------------------------------------------------------

ELDOParser::SubcktContext::SubcktContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Subckt_headerContext* ELDOParser::SubcktContext::subckt_header() {
  return getRuleContext<ELDOParser::Subckt_headerContext>(0);
}

ELDOParser::Subckt_footerContext* ELDOParser::SubcktContext::subckt_footer() {
  return getRuleContext<ELDOParser::Subckt_footerContext>(0);
}

std::vector<ELDOParser::Subckt_contentContext *> ELDOParser::SubcktContext::subckt_content() {
  return getRuleContexts<ELDOParser::Subckt_contentContext>();
}

ELDOParser::Subckt_contentContext* ELDOParser::SubcktContext::subckt_content(size_t i) {
  return getRuleContext<ELDOParser::Subckt_contentContext>(i);
}


size_t ELDOParser::SubcktContext::getRuleIndex() const {
  return ELDOParser::RuleSubckt;
}

void ELDOParser::SubcktContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt(this);
}

void ELDOParser::SubcktContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt(this);
}


std::any ELDOParser::SubcktContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSubckt(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::SubcktContext* ELDOParser::subckt() {
  SubcktContext *_localctx = _tracker.createInstance<SubcktContext>(_ctx, getState());
  enterRule(_localctx, 30, ELDOParser::RuleSubckt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(447);
    subckt_header();
    setState(449); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(448);
      subckt_content();
      setState(451); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -576460750155940260) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 17732511215910911) != 0));
    setState(453);
    subckt_footer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subckt_headerContext ------------------------------------------------------------------

ELDOParser::Subckt_headerContext::Subckt_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Subckt_headerContext::SUBCKT() {
  return getToken(ELDOParser::SUBCKT, 0);
}

tree::TerminalNode* ELDOParser::Subckt_headerContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::Subckt_headerContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Node_listContext* ELDOParser::Subckt_headerContext::node_list() {
  return getRuleContext<ELDOParser::Node_listContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::Subckt_headerContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

tree::TerminalNode* ELDOParser::Subckt_headerContext::PARAM_LIST_START() {
  return getToken(ELDOParser::PARAM_LIST_START, 0);
}


size_t ELDOParser::Subckt_headerContext::getRuleIndex() const {
  return ELDOParser::RuleSubckt_header;
}

void ELDOParser::Subckt_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt_header(this);
}

void ELDOParser::Subckt_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt_header(this);
}


std::any ELDOParser::Subckt_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSubckt_header(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Subckt_headerContext* ELDOParser::subckt_header() {
  Subckt_headerContext *_localctx = _tracker.createInstance<Subckt_headerContext>(_ctx, getState());
  enterRule(_localctx, 32, ELDOParser::RuleSubckt_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(455);
    match(ELDOParser::SUBCKT);
    setState(456);
    match(ELDOParser::ID);
    setState(458);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      setState(457);
      node_list();
      break;
    }

    default:
      break;
    }
    setState(464);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(461);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
      case 1: {
        setState(460);
        match(ELDOParser::PARAM_LIST_START);
        break;
      }

      default:
        break;
      }
      setState(463);
      parameter_list();
    }
    setState(466);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subckt_contentContext ------------------------------------------------------------------

ELDOParser::Subckt_contentContext::Subckt_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Netlist_entityContext* ELDOParser::Subckt_contentContext::netlist_entity() {
  return getRuleContext<ELDOParser::Netlist_entityContext>(0);
}


size_t ELDOParser::Subckt_contentContext::getRuleIndex() const {
  return ELDOParser::RuleSubckt_content;
}

void ELDOParser::Subckt_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt_content(this);
}

void ELDOParser::Subckt_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt_content(this);
}


std::any ELDOParser::Subckt_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSubckt_content(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Subckt_contentContext* ELDOParser::subckt_content() {
  Subckt_contentContext *_localctx = _tracker.createInstance<Subckt_contentContext>(_ctx, getState());
  enterRule(_localctx, 34, ELDOParser::RuleSubckt_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(468);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subckt_footerContext ------------------------------------------------------------------

ELDOParser::Subckt_footerContext::Subckt_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Subckt_footerContext::SUBCKT_END() {
  return getToken(ELDOParser::SUBCKT_END, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::Subckt_footerContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

tree::TerminalNode* ELDOParser::Subckt_footerContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Subckt_footerContext::getRuleIndex() const {
  return ELDOParser::RuleSubckt_footer;
}

void ELDOParser::Subckt_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt_footer(this);
}

void ELDOParser::Subckt_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt_footer(this);
}


std::any ELDOParser::Subckt_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSubckt_footer(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Subckt_footerContext* ELDOParser::subckt_footer() {
  Subckt_footerContext *_localctx = _tracker.createInstance<Subckt_footerContext>(_ctx, getState());
  enterRule(_localctx, 36, ELDOParser::RuleSubckt_footer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(470);
    match(ELDOParser::SUBCKT_END);
    setState(472);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(471);
      match(ELDOParser::ID);
    }
    setState(474);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnalysisContext ------------------------------------------------------------------

ELDOParser::AnalysisContext::AnalysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::AcContext* ELDOParser::AnalysisContext::ac() {
  return getRuleContext<ELDOParser::AcContext>(0);
}

ELDOParser::AgeContext* ELDOParser::AnalysisContext::age() {
  return getRuleContext<ELDOParser::AgeContext>(0);
}

ELDOParser::ChecksoaContext* ELDOParser::AnalysisContext::checksoa() {
  return getRuleContext<ELDOParser::ChecksoaContext>(0);
}

ELDOParser::DcContext* ELDOParser::AnalysisContext::dc() {
  return getRuleContext<ELDOParser::DcContext>(0);
}

ELDOParser::DchizContext* ELDOParser::AnalysisContext::dchiz() {
  return getRuleContext<ELDOParser::DchizContext>(0);
}

ELDOParser::DcmismatchContext* ELDOParser::AnalysisContext::dcmismatch() {
  return getRuleContext<ELDOParser::DcmismatchContext>(0);
}

ELDOParser::DexContext* ELDOParser::AnalysisContext::dex() {
  return getRuleContext<ELDOParser::DexContext>(0);
}

ELDOParser::DspContext* ELDOParser::AnalysisContext::dsp() {
  return getRuleContext<ELDOParser::DspContext>(0);
}

ELDOParser::DspmodContext* ELDOParser::AnalysisContext::dspmod() {
  return getRuleContext<ELDOParser::DspmodContext>(0);
}

ELDOParser::FourContext* ELDOParser::AnalysisContext::four() {
  return getRuleContext<ELDOParser::FourContext>(0);
}

ELDOParser::LstbContext* ELDOParser::AnalysisContext::lstb() {
  return getRuleContext<ELDOParser::LstbContext>(0);
}

ELDOParser::McContext* ELDOParser::AnalysisContext::mc() {
  return getRuleContext<ELDOParser::McContext>(0);
}

ELDOParser::NoiseContext* ELDOParser::AnalysisContext::noise() {
  return getRuleContext<ELDOParser::NoiseContext>(0);
}

ELDOParser::NoisetranContext* ELDOParser::AnalysisContext::noisetran() {
  return getRuleContext<ELDOParser::NoisetranContext>(0);
}

ELDOParser::OpContext* ELDOParser::AnalysisContext::op() {
  return getRuleContext<ELDOParser::OpContext>(0);
}

ELDOParser::OptfourContext* ELDOParser::AnalysisContext::optfour() {
  return getRuleContext<ELDOParser::OptfourContext>(0);
}

ELDOParser::OptimizeContext* ELDOParser::AnalysisContext::optimize() {
  return getRuleContext<ELDOParser::OptimizeContext>(0);
}

ELDOParser::OptnoiseContext* ELDOParser::AnalysisContext::optnoise() {
  return getRuleContext<ELDOParser::OptnoiseContext>(0);
}

ELDOParser::PzContext* ELDOParser::AnalysisContext::pz() {
  return getRuleContext<ELDOParser::PzContext>(0);
}

ELDOParser::RampContext* ELDOParser::AnalysisContext::ramp() {
  return getRuleContext<ELDOParser::RampContext>(0);
}

ELDOParser::SensContext* ELDOParser::AnalysisContext::sens() {
  return getRuleContext<ELDOParser::SensContext>(0);
}

ELDOParser::SensacContext* ELDOParser::AnalysisContext::sensac() {
  return getRuleContext<ELDOParser::SensacContext>(0);
}

ELDOParser::SensparamContext* ELDOParser::AnalysisContext::sensparam() {
  return getRuleContext<ELDOParser::SensparamContext>(0);
}

ELDOParser::SnfContext* ELDOParser::AnalysisContext::snf() {
  return getRuleContext<ELDOParser::SnfContext>(0);
}

ELDOParser::SolveContext* ELDOParser::AnalysisContext::solve() {
  return getRuleContext<ELDOParser::SolveContext>(0);
}

ELDOParser::TfContext* ELDOParser::AnalysisContext::tf() {
  return getRuleContext<ELDOParser::TfContext>(0);
}

ELDOParser::TranContext* ELDOParser::AnalysisContext::tran() {
  return getRuleContext<ELDOParser::TranContext>(0);
}

ELDOParser::WcaseContext* ELDOParser::AnalysisContext::wcase() {
  return getRuleContext<ELDOParser::WcaseContext>(0);
}

ELDOParser::ExtractContext* ELDOParser::AnalysisContext::extract() {
  return getRuleContext<ELDOParser::ExtractContext>(0);
}


size_t ELDOParser::AnalysisContext::getRuleIndex() const {
  return ELDOParser::RuleAnalysis;
}

void ELDOParser::AnalysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalysis(this);
}

void ELDOParser::AnalysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalysis(this);
}


std::any ELDOParser::AnalysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAnalysis(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::AnalysisContext* ELDOParser::analysis() {
  AnalysisContext *_localctx = _tracker.createInstance<AnalysisContext>(_ctx, getState());
  enterRule(_localctx, 38, ELDOParser::RuleAnalysis);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(505);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ELDOParser::AC: {
        enterOuterAlt(_localctx, 1);
        setState(476);
        ac();
        break;
      }

      case ELDOParser::AGE: {
        enterOuterAlt(_localctx, 2);
        setState(477);
        age();
        break;
      }

      case ELDOParser::CHECKSOA: {
        enterOuterAlt(_localctx, 3);
        setState(478);
        checksoa();
        break;
      }

      case ELDOParser::DC: {
        enterOuterAlt(_localctx, 4);
        setState(479);
        dc();
        break;
      }

      case ELDOParser::DCHIZ: {
        enterOuterAlt(_localctx, 5);
        setState(480);
        dchiz();
        break;
      }

      case ELDOParser::DCMISMATCH: {
        enterOuterAlt(_localctx, 6);
        setState(481);
        dcmismatch();
        break;
      }

      case ELDOParser::DEX: {
        enterOuterAlt(_localctx, 7);
        setState(482);
        dex();
        break;
      }

      case ELDOParser::DSP: {
        enterOuterAlt(_localctx, 8);
        setState(483);
        dsp();
        break;
      }

      case ELDOParser::DSPMOD: {
        enterOuterAlt(_localctx, 9);
        setState(484);
        dspmod();
        break;
      }

      case ELDOParser::FOUR: {
        enterOuterAlt(_localctx, 10);
        setState(485);
        four();
        break;
      }

      case ELDOParser::LSTB: {
        enterOuterAlt(_localctx, 11);
        setState(486);
        lstb();
        break;
      }

      case ELDOParser::MC: {
        enterOuterAlt(_localctx, 12);
        setState(487);
        mc();
        break;
      }

      case ELDOParser::NOISE: {
        enterOuterAlt(_localctx, 13);
        setState(488);
        noise();
        break;
      }

      case ELDOParser::NOISETRAN: {
        enterOuterAlt(_localctx, 14);
        setState(489);
        noisetran();
        break;
      }

      case ELDOParser::OP: {
        enterOuterAlt(_localctx, 15);
        setState(490);
        op();
        break;
      }

      case ELDOParser::OPTFOUR: {
        enterOuterAlt(_localctx, 16);
        setState(491);
        optfour();
        break;
      }

      case ELDOParser::OPTIMIZE: {
        enterOuterAlt(_localctx, 17);
        setState(492);
        optimize();
        break;
      }

      case ELDOParser::OPTNOISE: {
        enterOuterAlt(_localctx, 18);
        setState(493);
        optnoise();
        break;
      }

      case ELDOParser::PZ: {
        enterOuterAlt(_localctx, 19);
        setState(494);
        pz();
        break;
      }

      case ELDOParser::RAMP: {
        enterOuterAlt(_localctx, 20);
        setState(495);
        ramp();
        break;
      }

      case ELDOParser::SENS: {
        enterOuterAlt(_localctx, 21);
        setState(496);
        sens();
        break;
      }

      case ELDOParser::SENSAC: {
        enterOuterAlt(_localctx, 22);
        setState(497);
        sensac();
        break;
      }

      case ELDOParser::SENSPARAM: {
        enterOuterAlt(_localctx, 23);
        setState(498);
        sensparam();
        break;
      }

      case ELDOParser::SNF: {
        enterOuterAlt(_localctx, 24);
        setState(499);
        snf();
        break;
      }

      case ELDOParser::SOLVE: {
        enterOuterAlt(_localctx, 25);
        setState(500);
        solve();
        break;
      }

      case ELDOParser::TF: {
        enterOuterAlt(_localctx, 26);
        setState(501);
        tf();
        break;
      }

      case ELDOParser::TRAN: {
        enterOuterAlt(_localctx, 27);
        setState(502);
        tran();
        break;
      }

      case ELDOParser::WCASE: {
        enterOuterAlt(_localctx, 28);
        setState(503);
        wcase();
        break;
      }

      case ELDOParser::EXTRACT: {
        enterOuterAlt(_localctx, 29);
        setState(504);
        extract();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AcContext ------------------------------------------------------------------

ELDOParser::AcContext::AcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::AcContext::AC() {
  return getToken(ELDOParser::AC, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::AcContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Ac_parameter_drivenContext* ELDOParser::AcContext::ac_parameter_driven() {
  return getRuleContext<ELDOParser::Ac_parameter_drivenContext>(0);
}

ELDOParser::Ac_data_drivenContext* ELDOParser::AcContext::ac_data_driven() {
  return getRuleContext<ELDOParser::Ac_data_drivenContext>(0);
}

ELDOParser::Ac_list_drivenContext* ELDOParser::AcContext::ac_list_driven() {
  return getRuleContext<ELDOParser::Ac_list_drivenContext>(0);
}

ELDOParser::Ac_adaptiveContext* ELDOParser::AcContext::ac_adaptive() {
  return getRuleContext<ELDOParser::Ac_adaptiveContext>(0);
}


size_t ELDOParser::AcContext::getRuleIndex() const {
  return ELDOParser::RuleAc;
}

void ELDOParser::AcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAc(this);
}

void ELDOParser::AcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAc(this);
}


std::any ELDOParser::AcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAc(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::AcContext* ELDOParser::ac() {
  AcContext *_localctx = _tracker.createInstance<AcContext>(_ctx, getState());
  enterRule(_localctx, 40, ELDOParser::RuleAc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(507);
    match(ELDOParser::AC);
    setState(512);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(508);
      ac_parameter_driven();
      break;
    }

    case 2: {
      setState(509);
      ac_data_driven();
      break;
    }

    case 3: {
      setState(510);
      ac_list_driven();
      break;
    }

    case 4: {
      setState(511);
      ac_adaptive();
      break;
    }

    default:
      break;
    }
    setState(514);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ac_parameter_drivenContext ------------------------------------------------------------------

ELDOParser::Ac_parameter_drivenContext::Ac_parameter_drivenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ac_parameter_drivenContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Ac_parameter_drivenContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Ac_parameter_drivenContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Ac_parameter_drivenContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Ac_parameter_drivenContext::getRuleIndex() const {
  return ELDOParser::RuleAc_parameter_driven;
}

void ELDOParser::Ac_parameter_drivenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAc_parameter_driven(this);
}

void ELDOParser::Ac_parameter_drivenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAc_parameter_driven(this);
}


std::any ELDOParser::Ac_parameter_drivenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAc_parameter_driven(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ac_parameter_drivenContext* ELDOParser::ac_parameter_driven() {
  Ac_parameter_drivenContext *_localctx = _tracker.createInstance<Ac_parameter_drivenContext>(_ctx, getState());
  enterRule(_localctx, 42, ELDOParser::RuleAc_parameter_driven);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(516);
    match(ELDOParser::ID);
    setState(517);
    match(ELDOParser::NUMBER);
    setState(518);
    match(ELDOParser::NUMBER);
    setState(519);
    match(ELDOParser::NUMBER);
    setState(521);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(520);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ac_data_drivenContext ------------------------------------------------------------------

ELDOParser::Ac_data_drivenContext::Ac_data_drivenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::ParameterContext* ELDOParser::Ac_data_drivenContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::Ac_data_drivenContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Ac_data_drivenContext::getRuleIndex() const {
  return ELDOParser::RuleAc_data_driven;
}

void ELDOParser::Ac_data_drivenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAc_data_driven(this);
}

void ELDOParser::Ac_data_drivenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAc_data_driven(this);
}


std::any ELDOParser::Ac_data_drivenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAc_data_driven(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ac_data_drivenContext* ELDOParser::ac_data_driven() {
  Ac_data_drivenContext *_localctx = _tracker.createInstance<Ac_data_drivenContext>(_ctx, getState());
  enterRule(_localctx, 44, ELDOParser::RuleAc_data_driven);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(523);
    parameter();
    setState(525);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(524);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ac_list_drivenContext ------------------------------------------------------------------

ELDOParser::Ac_list_drivenContext::Ac_list_drivenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ac_list_drivenContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::Ac_list_drivenContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Ac_list_drivenContext::getRuleIndex() const {
  return ELDOParser::RuleAc_list_driven;
}

void ELDOParser::Ac_list_drivenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAc_list_driven(this);
}

void ELDOParser::Ac_list_drivenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAc_list_driven(this);
}


std::any ELDOParser::Ac_list_drivenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAc_list_driven(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ac_list_drivenContext* ELDOParser::ac_list_driven() {
  Ac_list_drivenContext *_localctx = _tracker.createInstance<Ac_list_drivenContext>(_ctx, getState());
  enterRule(_localctx, 46, ELDOParser::RuleAc_list_driven);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(527);
    match(ELDOParser::ID);
    setState(529);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(528);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ac_adaptiveContext ------------------------------------------------------------------

ELDOParser::Ac_adaptiveContext::Ac_adaptiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ac_adaptiveContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Ac_adaptiveContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Ac_adaptiveContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}


size_t ELDOParser::Ac_adaptiveContext::getRuleIndex() const {
  return ELDOParser::RuleAc_adaptive;
}

void ELDOParser::Ac_adaptiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAc_adaptive(this);
}

void ELDOParser::Ac_adaptiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAc_adaptive(this);
}


std::any ELDOParser::Ac_adaptiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAc_adaptive(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ac_adaptiveContext* ELDOParser::ac_adaptive() {
  Ac_adaptiveContext *_localctx = _tracker.createInstance<Ac_adaptiveContext>(_ctx, getState());
  enterRule(_localctx, 48, ELDOParser::RuleAc_adaptive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(531);
    match(ELDOParser::ID);
    setState(532);
    match(ELDOParser::NUMBER);
    setState(533);
    match(ELDOParser::NUMBER);
    setState(534);
    match(ELDOParser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AgeContext ------------------------------------------------------------------

ELDOParser::AgeContext::AgeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::AgeContext::AGE() {
  return getToken(ELDOParser::AGE, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::AgeContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::AgeContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::AgeContext::getRuleIndex() const {
  return ELDOParser::RuleAge;
}

void ELDOParser::AgeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAge(this);
}

void ELDOParser::AgeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAge(this);
}


std::any ELDOParser::AgeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAge(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::AgeContext* ELDOParser::age() {
  AgeContext *_localctx = _tracker.createInstance<AgeContext>(_ctx, getState());
  enterRule(_localctx, 50, ELDOParser::RuleAge);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(536);
    match(ELDOParser::AGE);
    setState(537);
    parameter_list();
    setState(538);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChecksoaContext ------------------------------------------------------------------

ELDOParser::ChecksoaContext::ChecksoaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::ChecksoaContext::CHECKSOA() {
  return getToken(ELDOParser::CHECKSOA, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::ChecksoaContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::ChecksoaContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::ChecksoaContext::getRuleIndex() const {
  return ELDOParser::RuleChecksoa;
}

void ELDOParser::ChecksoaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecksoa(this);
}

void ELDOParser::ChecksoaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecksoa(this);
}


std::any ELDOParser::ChecksoaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitChecksoa(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ChecksoaContext* ELDOParser::checksoa() {
  ChecksoaContext *_localctx = _tracker.createInstance<ChecksoaContext>(_ctx, getState());
  enterRule(_localctx, 52, ELDOParser::RuleChecksoa);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(540);
    match(ELDOParser::CHECKSOA);
    setState(541);
    parameter_list();
    setState(542);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DcContext ------------------------------------------------------------------

ELDOParser::DcContext::DcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::DcContext::DC() {
  return getToken(ELDOParser::DC, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::DcContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Dc_component_analysisContext* ELDOParser::DcContext::dc_component_analysis() {
  return getRuleContext<ELDOParser::Dc_component_analysisContext>(0);
}

ELDOParser::Dc_source_analysisContext* ELDOParser::DcContext::dc_source_analysis() {
  return getRuleContext<ELDOParser::Dc_source_analysisContext>(0);
}

ELDOParser::Dc_temperature_analysisContext* ELDOParser::DcContext::dc_temperature_analysis() {
  return getRuleContext<ELDOParser::Dc_temperature_analysisContext>(0);
}

ELDOParser::Dc_parameter_analysisContext* ELDOParser::DcContext::dc_parameter_analysis() {
  return getRuleContext<ELDOParser::Dc_parameter_analysisContext>(0);
}

ELDOParser::Dc_data_driven_analysisContext* ELDOParser::DcContext::dc_data_driven_analysis() {
  return getRuleContext<ELDOParser::Dc_data_driven_analysisContext>(0);
}


size_t ELDOParser::DcContext::getRuleIndex() const {
  return ELDOParser::RuleDc;
}

void ELDOParser::DcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDc(this);
}

void ELDOParser::DcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDc(this);
}


std::any ELDOParser::DcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDc(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::DcContext* ELDOParser::dc() {
  DcContext *_localctx = _tracker.createInstance<DcContext>(_ctx, getState());
  enterRule(_localctx, 54, ELDOParser::RuleDc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(544);
    match(ELDOParser::DC);
    setState(550);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(545);
      dc_component_analysis();
      break;
    }

    case 2: {
      setState(546);
      dc_source_analysis();
      break;
    }

    case 3: {
      setState(547);
      dc_temperature_analysis();
      break;
    }

    case 4: {
      setState(548);
      dc_parameter_analysis();
      break;
    }

    case 5: {
      setState(549);
      dc_data_driven_analysis();
      break;
    }

    default:
      break;
    }
    setState(552);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dc_component_analysisContext ------------------------------------------------------------------

ELDOParser::Dc_component_analysisContext::Dc_component_analysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> ELDOParser::Dc_component_analysisContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Dc_component_analysisContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}

std::vector<tree::TerminalNode *> ELDOParser::Dc_component_analysisContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Dc_component_analysisContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Dc_component_analysisContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Dc_component_analysisContext::getRuleIndex() const {
  return ELDOParser::RuleDc_component_analysis;
}

void ELDOParser::Dc_component_analysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDc_component_analysis(this);
}

void ELDOParser::Dc_component_analysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDc_component_analysis(this);
}


std::any ELDOParser::Dc_component_analysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDc_component_analysis(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Dc_component_analysisContext* ELDOParser::dc_component_analysis() {
  Dc_component_analysisContext *_localctx = _tracker.createInstance<Dc_component_analysisContext>(_ctx, getState());
  enterRule(_localctx, 56, ELDOParser::RuleDc_component_analysis);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(554);
    match(ELDOParser::ID);
    setState(556);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      setState(555);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(559);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(558);
      match(ELDOParser::ID);
    }
    setState(561);
    match(ELDOParser::NUMBER);
    setState(562);
    match(ELDOParser::NUMBER);
    setState(563);
    match(ELDOParser::NUMBER);
    setState(565);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(564);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dc_source_analysisContext ------------------------------------------------------------------

ELDOParser::Dc_source_analysisContext::Dc_source_analysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> ELDOParser::Dc_source_analysisContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Dc_source_analysisContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}

std::vector<tree::TerminalNode *> ELDOParser::Dc_source_analysisContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Dc_source_analysisContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Dc_source_analysisContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Dc_source_analysisContext::getRuleIndex() const {
  return ELDOParser::RuleDc_source_analysis;
}

void ELDOParser::Dc_source_analysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDc_source_analysis(this);
}

void ELDOParser::Dc_source_analysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDc_source_analysis(this);
}


std::any ELDOParser::Dc_source_analysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDc_source_analysis(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Dc_source_analysisContext* ELDOParser::dc_source_analysis() {
  Dc_source_analysisContext *_localctx = _tracker.createInstance<Dc_source_analysisContext>(_ctx, getState());
  enterRule(_localctx, 58, ELDOParser::RuleDc_source_analysis);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(567);
    match(ELDOParser::ID);
    setState(569);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(568);
      match(ELDOParser::ID);
    }
    setState(571);
    match(ELDOParser::NUMBER);
    setState(572);
    match(ELDOParser::NUMBER);
    setState(573);
    match(ELDOParser::NUMBER);
    setState(578);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(574);
      match(ELDOParser::ID);
      setState(575);
      match(ELDOParser::NUMBER);
      setState(576);
      match(ELDOParser::NUMBER);
      setState(577);
      match(ELDOParser::NUMBER);
      break;
    }

    default:
      break;
    }
    setState(581);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(580);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dc_temperature_analysisContext ------------------------------------------------------------------

ELDOParser::Dc_temperature_analysisContext::Dc_temperature_analysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Dc_temperature_analysisContext::TEMP() {
  return getToken(ELDOParser::TEMP, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Dc_temperature_analysisContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Dc_temperature_analysisContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Dc_temperature_analysisContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Dc_temperature_analysisContext::getRuleIndex() const {
  return ELDOParser::RuleDc_temperature_analysis;
}

void ELDOParser::Dc_temperature_analysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDc_temperature_analysis(this);
}

void ELDOParser::Dc_temperature_analysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDc_temperature_analysis(this);
}


std::any ELDOParser::Dc_temperature_analysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDc_temperature_analysis(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Dc_temperature_analysisContext* ELDOParser::dc_temperature_analysis() {
  Dc_temperature_analysisContext *_localctx = _tracker.createInstance<Dc_temperature_analysisContext>(_ctx, getState());
  enterRule(_localctx, 60, ELDOParser::RuleDc_temperature_analysis);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(583);
    match(ELDOParser::TEMP);
    setState(584);
    match(ELDOParser::NUMBER);
    setState(585);
    match(ELDOParser::NUMBER);
    setState(586);
    match(ELDOParser::NUMBER);
    setState(588);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(587);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dc_parameter_analysisContext ------------------------------------------------------------------

ELDOParser::Dc_parameter_analysisContext::Dc_parameter_analysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Dc_parameter_analysisContext::PARAM() {
  return getToken(ELDOParser::PARAM, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Dc_parameter_analysisContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Dc_parameter_analysisContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}

std::vector<tree::TerminalNode *> ELDOParser::Dc_parameter_analysisContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Dc_parameter_analysisContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Dc_parameter_analysisContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Dc_parameter_analysisContext::getRuleIndex() const {
  return ELDOParser::RuleDc_parameter_analysis;
}

void ELDOParser::Dc_parameter_analysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDc_parameter_analysis(this);
}

void ELDOParser::Dc_parameter_analysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDc_parameter_analysis(this);
}


std::any ELDOParser::Dc_parameter_analysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDc_parameter_analysis(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Dc_parameter_analysisContext* ELDOParser::dc_parameter_analysis() {
  Dc_parameter_analysisContext *_localctx = _tracker.createInstance<Dc_parameter_analysisContext>(_ctx, getState());
  enterRule(_localctx, 62, ELDOParser::RuleDc_parameter_analysis);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(590);
    match(ELDOParser::PARAM);
    setState(591);
    match(ELDOParser::ID);
    setState(593);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(592);
      match(ELDOParser::ID);
    }
    setState(595);
    match(ELDOParser::NUMBER);
    setState(596);
    match(ELDOParser::NUMBER);
    setState(597);
    match(ELDOParser::NUMBER);
    setState(599);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(598);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dc_data_driven_analysisContext ------------------------------------------------------------------

ELDOParser::Dc_data_driven_analysisContext::Dc_data_driven_analysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::ParameterContext* ELDOParser::Dc_data_driven_analysisContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::Dc_data_driven_analysisContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Dc_data_driven_analysisContext::getRuleIndex() const {
  return ELDOParser::RuleDc_data_driven_analysis;
}

void ELDOParser::Dc_data_driven_analysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDc_data_driven_analysis(this);
}

void ELDOParser::Dc_data_driven_analysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDc_data_driven_analysis(this);
}


std::any ELDOParser::Dc_data_driven_analysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDc_data_driven_analysis(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Dc_data_driven_analysisContext* ELDOParser::dc_data_driven_analysis() {
  Dc_data_driven_analysisContext *_localctx = _tracker.createInstance<Dc_data_driven_analysisContext>(_ctx, getState());
  enterRule(_localctx, 64, ELDOParser::RuleDc_data_driven_analysis);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(601);
    parameter();
    setState(603);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(602);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DchizContext ------------------------------------------------------------------

ELDOParser::DchizContext::DchizContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::DchizContext::DCHIZ() {
  return getToken(ELDOParser::DCHIZ, 0);
}

ELDOParser::ParameterContext* ELDOParser::DchizContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::DchizContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::DchizContext::getRuleIndex() const {
  return ELDOParser::RuleDchiz;
}

void ELDOParser::DchizContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDchiz(this);
}

void ELDOParser::DchizContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDchiz(this);
}


std::any ELDOParser::DchizContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDchiz(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::DchizContext* ELDOParser::dchiz() {
  DchizContext *_localctx = _tracker.createInstance<DchizContext>(_ctx, getState());
  enterRule(_localctx, 66, ELDOParser::RuleDchiz);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(605);
    match(ELDOParser::DCHIZ);
    setState(606);
    parameter();
    setState(607);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DcmismatchContext ------------------------------------------------------------------

ELDOParser::DcmismatchContext::DcmismatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::DcmismatchContext::DCMISMATCH() {
  return getToken(ELDOParser::DCMISMATCH, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::DcmismatchContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::DcmismatchContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::DcmismatchContext::getRuleIndex() const {
  return ELDOParser::RuleDcmismatch;
}

void ELDOParser::DcmismatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcmismatch(this);
}

void ELDOParser::DcmismatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcmismatch(this);
}


std::any ELDOParser::DcmismatchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDcmismatch(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::DcmismatchContext* ELDOParser::dcmismatch() {
  DcmismatchContext *_localctx = _tracker.createInstance<DcmismatchContext>(_ctx, getState());
  enterRule(_localctx, 68, ELDOParser::RuleDcmismatch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(609);
    match(ELDOParser::DCMISMATCH);
    setState(611);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(610);
      parameter_list();
    }
    setState(613);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DexContext ------------------------------------------------------------------

ELDOParser::DexContext::DexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::DexContext::DEX() {
  return getToken(ELDOParser::DEX, 0);
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::DexContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::DexContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}

ELDOParser::End_of_lineContext* ELDOParser::DexContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::DexContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::DexContext::getRuleIndex() const {
  return ELDOParser::RuleDex;
}

void ELDOParser::DexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDex(this);
}

void ELDOParser::DexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDex(this);
}


std::any ELDOParser::DexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDex(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::DexContext* ELDOParser::dex() {
  DexContext *_localctx = _tracker.createInstance<DexContext>(_ctx, getState());
  enterRule(_localctx, 70, ELDOParser::RuleDex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(615);
    match(ELDOParser::DEX);
    setState(616);
    parameter();
    setState(617);
    parameter();
    setState(619);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(618);
      parameter_list();
    }
    setState(621);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DspContext ------------------------------------------------------------------

ELDOParser::DspContext::DspContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::DspContext::DSP() {
  return getToken(ELDOParser::DSP, 0);
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::DspContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::DspContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}

tree::TerminalNode* ELDOParser::DspContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::DspContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::DspContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::DspContext::getRuleIndex() const {
  return ELDOParser::RuleDsp;
}

void ELDOParser::DspContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDsp(this);
}

void ELDOParser::DspContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDsp(this);
}


std::any ELDOParser::DspContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDsp(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::DspContext* ELDOParser::dsp() {
  DspContext *_localctx = _tracker.createInstance<DspContext>(_ctx, getState());
  enterRule(_localctx, 72, ELDOParser::RuleDsp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(623);
    match(ELDOParser::DSP);
    setState(624);
    parameter();
    setState(626);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(625);
      parameter();
      break;
    }

    default:
      break;
    }
    setState(629);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      setState(628);
      parameter();
      break;
    }

    default:
      break;
    }
    setState(631);
    match(ELDOParser::ID);
    setState(633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(632);
      parameter_list();
    }
    setState(635);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DspmodContext ------------------------------------------------------------------

ELDOParser::DspmodContext::DspmodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::DspmodContext::DSPMOD() {
  return getToken(ELDOParser::DSPMOD, 0);
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::DspmodContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::DspmodContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}

ELDOParser::End_of_lineContext* ELDOParser::DspmodContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::DspmodContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::DspmodContext::getRuleIndex() const {
  return ELDOParser::RuleDspmod;
}

void ELDOParser::DspmodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDspmod(this);
}

void ELDOParser::DspmodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDspmod(this);
}


std::any ELDOParser::DspmodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDspmod(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::DspmodContext* ELDOParser::dspmod() {
  DspmodContext *_localctx = _tracker.createInstance<DspmodContext>(_ctx, getState());
  enterRule(_localctx, 74, ELDOParser::RuleDspmod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(637);
    match(ELDOParser::DSPMOD);
    setState(638);
    parameter();
    setState(639);
    parameter();
    setState(641);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(640);
      parameter_list();
    }
    setState(643);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FourContext ------------------------------------------------------------------

ELDOParser::FourContext::FourContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::FourContext::FOUR() {
  return getToken(ELDOParser::FOUR, 0);
}

ELDOParser::ParameterContext* ELDOParser::FourContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}

tree::TerminalNode* ELDOParser::FourContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::FourContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::FourContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::FourContext::getRuleIndex() const {
  return ELDOParser::RuleFour;
}

void ELDOParser::FourContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFour(this);
}

void ELDOParser::FourContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFour(this);
}


std::any ELDOParser::FourContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitFour(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::FourContext* ELDOParser::four() {
  FourContext *_localctx = _tracker.createInstance<FourContext>(_ctx, getState());
  enterRule(_localctx, 76, ELDOParser::RuleFour);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(645);
    match(ELDOParser::FOUR);
    setState(646);
    parameter();
    setState(647);
    match(ELDOParser::ID);
    setState(649);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(648);
      parameter_list();
    }
    setState(651);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LstbContext ------------------------------------------------------------------

ELDOParser::LstbContext::LstbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::LstbContext::LSTB() {
  return getToken(ELDOParser::LSTB, 0);
}

ELDOParser::FilepathContext* ELDOParser::LstbContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::LstbContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::LstbContext::getRuleIndex() const {
  return ELDOParser::RuleLstb;
}

void ELDOParser::LstbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLstb(this);
}

void ELDOParser::LstbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLstb(this);
}


std::any ELDOParser::LstbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLstb(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::LstbContext* ELDOParser::lstb() {
  LstbContext *_localctx = _tracker.createInstance<LstbContext>(_ctx, getState());
  enterRule(_localctx, 78, ELDOParser::RuleLstb);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(653);
    match(ELDOParser::LSTB);
    setState(654);
    filepath();
    setState(655);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- McContext ------------------------------------------------------------------

ELDOParser::McContext::McContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::McContext::MC() {
  return getToken(ELDOParser::MC, 0);
}

tree::TerminalNode* ELDOParser::McContext::NUMBER() {
  return getToken(ELDOParser::NUMBER, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::McContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::McContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::McContext::getRuleIndex() const {
  return ELDOParser::RuleMc;
}

void ELDOParser::McContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMc(this);
}

void ELDOParser::McContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMc(this);
}


std::any ELDOParser::McContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMc(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::McContext* ELDOParser::mc() {
  McContext *_localctx = _tracker.createInstance<McContext>(_ctx, getState());
  enterRule(_localctx, 80, ELDOParser::RuleMc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(657);
    match(ELDOParser::MC);
    setState(658);
    match(ELDOParser::NUMBER);
    setState(660);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(659);
      parameter_list();
    }
    setState(662);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoiseContext ------------------------------------------------------------------

ELDOParser::NoiseContext::NoiseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::NoiseContext::NOISE() {
  return getToken(ELDOParser::NOISE, 0);
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::NoiseContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::NoiseContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}

tree::TerminalNode* ELDOParser::NoiseContext::NUMBER() {
  return getToken(ELDOParser::NUMBER, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::NoiseContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::NoiseContext::getRuleIndex() const {
  return ELDOParser::RuleNoise;
}

void ELDOParser::NoiseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoise(this);
}

void ELDOParser::NoiseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoise(this);
}


std::any ELDOParser::NoiseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNoise(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::NoiseContext* ELDOParser::noise() {
  NoiseContext *_localctx = _tracker.createInstance<NoiseContext>(_ctx, getState());
  enterRule(_localctx, 82, ELDOParser::RuleNoise);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(664);
    match(ELDOParser::NOISE);
    setState(665);
    parameter();
    setState(666);
    parameter();
    setState(667);
    match(ELDOParser::NUMBER);
    setState(668);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoisetranContext ------------------------------------------------------------------

ELDOParser::NoisetranContext::NoisetranContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::NoisetranContext::NOISETRAN() {
  return getToken(ELDOParser::NOISETRAN, 0);
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::NoisetranContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::NoisetranContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}

ELDOParser::End_of_lineContext* ELDOParser::NoisetranContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::NoisetranContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::NoisetranContext::getRuleIndex() const {
  return ELDOParser::RuleNoisetran;
}

void ELDOParser::NoisetranContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoisetran(this);
}

void ELDOParser::NoisetranContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoisetran(this);
}


std::any ELDOParser::NoisetranContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNoisetran(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::NoisetranContext* ELDOParser::noisetran() {
  NoisetranContext *_localctx = _tracker.createInstance<NoisetranContext>(_ctx, getState());
  enterRule(_localctx, 84, ELDOParser::RuleNoisetran);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(670);
    match(ELDOParser::NOISETRAN);
    setState(671);
    parameter();
    setState(672);
    parameter();
    setState(673);
    parameter();
    setState(675);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(674);
      parameter_list();
    }
    setState(677);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpContext ------------------------------------------------------------------

ELDOParser::OpContext::OpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::OpContext::OP() {
  return getToken(ELDOParser::OP, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::OpContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Op_selectiveContext* ELDOParser::OpContext::op_selective() {
  return getRuleContext<ELDOParser::Op_selectiveContext>(0);
}

ELDOParser::Op_time_basedContext* ELDOParser::OpContext::op_time_based() {
  return getRuleContext<ELDOParser::Op_time_basedContext>(0);
}

ELDOParser::Op_dc_basedContext* ELDOParser::OpContext::op_dc_based() {
  return getRuleContext<ELDOParser::Op_dc_basedContext>(0);
}


size_t ELDOParser::OpContext::getRuleIndex() const {
  return ELDOParser::RuleOp;
}

void ELDOParser::OpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp(this);
}

void ELDOParser::OpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp(this);
}


std::any ELDOParser::OpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOp(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::OpContext* ELDOParser::op() {
  OpContext *_localctx = _tracker.createInstance<OpContext>(_ctx, getState());
  enterRule(_localctx, 86, ELDOParser::RuleOp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(679);
    match(ELDOParser::OP);
    setState(683);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      setState(680);
      op_selective();
      break;
    }

    case 2: {
      setState(681);
      op_time_based();
      break;
    }

    case 3: {
      setState(682);
      op_dc_based();
      break;
    }

    default:
      break;
    }
    setState(685);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_selectiveContext ------------------------------------------------------------------

ELDOParser::Op_selectiveContext::Op_selectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::ExpressionContext *> ELDOParser::Op_selectiveContext::expression() {
  return getRuleContexts<ELDOParser::ExpressionContext>();
}

ELDOParser::ExpressionContext* ELDOParser::Op_selectiveContext::expression(size_t i) {
  return getRuleContext<ELDOParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ELDOParser::Op_selectiveContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Op_selectiveContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}


size_t ELDOParser::Op_selectiveContext::getRuleIndex() const {
  return ELDOParser::RuleOp_selective;
}

void ELDOParser::Op_selectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_selective(this);
}

void ELDOParser::Op_selectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_selective(this);
}


std::any ELDOParser::Op_selectiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOp_selective(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Op_selectiveContext* ELDOParser::op_selective() {
  Op_selectiveContext *_localctx = _tracker.createInstance<Op_selectiveContext>(_ctx, getState());
  enterRule(_localctx, 88, ELDOParser::RuleOp_selective);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(693);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL || ((((_la - 138) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 138)) & 1946157227) != 0)) {
      setState(688);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
      case 1: {
        setState(687);
        match(ELDOParser::ID);
        break;
      }

      default:
        break;
      }
      setState(690);
      expression(0);
      setState(695);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_time_basedContext ------------------------------------------------------------------

ELDOParser::Op_time_basedContext::Op_time_basedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::Op_time_basedContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::Op_time_basedContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}


size_t ELDOParser::Op_time_basedContext::getRuleIndex() const {
  return ELDOParser::RuleOp_time_based;
}

void ELDOParser::Op_time_basedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_time_based(this);
}

void ELDOParser::Op_time_basedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_time_based(this);
}


std::any ELDOParser::Op_time_basedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOp_time_based(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Op_time_basedContext* ELDOParser::op_time_based() {
  Op_time_basedContext *_localctx = _tracker.createInstance<Op_time_basedContext>(_ctx, getState());
  enterRule(_localctx, 90, ELDOParser::RuleOp_time_based);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(696);
    parameter();
    setState(698);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      setState(697);
      parameter();
      break;
    }

    default:
      break;
    }
    setState(701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(700);
      parameter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_dc_basedContext ------------------------------------------------------------------

ELDOParser::Op_dc_basedContext::Op_dc_basedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::Op_dc_basedContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::Op_dc_basedContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}


size_t ELDOParser::Op_dc_basedContext::getRuleIndex() const {
  return ELDOParser::RuleOp_dc_based;
}

void ELDOParser::Op_dc_basedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_dc_based(this);
}

void ELDOParser::Op_dc_basedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_dc_based(this);
}


std::any ELDOParser::Op_dc_basedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOp_dc_based(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Op_dc_basedContext* ELDOParser::op_dc_based() {
  Op_dc_basedContext *_localctx = _tracker.createInstance<Op_dc_basedContext>(_ctx, getState());
  enterRule(_localctx, 92, ELDOParser::RuleOp_dc_based);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    parameter();
    setState(705);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      setState(704);
      parameter();
      break;
    }

    default:
      break;
    }
    setState(708);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(707);
      parameter();
      break;
    }

    default:
      break;
    }
    setState(711);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(710);
      parameter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptfourContext ------------------------------------------------------------------

ELDOParser::OptfourContext::OptfourContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::OptfourContext::OPTFOUR() {
  return getToken(ELDOParser::OPTFOUR, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::OptfourContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::OptfourContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::OptfourContext::getRuleIndex() const {
  return ELDOParser::RuleOptfour;
}

void ELDOParser::OptfourContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptfour(this);
}

void ELDOParser::OptfourContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptfour(this);
}


std::any ELDOParser::OptfourContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOptfour(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::OptfourContext* ELDOParser::optfour() {
  OptfourContext *_localctx = _tracker.createInstance<OptfourContext>(_ctx, getState());
  enterRule(_localctx, 94, ELDOParser::RuleOptfour);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(713);
    match(ELDOParser::OPTFOUR);
    setState(715);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(714);
      parameter_list();
    }
    setState(717);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptimizeContext ------------------------------------------------------------------

ELDOParser::OptimizeContext::OptimizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::OptimizeContext::OPTIMIZE() {
  return getToken(ELDOParser::OPTIMIZE, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::OptimizeContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::OptimizeContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::OptimizeContext::getRuleIndex() const {
  return ELDOParser::RuleOptimize;
}

void ELDOParser::OptimizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptimize(this);
}

void ELDOParser::OptimizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptimize(this);
}


std::any ELDOParser::OptimizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOptimize(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::OptimizeContext* ELDOParser::optimize() {
  OptimizeContext *_localctx = _tracker.createInstance<OptimizeContext>(_ctx, getState());
  enterRule(_localctx, 96, ELDOParser::RuleOptimize);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(719);
    match(ELDOParser::OPTIMIZE);
    setState(721);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(720);
      parameter_list();
    }
    setState(723);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptnoiseContext ------------------------------------------------------------------

ELDOParser::OptnoiseContext::OptnoiseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::OptnoiseContext::OPTNOISE() {
  return getToken(ELDOParser::OPTNOISE, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::OptnoiseContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::OptnoiseContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::OptnoiseContext::getRuleIndex() const {
  return ELDOParser::RuleOptnoise;
}

void ELDOParser::OptnoiseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptnoise(this);
}

void ELDOParser::OptnoiseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptnoise(this);
}


std::any ELDOParser::OptnoiseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOptnoise(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::OptnoiseContext* ELDOParser::optnoise() {
  OptnoiseContext *_localctx = _tracker.createInstance<OptnoiseContext>(_ctx, getState());
  enterRule(_localctx, 98, ELDOParser::RuleOptnoise);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(725);
    match(ELDOParser::OPTNOISE);
    setState(727);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(726);
      parameter_list();
    }
    setState(729);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PzContext ------------------------------------------------------------------

ELDOParser::PzContext::PzContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::PzContext::PZ() {
  return getToken(ELDOParser::PZ, 0);
}

ELDOParser::FilepathContext* ELDOParser::PzContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::PzContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::PzContext::getRuleIndex() const {
  return ELDOParser::RulePz;
}

void ELDOParser::PzContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPz(this);
}

void ELDOParser::PzContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPz(this);
}


std::any ELDOParser::PzContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitPz(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::PzContext* ELDOParser::pz() {
  PzContext *_localctx = _tracker.createInstance<PzContext>(_ctx, getState());
  enterRule(_localctx, 100, ELDOParser::RulePz);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(731);
    match(ELDOParser::PZ);
    setState(732);
    filepath();
    setState(733);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RampContext ------------------------------------------------------------------

ELDOParser::RampContext::RampContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::RampContext::RAMP() {
  return getToken(ELDOParser::RAMP, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::RampContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::RampContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}

std::vector<tree::TerminalNode *> ELDOParser::RampContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::RampContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::End_of_lineContext* ELDOParser::RampContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::RampContext::getRuleIndex() const {
  return ELDOParser::RuleRamp;
}

void ELDOParser::RampContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRamp(this);
}

void ELDOParser::RampContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRamp(this);
}


std::any ELDOParser::RampContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitRamp(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::RampContext* ELDOParser::ramp() {
  RampContext *_localctx = _tracker.createInstance<RampContext>(_ctx, getState());
  enterRule(_localctx, 102, ELDOParser::RuleRamp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(735);
    match(ELDOParser::RAMP);
    setState(736);
    match(ELDOParser::ID);
    setState(737);
    match(ELDOParser::NUMBER);
    setState(739);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::NUMBER) {
      setState(738);
      match(ELDOParser::NUMBER);
    }
    setState(742);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(741);
      match(ELDOParser::ID);
    }
    setState(744);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SensContext ------------------------------------------------------------------

ELDOParser::SensContext::SensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::SensContext::SENS() {
  return getToken(ELDOParser::SENS, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::SensContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::SensContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::SensContext::getRuleIndex() const {
  return ELDOParser::RuleSens;
}

void ELDOParser::SensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSens(this);
}

void ELDOParser::SensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSens(this);
}


std::any ELDOParser::SensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSens(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::SensContext* ELDOParser::sens() {
  SensContext *_localctx = _tracker.createInstance<SensContext>(_ctx, getState());
  enterRule(_localctx, 104, ELDOParser::RuleSens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(746);
    match(ELDOParser::SENS);
    setState(747);
    parameter_list();
    setState(748);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SensacContext ------------------------------------------------------------------

ELDOParser::SensacContext::SensacContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::SensacContext::SENSAC() {
  return getToken(ELDOParser::SENSAC, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::SensacContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::SensacContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::SensacContext::getRuleIndex() const {
  return ELDOParser::RuleSensac;
}

void ELDOParser::SensacContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSensac(this);
}

void ELDOParser::SensacContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSensac(this);
}


std::any ELDOParser::SensacContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSensac(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::SensacContext* ELDOParser::sensac() {
  SensacContext *_localctx = _tracker.createInstance<SensacContext>(_ctx, getState());
  enterRule(_localctx, 106, ELDOParser::RuleSensac);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(750);
    match(ELDOParser::SENSAC);
    setState(751);
    parameter_list();
    setState(752);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SensparamContext ------------------------------------------------------------------

ELDOParser::SensparamContext::SensparamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::SensparamContext::SENSPARAM() {
  return getToken(ELDOParser::SENSPARAM, 0);
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::SensparamContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::SensparamContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}

ELDOParser::End_of_lineContext* ELDOParser::SensparamContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::SensparamContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::SensparamContext::getRuleIndex() const {
  return ELDOParser::RuleSensparam;
}

void ELDOParser::SensparamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSensparam(this);
}

void ELDOParser::SensparamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSensparam(this);
}


std::any ELDOParser::SensparamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSensparam(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::SensparamContext* ELDOParser::sensparam() {
  SensparamContext *_localctx = _tracker.createInstance<SensparamContext>(_ctx, getState());
  enterRule(_localctx, 108, ELDOParser::RuleSensparam);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(754);
    match(ELDOParser::SENSPARAM);
    setState(755);
    parameter();
    setState(756);
    parameter();
    setState(758);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(757);
      parameter_list();
    }
    setState(760);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnfContext ------------------------------------------------------------------

ELDOParser::SnfContext::SnfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::SnfContext::SNF() {
  return getToken(ELDOParser::SNF, 0);
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::SnfContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::SnfContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}

ELDOParser::End_of_lineContext* ELDOParser::SnfContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::SnfContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::SnfContext::getRuleIndex() const {
  return ELDOParser::RuleSnf;
}

void ELDOParser::SnfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnf(this);
}

void ELDOParser::SnfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnf(this);
}


std::any ELDOParser::SnfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSnf(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::SnfContext* ELDOParser::snf() {
  SnfContext *_localctx = _tracker.createInstance<SnfContext>(_ctx, getState());
  enterRule(_localctx, 110, ELDOParser::RuleSnf);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(762);
    match(ELDOParser::SNF);
    setState(763);
    parameter();
    setState(764);
    parameter();
    setState(766);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(765);
      parameter_list();
    }
    setState(768);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SolveContext ------------------------------------------------------------------

ELDOParser::SolveContext::SolveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::SolveContext::SOLVE() {
  return getToken(ELDOParser::SOLVE, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::SolveContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Solve_parameterContext* ELDOParser::SolveContext::solve_parameter() {
  return getRuleContext<ELDOParser::Solve_parameterContext>(0);
}

ELDOParser::Solve_objectContext* ELDOParser::SolveContext::solve_object() {
  return getRuleContext<ELDOParser::Solve_objectContext>(0);
}

ELDOParser::Solve_componentContext* ELDOParser::SolveContext::solve_component() {
  return getRuleContext<ELDOParser::Solve_componentContext>(0);
}


size_t ELDOParser::SolveContext::getRuleIndex() const {
  return ELDOParser::RuleSolve;
}

void ELDOParser::SolveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSolve(this);
}

void ELDOParser::SolveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSolve(this);
}


std::any ELDOParser::SolveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSolve(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::SolveContext* ELDOParser::solve() {
  SolveContext *_localctx = _tracker.createInstance<SolveContext>(_ctx, getState());
  enterRule(_localctx, 112, ELDOParser::RuleSolve);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(770);
    match(ELDOParser::SOLVE);
    setState(774);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(771);
      solve_parameter();
      break;
    }

    case 2: {
      setState(772);
      solve_object();
      break;
    }

    case 3: {
      setState(773);
      solve_component();
      break;
    }

    default:
      break;
    }
    setState(776);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Solve_parameterContext ------------------------------------------------------------------

ELDOParser::Solve_parameterContext::Solve_parameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Solve_parameterContext::PARAM() {
  return getToken(ELDOParser::PARAM, 0);
}

tree::TerminalNode* ELDOParser::Solve_parameterContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Solve_parameterContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Solve_parameterContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Solve_parameterContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Solve_parameterContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::Solve_parameterContext::getRuleIndex() const {
  return ELDOParser::RuleSolve_parameter;
}

void ELDOParser::Solve_parameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSolve_parameter(this);
}

void ELDOParser::Solve_parameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSolve_parameter(this);
}


std::any ELDOParser::Solve_parameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSolve_parameter(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Solve_parameterContext* ELDOParser::solve_parameter() {
  Solve_parameterContext *_localctx = _tracker.createInstance<Solve_parameterContext>(_ctx, getState());
  enterRule(_localctx, 114, ELDOParser::RuleSolve_parameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(778);
    match(ELDOParser::PARAM);
    setState(779);
    match(ELDOParser::ID);
    setState(780);
    match(ELDOParser::NUMBER);
    setState(781);
    match(ELDOParser::NUMBER);
    setState(782);
    parameter_list();
    setState(783);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Solve_objectContext ------------------------------------------------------------------

ELDOParser::Solve_objectContext::Solve_objectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Solve_objectContext::PARAM() {
  return getToken(ELDOParser::PARAM, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Solve_objectContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Solve_objectContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}

std::vector<tree::TerminalNode *> ELDOParser::Solve_objectContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Solve_objectContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Solve_objectContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Solve_objectContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::Solve_objectContext::getRuleIndex() const {
  return ELDOParser::RuleSolve_object;
}

void ELDOParser::Solve_objectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSolve_object(this);
}

void ELDOParser::Solve_objectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSolve_object(this);
}


std::any ELDOParser::Solve_objectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSolve_object(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Solve_objectContext* ELDOParser::solve_object() {
  Solve_objectContext *_localctx = _tracker.createInstance<Solve_objectContext>(_ctx, getState());
  enterRule(_localctx, 116, ELDOParser::RuleSolve_object);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(785);
    match(ELDOParser::PARAM);
    setState(786);
    match(ELDOParser::ID);
    setState(788);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(787);
      match(ELDOParser::ID);
    }
    setState(790);
    match(ELDOParser::NUMBER);
    setState(791);
    match(ELDOParser::NUMBER);
    setState(792);
    parameter_list();
    setState(793);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Solve_componentContext ------------------------------------------------------------------

ELDOParser::Solve_componentContext::Solve_componentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Solve_componentContext::PARAM() {
  return getToken(ELDOParser::PARAM, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Solve_componentContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Solve_componentContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}

std::vector<tree::TerminalNode *> ELDOParser::Solve_componentContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Solve_componentContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Solve_componentContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Solve_componentContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::Solve_componentContext::getRuleIndex() const {
  return ELDOParser::RuleSolve_component;
}

void ELDOParser::Solve_componentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSolve_component(this);
}

void ELDOParser::Solve_componentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSolve_component(this);
}


std::any ELDOParser::Solve_componentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSolve_component(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Solve_componentContext* ELDOParser::solve_component() {
  Solve_componentContext *_localctx = _tracker.createInstance<Solve_componentContext>(_ctx, getState());
  enterRule(_localctx, 118, ELDOParser::RuleSolve_component);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    match(ELDOParser::PARAM);
    setState(796);
    match(ELDOParser::ID);
    setState(798);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(797);
      match(ELDOParser::ID);
    }
    setState(800);
    match(ELDOParser::NUMBER);
    setState(801);
    match(ELDOParser::NUMBER);
    setState(802);
    parameter_list();
    setState(803);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TfContext ------------------------------------------------------------------

ELDOParser::TfContext::TfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::TfContext::TF() {
  return getToken(ELDOParser::TF, 0);
}

std::vector<ELDOParser::ParameterContext *> ELDOParser::TfContext::parameter() {
  return getRuleContexts<ELDOParser::ParameterContext>();
}

ELDOParser::ParameterContext* ELDOParser::TfContext::parameter(size_t i) {
  return getRuleContext<ELDOParser::ParameterContext>(i);
}

ELDOParser::End_of_lineContext* ELDOParser::TfContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::TfContext::getRuleIndex() const {
  return ELDOParser::RuleTf;
}

void ELDOParser::TfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTf(this);
}

void ELDOParser::TfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTf(this);
}


std::any ELDOParser::TfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitTf(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::TfContext* ELDOParser::tf() {
  TfContext *_localctx = _tracker.createInstance<TfContext>(_ctx, getState());
  enterRule(_localctx, 120, ELDOParser::RuleTf);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(805);
    match(ELDOParser::TF);
    setState(806);
    parameter();
    setState(807);
    parameter();
    setState(808);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TranContext ------------------------------------------------------------------

ELDOParser::TranContext::TranContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::TranContext::TRAN() {
  return getToken(ELDOParser::TRAN, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::TranContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Tran_point_drivenContext* ELDOParser::TranContext::tran_point_driven() {
  return getRuleContext<ELDOParser::Tran_point_drivenContext>(0);
}

ELDOParser::Tran_parameterizedContext* ELDOParser::TranContext::tran_parameterized() {
  return getRuleContext<ELDOParser::Tran_parameterizedContext>(0);
}

ELDOParser::Tran_data_drivenContext* ELDOParser::TranContext::tran_data_driven() {
  return getRuleContext<ELDOParser::Tran_data_drivenContext>(0);
}


size_t ELDOParser::TranContext::getRuleIndex() const {
  return ELDOParser::RuleTran;
}

void ELDOParser::TranContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTran(this);
}

void ELDOParser::TranContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTran(this);
}


std::any ELDOParser::TranContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitTran(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::TranContext* ELDOParser::tran() {
  TranContext *_localctx = _tracker.createInstance<TranContext>(_ctx, getState());
  enterRule(_localctx, 122, ELDOParser::RuleTran);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(810);
    match(ELDOParser::TRAN);
    setState(814);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      setState(811);
      tran_point_driven();
      break;
    }

    case 2: {
      setState(812);
      tran_parameterized();
      break;
    }

    case 3: {
      setState(813);
      tran_data_driven();
      break;
    }

    default:
      break;
    }
    setState(816);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tran_point_drivenContext ------------------------------------------------------------------

ELDOParser::Tran_point_drivenContext::Tran_point_drivenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> ELDOParser::Tran_point_drivenContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Tran_point_drivenContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}

ELDOParser::Parameter_listContext* ELDOParser::Tran_point_drivenContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Tran_point_drivenContext::getRuleIndex() const {
  return ELDOParser::RuleTran_point_driven;
}

void ELDOParser::Tran_point_drivenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTran_point_driven(this);
}

void ELDOParser::Tran_point_drivenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTran_point_driven(this);
}


std::any ELDOParser::Tran_point_drivenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitTran_point_driven(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Tran_point_drivenContext* ELDOParser::tran_point_driven() {
  Tran_point_drivenContext *_localctx = _tracker.createInstance<Tran_point_drivenContext>(_ctx, getState());
  enterRule(_localctx, 124, ELDOParser::RuleTran_point_driven);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(818);
    match(ELDOParser::NUMBER);
    setState(819);
    match(ELDOParser::NUMBER);
    setState(824);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::NUMBER) {
      setState(820);
      match(ELDOParser::NUMBER);
      setState(822);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ELDOParser::NUMBER) {
        setState(821);
        match(ELDOParser::NUMBER);
      }
    }
    setState(827);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(826);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tran_parameterizedContext ------------------------------------------------------------------

ELDOParser::Tran_parameterizedContext::Tran_parameterizedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::ExpressionContext *> ELDOParser::Tran_parameterizedContext::expression() {
  return getRuleContexts<ELDOParser::ExpressionContext>();
}

ELDOParser::ExpressionContext* ELDOParser::Tran_parameterizedContext::expression(size_t i) {
  return getRuleContext<ELDOParser::ExpressionContext>(i);
}

ELDOParser::Parameter_listContext* ELDOParser::Tran_parameterizedContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Tran_parameterizedContext::getRuleIndex() const {
  return ELDOParser::RuleTran_parameterized;
}

void ELDOParser::Tran_parameterizedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTran_parameterized(this);
}

void ELDOParser::Tran_parameterizedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTran_parameterized(this);
}


std::any ELDOParser::Tran_parameterizedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitTran_parameterized(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Tran_parameterizedContext* ELDOParser::tran_parameterized() {
  Tran_parameterizedContext *_localctx = _tracker.createInstance<Tran_parameterizedContext>(_ctx, getState());
  enterRule(_localctx, 126, ELDOParser::RuleTran_parameterized);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(832); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(829);
              expression(0);
              setState(830);
              expression(0);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(834); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(837);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(836);
      parameter_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tran_data_drivenContext ------------------------------------------------------------------

ELDOParser::Tran_data_drivenContext::Tran_data_drivenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Parameter_listContext* ELDOParser::Tran_data_drivenContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Tran_data_drivenContext::getRuleIndex() const {
  return ELDOParser::RuleTran_data_driven;
}

void ELDOParser::Tran_data_drivenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTran_data_driven(this);
}

void ELDOParser::Tran_data_drivenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTran_data_driven(this);
}


std::any ELDOParser::Tran_data_drivenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitTran_data_driven(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Tran_data_drivenContext* ELDOParser::tran_data_driven() {
  Tran_data_drivenContext *_localctx = _tracker.createInstance<Tran_data_drivenContext>(_ctx, getState());
  enterRule(_localctx, 128, ELDOParser::RuleTran_data_driven);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(839);
    parameter_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WcaseContext ------------------------------------------------------------------

ELDOParser::WcaseContext::WcaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::WcaseContext::WCASE() {
  return getToken(ELDOParser::WCASE, 0);
}

tree::TerminalNode* ELDOParser::WcaseContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::WcaseContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::WcaseContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::WcaseContext::getRuleIndex() const {
  return ELDOParser::RuleWcase;
}

void ELDOParser::WcaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWcase(this);
}

void ELDOParser::WcaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWcase(this);
}


std::any ELDOParser::WcaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitWcase(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::WcaseContext* ELDOParser::wcase() {
  WcaseContext *_localctx = _tracker.createInstance<WcaseContext>(_ctx, getState());
  enterRule(_localctx, 130, ELDOParser::RuleWcase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(841);
    match(ELDOParser::WCASE);
    setState(842);
    match(ELDOParser::ID);
    setState(844);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(843);
      parameter_list();
    }
    setState(846);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExtractContext ------------------------------------------------------------------

ELDOParser::ExtractContext::ExtractContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::ExtractContext::EXTRACT() {
  return getToken(ELDOParser::EXTRACT, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::ExtractContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::ExtractContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::ExtractContext::getRuleIndex() const {
  return ELDOParser::RuleExtract;
}

void ELDOParser::ExtractContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtract(this);
}

void ELDOParser::ExtractContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtract(this);
}


std::any ELDOParser::ExtractContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitExtract(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ExtractContext* ELDOParser::extract() {
  ExtractContext *_localctx = _tracker.createInstance<ExtractContext>(_ctx, getState());
  enterRule(_localctx, 132, ELDOParser::RuleExtract);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(848);
    match(ELDOParser::EXTRACT);
    setState(850);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(849);
      parameter_list();
    }
    setState(852);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GlobalContext ------------------------------------------------------------------

ELDOParser::GlobalContext::GlobalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::GlobalContext::GLOBAL() {
  return getToken(ELDOParser::GLOBAL, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::GlobalContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Node_listContext* ELDOParser::GlobalContext::node_list() {
  return getRuleContext<ELDOParser::Node_listContext>(0);
}


size_t ELDOParser::GlobalContext::getRuleIndex() const {
  return ELDOParser::RuleGlobal;
}

void ELDOParser::GlobalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal(this);
}

void ELDOParser::GlobalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal(this);
}


std::any ELDOParser::GlobalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitGlobal(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::GlobalContext* ELDOParser::global() {
  GlobalContext *_localctx = _tracker.createInstance<GlobalContext>(_ctx, getState());
  enterRule(_localctx, 134, ELDOParser::RuleGlobal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(854);
    match(ELDOParser::GLOBAL);
    setState(856);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 100663297) != 0)) {
      setState(855);
      node_list();
    }
    setState(858);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModelContext ------------------------------------------------------------------

ELDOParser::ModelContext::ModelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::ModelContext::MODEL_DEF() {
  return getToken(ELDOParser::MODEL_DEF, 0);
}

ELDOParser::Model_nameContext* ELDOParser::ModelContext::model_name() {
  return getRuleContext<ELDOParser::Model_nameContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::ModelContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Model_masterContext* ELDOParser::ModelContext::model_master() {
  return getRuleContext<ELDOParser::Model_masterContext>(0);
}

tree::TerminalNode* ELDOParser::ModelContext::NONOISE() {
  return getToken(ELDOParser::NONOISE, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::ModelContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::Model_libContext* ELDOParser::ModelContext::model_lib() {
  return getRuleContext<ELDOParser::Model_libContext>(0);
}

ELDOParser::FilepathContext* ELDOParser::ModelContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

ELDOParser::Model_lib_typeContext* ELDOParser::ModelContext::model_lib_type() {
  return getRuleContext<ELDOParser::Model_lib_typeContext>(0);
}


size_t ELDOParser::ModelContext::getRuleIndex() const {
  return ELDOParser::RuleModel;
}

void ELDOParser::ModelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel(this);
}

void ELDOParser::ModelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel(this);
}


std::any ELDOParser::ModelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitModel(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ModelContext* ELDOParser::model() {
  ModelContext *_localctx = _tracker.createInstance<ModelContext>(_ctx, getState());
  enterRule(_localctx, 136, ELDOParser::RuleModel);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(882);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(860);
      match(ELDOParser::MODEL_DEF);
      setState(861);
      model_name();
      setState(863);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
      case 1: {
        setState(862);
        model_master();
        break;
      }

      default:
        break;
      }
      setState(866);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ELDOParser::NONOISE) {
        setState(865);
        match(ELDOParser::NONOISE);
      }
      setState(869);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 67108885) != 0)) {
        setState(868);
        parameter_list();
      }
      setState(871);
      end_of_line();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(873);
      match(ELDOParser::MODEL_DEF);
      setState(874);
      model_lib();
      setState(875);
      filepath();
      setState(876);
      model_name();
      setState(878);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ELDOParser::ID) {
        setState(877);
        model_lib_type();
      }
      setState(880);
      end_of_line();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_libContext ------------------------------------------------------------------

ELDOParser::Model_libContext::Model_libContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Model_libContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Model_libContext::getRuleIndex() const {
  return ELDOParser::RuleModel_lib;
}

void ELDOParser::Model_libContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_lib(this);
}

void ELDOParser::Model_libContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_lib(this);
}


std::any ELDOParser::Model_libContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitModel_lib(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Model_libContext* ELDOParser::model_lib() {
  Model_libContext *_localctx = _tracker.createInstance<Model_libContext>(_ctx, getState());
  enterRule(_localctx, 138, ELDOParser::RuleModel_lib);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(884);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_nameContext ------------------------------------------------------------------

ELDOParser::Model_nameContext::Model_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Model_nameContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Model_nameContext::getRuleIndex() const {
  return ELDOParser::RuleModel_name;
}

void ELDOParser::Model_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_name(this);
}

void ELDOParser::Model_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_name(this);
}


std::any ELDOParser::Model_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitModel_name(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Model_nameContext* ELDOParser::model_name() {
  Model_nameContext *_localctx = _tracker.createInstance<Model_nameContext>(_ctx, getState());
  enterRule(_localctx, 140, ELDOParser::RuleModel_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(886);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_masterContext ------------------------------------------------------------------

ELDOParser::Model_masterContext::Model_masterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Model_masterContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Model_masterContext::getRuleIndex() const {
  return ELDOParser::RuleModel_master;
}

void ELDOParser::Model_masterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_master(this);
}

void ELDOParser::Model_masterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_master(this);
}


std::any ELDOParser::Model_masterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitModel_master(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Model_masterContext* ELDOParser::model_master() {
  Model_masterContext *_localctx = _tracker.createInstance<Model_masterContext>(_ctx, getState());
  enterRule(_localctx, 142, ELDOParser::RuleModel_master);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(888);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_lib_typeContext ------------------------------------------------------------------

ELDOParser::Model_lib_typeContext::Model_lib_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Model_lib_typeContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Model_lib_typeContext::getRuleIndex() const {
  return ELDOParser::RuleModel_lib_type;
}

void ELDOParser::Model_lib_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_lib_type(this);
}

void ELDOParser::Model_lib_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_lib_type(this);
}


std::any ELDOParser::Model_lib_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitModel_lib_type(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Model_lib_typeContext* ELDOParser::model_lib_type() {
  Model_lib_typeContext *_localctx = _tracker.createInstance<Model_lib_typeContext>(_ctx, getState());
  enterRule(_localctx, 144, ELDOParser::RuleModel_lib_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(890);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ControlContext ------------------------------------------------------------------

ELDOParser::ControlContext::ControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::AlterContext* ELDOParser::ControlContext::alter() {
  return getRuleContext<ELDOParser::AlterContext>(0);
}

ELDOParser::SaveContext* ELDOParser::ControlContext::save() {
  return getRuleContext<ELDOParser::SaveContext>(0);
}

ELDOParser::OptionContext* ELDOParser::ControlContext::option() {
  return getRuleContext<ELDOParser::OptionContext>(0);
}

ELDOParser::NodesetContext* ELDOParser::ControlContext::nodeset() {
  return getRuleContext<ELDOParser::NodesetContext>(0);
}

ELDOParser::Call_tclContext* ELDOParser::ControlContext::call_tcl() {
  return getRuleContext<ELDOParser::Call_tclContext>(0);
}

ELDOParser::Use_tclContext* ELDOParser::ControlContext::use_tcl() {
  return getRuleContext<ELDOParser::Use_tclContext>(0);
}

ELDOParser::DefmacContext* ELDOParser::ControlContext::defmac() {
  return getRuleContext<ELDOParser::DefmacContext>(0);
}

ELDOParser::ChrentContext* ELDOParser::ControlContext::chrent() {
  return getRuleContext<ELDOParser::ChrentContext>(0);
}

ELDOParser::IcContext* ELDOParser::ControlContext::ic() {
  return getRuleContext<ELDOParser::IcContext>(0);
}

ELDOParser::PrintContext* ELDOParser::ControlContext::print() {
  return getRuleContext<ELDOParser::PrintContext>(0);
}

ELDOParser::PlotContext* ELDOParser::ControlContext::plot() {
  return getRuleContext<ELDOParser::PlotContext>(0);
}

ELDOParser::FfileContext* ELDOParser::ControlContext::ffile() {
  return getRuleContext<ELDOParser::FfileContext>(0);
}

ELDOParser::ProbeContext* ELDOParser::ControlContext::probe() {
  return getRuleContext<ELDOParser::ProbeContext>(0);
}

ELDOParser::DefwaveContext* ELDOParser::ControlContext::defwave() {
  return getRuleContext<ELDOParser::DefwaveContext>(0);
}

ELDOParser::TempContext* ELDOParser::ControlContext::temp() {
  return getRuleContext<ELDOParser::TempContext>(0);
}

ELDOParser::MeasContext* ELDOParser::ControlContext::meas() {
  return getRuleContext<ELDOParser::MeasContext>(0);
}

ELDOParser::ConnectContext* ELDOParser::ControlContext::connect() {
  return getRuleContext<ELDOParser::ConnectContext>(0);
}


size_t ELDOParser::ControlContext::getRuleIndex() const {
  return ELDOParser::RuleControl;
}

void ELDOParser::ControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterControl(this);
}

void ELDOParser::ControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitControl(this);
}


std::any ELDOParser::ControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitControl(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ControlContext* ELDOParser::control() {
  ControlContext *_localctx = _tracker.createInstance<ControlContext>(_ctx, getState());
  enterRule(_localctx, 146, ELDOParser::RuleControl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(909);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ELDOParser::ALTER: {
        enterOuterAlt(_localctx, 1);
        setState(892);
        alter();
        break;
      }

      case ELDOParser::SAVE: {
        enterOuterAlt(_localctx, 2);
        setState(893);
        save();
        break;
      }

      case ELDOParser::OPTION:
      case ELDOParser::OPT: {
        enterOuterAlt(_localctx, 3);
        setState(894);
        option();
        break;
      }

      case ELDOParser::NODESET: {
        enterOuterAlt(_localctx, 4);
        setState(895);
        nodeset();
        break;
      }

      case ELDOParser::CALL_TCL: {
        enterOuterAlt(_localctx, 5);
        setState(896);
        call_tcl();
        break;
      }

      case ELDOParser::USE_TCL: {
        enterOuterAlt(_localctx, 6);
        setState(897);
        use_tcl();
        break;
      }

      case ELDOParser::DEFMAC: {
        enterOuterAlt(_localctx, 7);
        setState(898);
        defmac();
        break;
      }

      case ELDOParser::CHRENT: {
        enterOuterAlt(_localctx, 8);
        setState(899);
        chrent();
        break;
      }

      case ELDOParser::IC: {
        enterOuterAlt(_localctx, 9);
        setState(900);
        ic();
        break;
      }

      case ELDOParser::PRINT: {
        enterOuterAlt(_localctx, 10);
        setState(901);
        print();
        break;
      }

      case ELDOParser::PLOT: {
        enterOuterAlt(_localctx, 11);
        setState(902);
        plot();
        break;
      }

      case ELDOParser::FFILE: {
        enterOuterAlt(_localctx, 12);
        setState(903);
        ffile();
        break;
      }

      case ELDOParser::PROBE: {
        enterOuterAlt(_localctx, 13);
        setState(904);
        probe();
        break;
      }

      case ELDOParser::DEFWAVE: {
        enterOuterAlt(_localctx, 14);
        setState(905);
        defwave();
        break;
      }

      case ELDOParser::TEMP_SET: {
        enterOuterAlt(_localctx, 15);
        setState(906);
        temp();
        break;
      }

      case ELDOParser::MEAS: {
        enterOuterAlt(_localctx, 16);
        setState(907);
        meas();
        break;
      }

      case ELDOParser::CONNECT: {
        enterOuterAlt(_localctx, 17);
        setState(908);
        connect();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterContext ------------------------------------------------------------------

ELDOParser::AlterContext::AlterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Alter_footerContext* ELDOParser::AlterContext::alter_footer() {
  return getRuleContext<ELDOParser::Alter_footerContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::AlterContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

std::vector<ELDOParser::Alter_definitionContext *> ELDOParser::AlterContext::alter_definition() {
  return getRuleContexts<ELDOParser::Alter_definitionContext>();
}

ELDOParser::Alter_definitionContext* ELDOParser::AlterContext::alter_definition(size_t i) {
  return getRuleContext<ELDOParser::Alter_definitionContext>(i);
}


size_t ELDOParser::AlterContext::getRuleIndex() const {
  return ELDOParser::RuleAlter;
}

void ELDOParser::AlterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter(this);
}

void ELDOParser::AlterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter(this);
}


std::any ELDOParser::AlterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAlter(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::AlterContext* ELDOParser::alter() {
  AlterContext *_localctx = _tracker.createInstance<AlterContext>(_ctx, getState());
  enterRule(_localctx, 148, ELDOParser::RuleAlter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(912); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(911);
      alter_definition();
      setState(914); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ELDOParser::ALTER);
    setState(916);
    alter_footer();
    setState(917);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_definitionContext ------------------------------------------------------------------

ELDOParser::Alter_definitionContext::Alter_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Alter_headerContext* ELDOParser::Alter_definitionContext::alter_header() {
  return getRuleContext<ELDOParser::Alter_headerContext>(0);
}

std::vector<ELDOParser::Alter_contentContext *> ELDOParser::Alter_definitionContext::alter_content() {
  return getRuleContexts<ELDOParser::Alter_contentContext>();
}

ELDOParser::Alter_contentContext* ELDOParser::Alter_definitionContext::alter_content(size_t i) {
  return getRuleContext<ELDOParser::Alter_contentContext>(i);
}


size_t ELDOParser::Alter_definitionContext::getRuleIndex() const {
  return ELDOParser::RuleAlter_definition;
}

void ELDOParser::Alter_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_definition(this);
}

void ELDOParser::Alter_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_definition(this);
}


std::any ELDOParser::Alter_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAlter_definition(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Alter_definitionContext* ELDOParser::alter_definition() {
  Alter_definitionContext *_localctx = _tracker.createInstance<Alter_definitionContext>(_ctx, getState());
  enterRule(_localctx, 150, ELDOParser::RuleAlter_definition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(919);
    alter_header();
    setState(921); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(920);
              alter_content();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(923); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_headerContext ------------------------------------------------------------------

ELDOParser::Alter_headerContext::Alter_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Alter_headerContext::ALTER() {
  return getToken(ELDOParser::ALTER, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::Alter_headerContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

std::vector<tree::TerminalNode *> ELDOParser::Alter_headerContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Alter_headerContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}


size_t ELDOParser::Alter_headerContext::getRuleIndex() const {
  return ELDOParser::RuleAlter_header;
}

void ELDOParser::Alter_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_header(this);
}

void ELDOParser::Alter_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_header(this);
}


std::any ELDOParser::Alter_headerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAlter_header(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Alter_headerContext* ELDOParser::alter_header() {
  Alter_headerContext *_localctx = _tracker.createInstance<Alter_headerContext>(_ctx, getState());
  enterRule(_localctx, 152, ELDOParser::RuleAlter_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(925);
    match(ELDOParser::ALTER);
    setState(929);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ELDOParser::ID) {
      setState(926);
      match(ELDOParser::ID);
      setState(931);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(932);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_contentContext ------------------------------------------------------------------

ELDOParser::Alter_contentContext::Alter_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Netlist_entityContext* ELDOParser::Alter_contentContext::netlist_entity() {
  return getRuleContext<ELDOParser::Netlist_entityContext>(0);
}


size_t ELDOParser::Alter_contentContext::getRuleIndex() const {
  return ELDOParser::RuleAlter_content;
}

void ELDOParser::Alter_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_content(this);
}

void ELDOParser::Alter_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_content(this);
}


std::any ELDOParser::Alter_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAlter_content(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Alter_contentContext* ELDOParser::alter_content() {
  Alter_contentContext *_localctx = _tracker.createInstance<Alter_contentContext>(_ctx, getState());
  enterRule(_localctx, 154, ELDOParser::RuleAlter_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(934);
    netlist_entity();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_footerContext ------------------------------------------------------------------

ELDOParser::Alter_footerContext::Alter_footerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Alter_footerContext::NETLIST_END() {
  return getToken(ELDOParser::NETLIST_END, 0);
}


size_t ELDOParser::Alter_footerContext::getRuleIndex() const {
  return ELDOParser::RuleAlter_footer;
}

void ELDOParser::Alter_footerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_footer(this);
}

void ELDOParser::Alter_footerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_footer(this);
}


std::any ELDOParser::Alter_footerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitAlter_footer(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Alter_footerContext* ELDOParser::alter_footer() {
  Alter_footerContext *_localctx = _tracker.createInstance<Alter_footerContext>(_ctx, getState());
  enterRule(_localctx, 156, ELDOParser::RuleAlter_footer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(936);
    match(ELDOParser::NETLIST_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SaveContext ------------------------------------------------------------------

ELDOParser::SaveContext::SaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::SaveContext::SAVE() {
  return getToken(ELDOParser::SAVE, 0);
}

ELDOParser::Save_whenContext* ELDOParser::SaveContext::save_when() {
  return getRuleContext<ELDOParser::Save_whenContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::SaveContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Save_fileContext* ELDOParser::SaveContext::save_file() {
  return getRuleContext<ELDOParser::Save_fileContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::SaveContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::SaveContext::getRuleIndex() const {
  return ELDOParser::RuleSave;
}

void ELDOParser::SaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSave(this);
}

void ELDOParser::SaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSave(this);
}


std::any ELDOParser::SaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSave(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::SaveContext* ELDOParser::save() {
  SaveContext *_localctx = _tracker.createInstance<SaveContext>(_ctx, getState());
  enterRule(_localctx, 158, ELDOParser::RuleSave);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(938);
    match(ELDOParser::SAVE);
    setState(940);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(939);
      save_file();
      break;
    }

    default:
      break;
    }
    setState(942);
    save_when();
    setState(944);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(943);
      parameter_list();
    }
    setState(946);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Save_fileContext ------------------------------------------------------------------

ELDOParser::Save_fileContext::Save_fileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::FilepathContext* ELDOParser::Save_fileContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

tree::TerminalNode* ELDOParser::Save_fileContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::Save_fileContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}


size_t ELDOParser::Save_fileContext::getRuleIndex() const {
  return ELDOParser::RuleSave_file;
}

void ELDOParser::Save_fileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSave_file(this);
}

void ELDOParser::Save_fileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSave_file(this);
}


std::any ELDOParser::Save_fileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSave_file(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Save_fileContext* ELDOParser::save_file() {
  Save_fileContext *_localctx = _tracker.createInstance<Save_fileContext>(_ctx, getState());
  enterRule(_localctx, 160, ELDOParser::RuleSave_file);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(950);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      setState(948);
      match(ELDOParser::ID);
      setState(949);
      match(ELDOParser::EQUAL);
      break;
    }

    default:
      break;
    }
    setState(952);
    filepath();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Save_whenContext ------------------------------------------------------------------

ELDOParser::Save_whenContext::Save_whenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Save_whenContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

ELDOParser::ParameterContext* ELDOParser::Save_whenContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}


size_t ELDOParser::Save_whenContext::getRuleIndex() const {
  return ELDOParser::RuleSave_when;
}

void ELDOParser::Save_whenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSave_when(this);
}

void ELDOParser::Save_whenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSave_when(this);
}


std::any ELDOParser::Save_whenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSave_when(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Save_whenContext* ELDOParser::save_when() {
  Save_whenContext *_localctx = _tracker.createInstance<Save_whenContext>(_ctx, getState());
  enterRule(_localctx, 162, ELDOParser::RuleSave_when);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(956);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(954);
      match(ELDOParser::ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(955);
      parameter();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionContext ------------------------------------------------------------------

ELDOParser::OptionContext::OptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Parameter_listContext* ELDOParser::OptionContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::OptionContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

tree::TerminalNode* ELDOParser::OptionContext::OPTION() {
  return getToken(ELDOParser::OPTION, 0);
}

tree::TerminalNode* ELDOParser::OptionContext::OPT() {
  return getToken(ELDOParser::OPT, 0);
}


size_t ELDOParser::OptionContext::getRuleIndex() const {
  return ELDOParser::RuleOption;
}

void ELDOParser::OptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOption(this);
}

void ELDOParser::OptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOption(this);
}


std::any ELDOParser::OptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOption(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::OptionContext* ELDOParser::option() {
  OptionContext *_localctx = _tracker.createInstance<OptionContext>(_ctx, getState());
  enterRule(_localctx, 164, ELDOParser::RuleOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(958);
    _la = _input->LA(1);
    if (!(_la == ELDOParser::OPTION

    || _la == ELDOParser::OPT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(959);
    parameter_list();
    setState(960);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NodesetContext ------------------------------------------------------------------

ELDOParser::NodesetContext::NodesetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::NodesetContext::NODESET() {
  return getToken(ELDOParser::NODESET, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::NodesetContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::NodesetContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::NodesetContext::getRuleIndex() const {
  return ELDOParser::RuleNodeset;
}

void ELDOParser::NodesetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNodeset(this);
}

void ELDOParser::NodesetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNodeset(this);
}


std::any ELDOParser::NodesetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNodeset(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::NodesetContext* ELDOParser::nodeset() {
  NodesetContext *_localctx = _tracker.createInstance<NodesetContext>(_ctx, getState());
  enterRule(_localctx, 166, ELDOParser::RuleNodeset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(962);
    match(ELDOParser::NODESET);
    setState(963);
    parameter_list();
    setState(964);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_tclContext ------------------------------------------------------------------

ELDOParser::Call_tclContext::Call_tclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Call_tclContext::CALL_TCL() {
  return getToken(ELDOParser::CALL_TCL, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::Call_tclContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

std::vector<tree::TerminalNode *> ELDOParser::Call_tclContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Call_tclContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}

ELDOParser::Call_tcl_whenContext* ELDOParser::Call_tclContext::call_tcl_when() {
  return getRuleContext<ELDOParser::Call_tcl_whenContext>(0);
}

ELDOParser::Parameter_listContext* ELDOParser::Call_tclContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::ExpressionContext* ELDOParser::Call_tclContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}


size_t ELDOParser::Call_tclContext::getRuleIndex() const {
  return ELDOParser::RuleCall_tcl;
}

void ELDOParser::Call_tclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_tcl(this);
}

void ELDOParser::Call_tclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_tcl(this);
}


std::any ELDOParser::Call_tclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitCall_tcl(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Call_tclContext* ELDOParser::call_tcl() {
  Call_tclContext *_localctx = _tracker.createInstance<Call_tclContext>(_ctx, getState());
  enterRule(_localctx, 168, ELDOParser::RuleCall_tcl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(966);
    match(ELDOParser::CALL_TCL);
    setState(968);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(967);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(971);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::WHEN) {
      setState(970);
      call_tcl_when();
    }
    setState(974);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
    case 1: {
      setState(973);
      parameter_list();
      break;
    }

    default:
      break;
    }
    setState(977);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      setState(976);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(980);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(979);
      match(ELDOParser::ID);
    }
    setState(982);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_tcl_whenContext ------------------------------------------------------------------

ELDOParser::Call_tcl_whenContext::Call_tcl_whenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Call_tcl_whenContext::WHEN() {
  return getToken(ELDOParser::WHEN, 0);
}

tree::TerminalNode* ELDOParser::Call_tcl_whenContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Call_tcl_whenContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Call_tcl_whenContext::getRuleIndex() const {
  return ELDOParser::RuleCall_tcl_when;
}

void ELDOParser::Call_tcl_whenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_tcl_when(this);
}

void ELDOParser::Call_tcl_whenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_tcl_when(this);
}


std::any ELDOParser::Call_tcl_whenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitCall_tcl_when(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Call_tcl_whenContext* ELDOParser::call_tcl_when() {
  Call_tcl_whenContext *_localctx = _tracker.createInstance<Call_tcl_whenContext>(_ctx, getState());
  enterRule(_localctx, 170, ELDOParser::RuleCall_tcl_when);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(984);
    match(ELDOParser::WHEN);
    setState(985);
    match(ELDOParser::EQUAL);
    setState(986);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_tclContext ------------------------------------------------------------------

ELDOParser::Use_tclContext::Use_tclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Use_tclContext::USE_TCL() {
  return getToken(ELDOParser::USE_TCL, 0);
}

ELDOParser::FilepathContext* ELDOParser::Use_tclContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Use_tclContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::Use_tclContext::getRuleIndex() const {
  return ELDOParser::RuleUse_tcl;
}

void ELDOParser::Use_tclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUse_tcl(this);
}

void ELDOParser::Use_tclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUse_tcl(this);
}


std::any ELDOParser::Use_tclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitUse_tcl(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Use_tclContext* ELDOParser::use_tcl() {
  Use_tclContext *_localctx = _tracker.createInstance<Use_tclContext>(_ctx, getState());
  enterRule(_localctx, 172, ELDOParser::RuleUse_tcl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(988);
    match(ELDOParser::USE_TCL);
    setState(989);
    filepath();
    setState(990);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefmacContext ------------------------------------------------------------------

ELDOParser::DefmacContext::DefmacContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::DefmacContext::DEFMAC() {
  return getToken(ELDOParser::DEFMAC, 0);
}

ELDOParser::ParameterContext* ELDOParser::DefmacContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::DefmacContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::DefmacContext::getRuleIndex() const {
  return ELDOParser::RuleDefmac;
}

void ELDOParser::DefmacContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefmac(this);
}

void ELDOParser::DefmacContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefmac(this);
}


std::any ELDOParser::DefmacContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDefmac(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::DefmacContext* ELDOParser::defmac() {
  DefmacContext *_localctx = _tracker.createInstance<DefmacContext>(_ctx, getState());
  enterRule(_localctx, 174, ELDOParser::RuleDefmac);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(992);
    match(ELDOParser::DEFMAC);
    setState(993);
    parameter();
    setState(994);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChrentContext ------------------------------------------------------------------

ELDOParser::ChrentContext::ChrentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::ChrentContext::CHRENT() {
  return getToken(ELDOParser::CHRENT, 0);
}

ELDOParser::NodeContext* ELDOParser::ChrentContext::node() {
  return getRuleContext<ELDOParser::NodeContext>(0);
}

ELDOParser::Chrent_behaviourContext* ELDOParser::ChrentContext::chrent_behaviour() {
  return getRuleContext<ELDOParser::Chrent_behaviourContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::ChrentContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

tree::TerminalNode* ELDOParser::ChrentContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::ChrentContext::getRuleIndex() const {
  return ELDOParser::RuleChrent;
}

void ELDOParser::ChrentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChrent(this);
}

void ELDOParser::ChrentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChrent(this);
}


std::any ELDOParser::ChrentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitChrent(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ChrentContext* ELDOParser::chrent() {
  ChrentContext *_localctx = _tracker.createInstance<ChrentContext>(_ctx, getState());
  enterRule(_localctx, 176, ELDOParser::RuleChrent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(996);
    match(ELDOParser::CHRENT);
    setState(997);
    node();
    setState(998);
    chrent_behaviour();
    setState(1000);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(999);
      match(ELDOParser::ID);
    }
    setState(1002);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chrent_behaviourContext ------------------------------------------------------------------

ELDOParser::Chrent_behaviourContext::Chrent_behaviourContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::Chrent_pointContext *> ELDOParser::Chrent_behaviourContext::chrent_point() {
  return getRuleContexts<ELDOParser::Chrent_pointContext>();
}

ELDOParser::Chrent_pointContext* ELDOParser::Chrent_behaviourContext::chrent_point(size_t i) {
  return getRuleContext<ELDOParser::Chrent_pointContext>(i);
}


size_t ELDOParser::Chrent_behaviourContext::getRuleIndex() const {
  return ELDOParser::RuleChrent_behaviour;
}

void ELDOParser::Chrent_behaviourContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChrent_behaviour(this);
}

void ELDOParser::Chrent_behaviourContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChrent_behaviour(this);
}


std::any ELDOParser::Chrent_behaviourContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitChrent_behaviour(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Chrent_behaviourContext* ELDOParser::chrent_behaviour() {
  Chrent_behaviourContext *_localctx = _tracker.createInstance<Chrent_behaviourContext>(_ctx, getState());
  enterRule(_localctx, 178, ELDOParser::RuleChrent_behaviour);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1005); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1004);
      chrent_point();
      setState(1007); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ELDOParser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chrent_pointContext ------------------------------------------------------------------

ELDOParser::Chrent_pointContext::Chrent_pointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::Chrent_pairContext *> ELDOParser::Chrent_pointContext::chrent_pair() {
  return getRuleContexts<ELDOParser::Chrent_pairContext>();
}

ELDOParser::Chrent_pairContext* ELDOParser::Chrent_pointContext::chrent_pair(size_t i) {
  return getRuleContext<ELDOParser::Chrent_pairContext>(i);
}

tree::TerminalNode* ELDOParser::Chrent_pointContext::NUMBER() {
  return getToken(ELDOParser::NUMBER, 0);
}


size_t ELDOParser::Chrent_pointContext::getRuleIndex() const {
  return ELDOParser::RuleChrent_point;
}

void ELDOParser::Chrent_pointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChrent_point(this);
}

void ELDOParser::Chrent_pointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChrent_point(this);
}


std::any ELDOParser::Chrent_pointContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitChrent_point(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Chrent_pointContext* ELDOParser::chrent_point() {
  Chrent_pointContext *_localctx = _tracker.createInstance<Chrent_pointContext>(_ctx, getState());
  enterRule(_localctx, 180, ELDOParser::RuleChrent_point);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1010); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1009);
              chrent_pair();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1012); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(1015);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(1014);
      match(ELDOParser::NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chrent_pairContext ------------------------------------------------------------------

ELDOParser::Chrent_pairContext::Chrent_pairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> ELDOParser::Chrent_pairContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::Chrent_pairContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}


size_t ELDOParser::Chrent_pairContext::getRuleIndex() const {
  return ELDOParser::RuleChrent_pair;
}

void ELDOParser::Chrent_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChrent_pair(this);
}

void ELDOParser::Chrent_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChrent_pair(this);
}


std::any ELDOParser::Chrent_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitChrent_pair(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Chrent_pairContext* ELDOParser::chrent_pair() {
  Chrent_pairContext *_localctx = _tracker.createInstance<Chrent_pairContext>(_ctx, getState());
  enterRule(_localctx, 182, ELDOParser::RuleChrent_pair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1017);
    match(ELDOParser::NUMBER);
    setState(1018);
    match(ELDOParser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IcContext ------------------------------------------------------------------

ELDOParser::IcContext::IcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::IcContext::IC() {
  return getToken(ELDOParser::IC, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::IcContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

std::vector<ELDOParser::Ic_contentContext *> ELDOParser::IcContext::ic_content() {
  return getRuleContexts<ELDOParser::Ic_contentContext>();
}

ELDOParser::Ic_contentContext* ELDOParser::IcContext::ic_content(size_t i) {
  return getRuleContext<ELDOParser::Ic_contentContext>(i);
}


size_t ELDOParser::IcContext::getRuleIndex() const {
  return ELDOParser::RuleIc;
}

void ELDOParser::IcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIc(this);
}

void ELDOParser::IcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIc(this);
}


std::any ELDOParser::IcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitIc(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::IcContext* ELDOParser::ic() {
  IcContext *_localctx = _tracker.createInstance<IcContext>(_ctx, getState());
  enterRule(_localctx, 184, ELDOParser::RuleIc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1020);
    match(ELDOParser::IC);
    setState(1022); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1021);
      ic_content();
      setState(1024); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0));
    setState(1026);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ic_contentContext ------------------------------------------------------------------

ELDOParser::Ic_contentContext::Ic_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::ParameterContext* ELDOParser::Ic_contentContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}

ELDOParser::Ic_subcktContext* ELDOParser::Ic_contentContext::ic_subckt() {
  return getRuleContext<ELDOParser::Ic_subcktContext>(0);
}


size_t ELDOParser::Ic_contentContext::getRuleIndex() const {
  return ELDOParser::RuleIc_content;
}

void ELDOParser::Ic_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIc_content(this);
}

void ELDOParser::Ic_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIc_content(this);
}


std::any ELDOParser::Ic_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitIc_content(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ic_contentContext* ELDOParser::ic_content() {
  Ic_contentContext *_localctx = _tracker.createInstance<Ic_contentContext>(_ctx, getState());
  enterRule(_localctx, 186, ELDOParser::RuleIc_content);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1028);
    parameter();
    setState(1030);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {
    case 1: {
      setState(1029);
      ic_subckt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ic_subcktContext ------------------------------------------------------------------

ELDOParser::Ic_subcktContext::Ic_subcktContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ic_subcktContext::SUBCKT() {
  return getToken(ELDOParser::SUBCKT, 0);
}

tree::TerminalNode* ELDOParser::Ic_subcktContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Ic_subcktContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Ic_subcktContext::getRuleIndex() const {
  return ELDOParser::RuleIc_subckt;
}

void ELDOParser::Ic_subcktContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIc_subckt(this);
}

void ELDOParser::Ic_subcktContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIc_subckt(this);
}


std::any ELDOParser::Ic_subcktContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitIc_subckt(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ic_subcktContext* ELDOParser::ic_subckt() {
  Ic_subcktContext *_localctx = _tracker.createInstance<Ic_subcktContext>(_ctx, getState());
  enterRule(_localctx, 188, ELDOParser::RuleIc_subckt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1032);
    match(ELDOParser::SUBCKT);
    setState(1033);
    match(ELDOParser::EQUAL);
    setState(1034);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrintContext ------------------------------------------------------------------

ELDOParser::PrintContext::PrintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::PrintContext::PRINT() {
  return getToken(ELDOParser::PRINT, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::PrintContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::PrintContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

tree::TerminalNode* ELDOParser::PrintContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::PrintContext::getRuleIndex() const {
  return ELDOParser::RulePrint;
}

void ELDOParser::PrintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrint(this);
}

void ELDOParser::PrintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrint(this);
}


std::any ELDOParser::PrintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitPrint(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::PrintContext* ELDOParser::print() {
  PrintContext *_localctx = _tracker.createInstance<PrintContext>(_ctx, getState());
  enterRule(_localctx, 190, ELDOParser::RulePrint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1036);
    match(ELDOParser::PRINT);
    setState(1038);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      setState(1037);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(1040);
    parameter_list();
    setState(1041);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PlotContext ------------------------------------------------------------------

ELDOParser::PlotContext::PlotContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::PlotContext::PLOT() {
  return getToken(ELDOParser::PLOT, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::PlotContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::PlotContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

tree::TerminalNode* ELDOParser::PlotContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::PlotContext::getRuleIndex() const {
  return ELDOParser::RulePlot;
}

void ELDOParser::PlotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlot(this);
}

void ELDOParser::PlotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlot(this);
}


std::any ELDOParser::PlotContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitPlot(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::PlotContext* ELDOParser::plot() {
  PlotContext *_localctx = _tracker.createInstance<PlotContext>(_ctx, getState());
  enterRule(_localctx, 192, ELDOParser::RulePlot);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1043);
    match(ELDOParser::PLOT);
    setState(1045);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      setState(1044);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(1047);
    parameter_list();
    setState(1048);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FfileContext ------------------------------------------------------------------

ELDOParser::FfileContext::FfileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::FfileContext::FFILE() {
  return getToken(ELDOParser::FFILE, 0);
}

ELDOParser::Ffile_tabulationContext* ELDOParser::FfileContext::ffile_tabulation() {
  return getRuleContext<ELDOParser::Ffile_tabulationContext>(0);
}

ELDOParser::FilepathContext* ELDOParser::FfileContext::filepath() {
  return getRuleContext<ELDOParser::FilepathContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::FfileContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Ffile_singlelineContext* ELDOParser::FfileContext::ffile_singleline() {
  return getRuleContext<ELDOParser::Ffile_singlelineContext>(0);
}

ELDOParser::Ffile_unitContext* ELDOParser::FfileContext::ffile_unit() {
  return getRuleContext<ELDOParser::Ffile_unitContext>(0);
}

ELDOParser::Ffile_storage_formatContext* ELDOParser::FfileContext::ffile_storage_format() {
  return getRuleContext<ELDOParser::Ffile_storage_formatContext>(0);
}


size_t ELDOParser::FfileContext::getRuleIndex() const {
  return ELDOParser::RuleFfile;
}

void ELDOParser::FfileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFfile(this);
}

void ELDOParser::FfileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFfile(this);
}


std::any ELDOParser::FfileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitFfile(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::FfileContext* ELDOParser::ffile() {
  FfileContext *_localctx = _tracker.createInstance<FfileContext>(_ctx, getState());
  enterRule(_localctx, 194, ELDOParser::RuleFfile);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1050);
    match(ELDOParser::FFILE);
    setState(1051);
    ffile_tabulation();
    setState(1053);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
    case 1: {
      setState(1052);
      ffile_singleline();
      break;
    }

    default:
      break;
    }
    setState(1055);
    filepath();
    setState(1057);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      setState(1056);
      ffile_unit();
      break;
    }

    default:
      break;
    }
    setState(1060);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::ID) {
      setState(1059);
      ffile_storage_format();
    }
    setState(1062);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ffile_tabulationContext ------------------------------------------------------------------

ELDOParser::Ffile_tabulationContext::Ffile_tabulationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ffile_tabulationContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Ffile_tabulationContext::getRuleIndex() const {
  return ELDOParser::RuleFfile_tabulation;
}

void ELDOParser::Ffile_tabulationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFfile_tabulation(this);
}

void ELDOParser::Ffile_tabulationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFfile_tabulation(this);
}


std::any ELDOParser::Ffile_tabulationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitFfile_tabulation(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ffile_tabulationContext* ELDOParser::ffile_tabulation() {
  Ffile_tabulationContext *_localctx = _tracker.createInstance<Ffile_tabulationContext>(_ctx, getState());
  enterRule(_localctx, 196, ELDOParser::RuleFfile_tabulation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1064);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ffile_singlelineContext ------------------------------------------------------------------

ELDOParser::Ffile_singlelineContext::Ffile_singlelineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ffile_singlelineContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Ffile_singlelineContext::getRuleIndex() const {
  return ELDOParser::RuleFfile_singleline;
}

void ELDOParser::Ffile_singlelineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFfile_singleline(this);
}

void ELDOParser::Ffile_singlelineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFfile_singleline(this);
}


std::any ELDOParser::Ffile_singlelineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitFfile_singleline(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ffile_singlelineContext* ELDOParser::ffile_singleline() {
  Ffile_singlelineContext *_localctx = _tracker.createInstance<Ffile_singlelineContext>(_ctx, getState());
  enterRule(_localctx, 198, ELDOParser::RuleFfile_singleline);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1066);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ffile_unitContext ------------------------------------------------------------------

ELDOParser::Ffile_unitContext::Ffile_unitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ffile_unitContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Ffile_unitContext::getRuleIndex() const {
  return ELDOParser::RuleFfile_unit;
}

void ELDOParser::Ffile_unitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFfile_unit(this);
}

void ELDOParser::Ffile_unitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFfile_unit(this);
}


std::any ELDOParser::Ffile_unitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitFfile_unit(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ffile_unitContext* ELDOParser::ffile_unit() {
  Ffile_unitContext *_localctx = _tracker.createInstance<Ffile_unitContext>(_ctx, getState());
  enterRule(_localctx, 200, ELDOParser::RuleFfile_unit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1068);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ffile_storage_formatContext ------------------------------------------------------------------

ELDOParser::Ffile_storage_formatContext::Ffile_storage_formatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ffile_storage_formatContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Ffile_storage_formatContext::getRuleIndex() const {
  return ELDOParser::RuleFfile_storage_format;
}

void ELDOParser::Ffile_storage_formatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFfile_storage_format(this);
}

void ELDOParser::Ffile_storage_formatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFfile_storage_format(this);
}


std::any ELDOParser::Ffile_storage_formatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitFfile_storage_format(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ffile_storage_formatContext* ELDOParser::ffile_storage_format() {
  Ffile_storage_formatContext *_localctx = _tracker.createInstance<Ffile_storage_formatContext>(_ctx, getState());
  enterRule(_localctx, 202, ELDOParser::RuleFfile_storage_format);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1070);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProbeContext ------------------------------------------------------------------

ELDOParser::ProbeContext::ProbeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::ProbeContext::PROBE() {
  return getToken(ELDOParser::PROBE, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::ProbeContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

tree::TerminalNode* ELDOParser::ProbeContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::ProbeContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::ProbeContext::getRuleIndex() const {
  return ELDOParser::RuleProbe;
}

void ELDOParser::ProbeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProbe(this);
}

void ELDOParser::ProbeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProbe(this);
}


std::any ELDOParser::ProbeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitProbe(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ProbeContext* ELDOParser::probe() {
  ProbeContext *_localctx = _tracker.createInstance<ProbeContext>(_ctx, getState());
  enterRule(_localctx, 204, ELDOParser::RuleProbe);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1072);
    match(ELDOParser::PROBE);
    setState(1074);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      setState(1073);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(1077);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(1076);
      parameter_list();
    }
    setState(1079);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefwaveContext ------------------------------------------------------------------

ELDOParser::DefwaveContext::DefwaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::DefwaveContext::DEFWAVE() {
  return getToken(ELDOParser::DEFWAVE, 0);
}

ELDOParser::ParameterContext* ELDOParser::DefwaveContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::DefwaveContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

std::vector<tree::TerminalNode *> ELDOParser::DefwaveContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::DefwaveContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}


size_t ELDOParser::DefwaveContext::getRuleIndex() const {
  return ELDOParser::RuleDefwave;
}

void ELDOParser::DefwaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefwave(this);
}

void ELDOParser::DefwaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefwave(this);
}


std::any ELDOParser::DefwaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDefwave(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::DefwaveContext* ELDOParser::defwave() {
  DefwaveContext *_localctx = _tracker.createInstance<DefwaveContext>(_ctx, getState());
  enterRule(_localctx, 206, ELDOParser::RuleDefwave);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1081);
    match(ELDOParser::DEFWAVE);
    setState(1083);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      setState(1082);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(1086);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      setState(1085);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(1088);
    parameter();
    setState(1089);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TempContext ------------------------------------------------------------------

ELDOParser::TempContext::TempContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::TempContext::TEMP_SET() {
  return getToken(ELDOParser::TEMP_SET, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::TempContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

std::vector<tree::TerminalNode *> ELDOParser::TempContext::NUMBER() {
  return getTokens(ELDOParser::NUMBER);
}

tree::TerminalNode* ELDOParser::TempContext::NUMBER(size_t i) {
  return getToken(ELDOParser::NUMBER, i);
}


size_t ELDOParser::TempContext::getRuleIndex() const {
  return ELDOParser::RuleTemp;
}

void ELDOParser::TempContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemp(this);
}

void ELDOParser::TempContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemp(this);
}


std::any ELDOParser::TempContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitTemp(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::TempContext* ELDOParser::temp() {
  TempContext *_localctx = _tracker.createInstance<TempContext>(_ctx, getState());
  enterRule(_localctx, 208, ELDOParser::RuleTemp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1091);
    match(ELDOParser::TEMP_SET);
    setState(1093); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1092);
      match(ELDOParser::NUMBER);
      setState(1095); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ELDOParser::NUMBER);
    setState(1097);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MeasContext ------------------------------------------------------------------

ELDOParser::MeasContext::MeasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::MeasContext::MEAS() {
  return getToken(ELDOParser::MEAS, 0);
}

ELDOParser::Meas_label_nameContext* ELDOParser::MeasContext::meas_label_name() {
  return getRuleContext<ELDOParser::Meas_label_nameContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::MeasContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

ELDOParser::Meas_infoContext* ELDOParser::MeasContext::meas_info() {
  return getRuleContext<ELDOParser::Meas_infoContext>(0);
}

ELDOParser::Meas_vectContext* ELDOParser::MeasContext::meas_vect() {
  return getRuleContext<ELDOParser::Meas_vectContext>(0);
}

ELDOParser::Meas_catvectContext* ELDOParser::MeasContext::meas_catvect() {
  return getRuleContext<ELDOParser::Meas_catvectContext>(0);
}

std::vector<ELDOParser::Meas_configurationContext *> ELDOParser::MeasContext::meas_configuration() {
  return getRuleContexts<ELDOParser::Meas_configurationContext>();
}

ELDOParser::Meas_configurationContext* ELDOParser::MeasContext::meas_configuration(size_t i) {
  return getRuleContext<ELDOParser::Meas_configurationContext>(i);
}

ELDOParser::Parameter_listContext* ELDOParser::MeasContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::MeasContext::getRuleIndex() const {
  return ELDOParser::RuleMeas;
}

void ELDOParser::MeasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas(this);
}

void ELDOParser::MeasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas(this);
}


std::any ELDOParser::MeasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::MeasContext* ELDOParser::meas() {
  MeasContext *_localctx = _tracker.createInstance<MeasContext>(_ctx, getState());
  enterRule(_localctx, 210, ELDOParser::RuleMeas);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1099);
    match(ELDOParser::MEAS);
    setState(1101);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
    case 1: {
      setState(1100);
      meas_info();
      break;
    }

    default:
      break;
    }
    setState(1104);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::VECT) {
      setState(1103);
      meas_vect();
    }
    setState(1107);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::CATVECT) {
      setState(1106);
      meas_catvect();
    }
    setState(1109);
    meas_label_name();
    setState(1111); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1110);
      meas_configuration();
      setState(1113); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1882366054236160) != 0));
    setState(1116);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 9020393394274304) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 67108885) != 0)) {
      setState(1115);
      parameter_list();
    }
    setState(1118);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_infoContext ------------------------------------------------------------------

ELDOParser::Meas_infoContext::Meas_infoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_infoContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Meas_infoContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_info;
}

void ELDOParser::Meas_infoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_info(this);
}

void ELDOParser::Meas_infoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_info(this);
}


std::any ELDOParser::Meas_infoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_info(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_infoContext* ELDOParser::meas_info() {
  Meas_infoContext *_localctx = _tracker.createInstance<Meas_infoContext>(_ctx, getState());
  enterRule(_localctx, 212, ELDOParser::RuleMeas_info);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1120);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_vectContext ------------------------------------------------------------------

ELDOParser::Meas_vectContext::Meas_vectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_vectContext::VECT() {
  return getToken(ELDOParser::VECT, 0);
}


size_t ELDOParser::Meas_vectContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_vect;
}

void ELDOParser::Meas_vectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_vect(this);
}

void ELDOParser::Meas_vectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_vect(this);
}


std::any ELDOParser::Meas_vectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_vect(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_vectContext* ELDOParser::meas_vect() {
  Meas_vectContext *_localctx = _tracker.createInstance<Meas_vectContext>(_ctx, getState());
  enterRule(_localctx, 214, ELDOParser::RuleMeas_vect);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1122);
    match(ELDOParser::VECT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_catvectContext ------------------------------------------------------------------

ELDOParser::Meas_catvectContext::Meas_catvectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_catvectContext::CATVECT() {
  return getToken(ELDOParser::CATVECT, 0);
}


size_t ELDOParser::Meas_catvectContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_catvect;
}

void ELDOParser::Meas_catvectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_catvect(this);
}

void ELDOParser::Meas_catvectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_catvect(this);
}


std::any ELDOParser::Meas_catvectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_catvect(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_catvectContext* ELDOParser::meas_catvect() {
  Meas_catvectContext *_localctx = _tracker.createInstance<Meas_catvectContext>(_ctx, getState());
  enterRule(_localctx, 216, ELDOParser::RuleMeas_catvect);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1124);
    match(ELDOParser::CATVECT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_label_nameContext ------------------------------------------------------------------

ELDOParser::Meas_label_nameContext::Meas_label_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_label_nameContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Meas_label_nameContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_label_name;
}

void ELDOParser::Meas_label_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_label_name(this);
}

void ELDOParser::Meas_label_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_label_name(this);
}


std::any ELDOParser::Meas_label_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_label_name(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_label_nameContext* ELDOParser::meas_label_name() {
  Meas_label_nameContext *_localctx = _tracker.createInstance<Meas_label_nameContext>(_ctx, getState());
  enterRule(_localctx, 218, ELDOParser::RuleMeas_label_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1126);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_configurationContext ------------------------------------------------------------------

ELDOParser::Meas_configurationContext::Meas_configurationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Meas_findContext* ELDOParser::Meas_configurationContext::meas_find() {
  return getRuleContext<ELDOParser::Meas_findContext>(0);
}

ELDOParser::Meas_atContext* ELDOParser::Meas_configurationContext::meas_at() {
  return getRuleContext<ELDOParser::Meas_atContext>(0);
}

ELDOParser::Meas_whenContext* ELDOParser::Meas_configurationContext::meas_when() {
  return getRuleContext<ELDOParser::Meas_whenContext>(0);
}

ELDOParser::Meas_derivativeContext* ELDOParser::Meas_configurationContext::meas_derivative() {
  return getRuleContext<ELDOParser::Meas_derivativeContext>(0);
}

ELDOParser::Meas_paramContext* ELDOParser::Meas_configurationContext::meas_param() {
  return getRuleContext<ELDOParser::Meas_paramContext>(0);
}

ELDOParser::Meas_trigContext* ELDOParser::Meas_configurationContext::meas_trig() {
  return getRuleContext<ELDOParser::Meas_trigContext>(0);
}

ELDOParser::Meas_targContext* ELDOParser::Meas_configurationContext::meas_targ() {
  return getRuleContext<ELDOParser::Meas_targContext>(0);
}


size_t ELDOParser::Meas_configurationContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_configuration;
}

void ELDOParser::Meas_configurationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_configuration(this);
}

void ELDOParser::Meas_configurationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_configuration(this);
}


std::any ELDOParser::Meas_configurationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_configuration(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_configurationContext* ELDOParser::meas_configuration() {
  Meas_configurationContext *_localctx = _tracker.createInstance<Meas_configurationContext>(_ctx, getState());
  enterRule(_localctx, 220, ELDOParser::RuleMeas_configuration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1136);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ELDOParser::FIND: {
        enterOuterAlt(_localctx, 1);
        setState(1128);
        meas_find();
        break;
      }

      case ELDOParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(1129);
        meas_at();
        break;
      }

      case ELDOParser::WHEN: {
        enterOuterAlt(_localctx, 3);
        setState(1130);
        meas_when();
        break;
      }

      case ELDOParser::DERIVATIVE: {
        enterOuterAlt(_localctx, 4);
        setState(1131);
        meas_derivative();
        break;
      }

      case ELDOParser::PARAM: {
        enterOuterAlt(_localctx, 5);
        setState(1132);
        meas_param();
        break;
      }

      case ELDOParser::TRIG: {
        enterOuterAlt(_localctx, 6);
        setState(1133);
        meas_trig();
        setState(1134);
        meas_targ();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_findContext ------------------------------------------------------------------

ELDOParser::Meas_findContext::Meas_findContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_findContext::FIND() {
  return getToken(ELDOParser::FIND, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Meas_findContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}


size_t ELDOParser::Meas_findContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_find;
}

void ELDOParser::Meas_findContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_find(this);
}

void ELDOParser::Meas_findContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_find(this);
}


std::any ELDOParser::Meas_findContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_find(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_findContext* ELDOParser::meas_find() {
  Meas_findContext *_localctx = _tracker.createInstance<Meas_findContext>(_ctx, getState());
  enterRule(_localctx, 222, ELDOParser::RuleMeas_find);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1138);
    match(ELDOParser::FIND);
    setState(1139);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_atContext ------------------------------------------------------------------

ELDOParser::Meas_atContext::Meas_atContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_atContext::AT() {
  return getToken(ELDOParser::AT, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Meas_atContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}

tree::TerminalNode* ELDOParser::Meas_atContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}


size_t ELDOParser::Meas_atContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_at;
}

void ELDOParser::Meas_atContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_at(this);
}

void ELDOParser::Meas_atContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_at(this);
}


std::any ELDOParser::Meas_atContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_at(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_atContext* ELDOParser::meas_at() {
  Meas_atContext *_localctx = _tracker.createInstance<Meas_atContext>(_ctx, getState());
  enterRule(_localctx, 224, ELDOParser::RuleMeas_at);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1141);
    match(ELDOParser::AT);
    setState(1143);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::EQUAL) {
      setState(1142);
      match(ELDOParser::EQUAL);
    }
    setState(1145);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_whenContext ------------------------------------------------------------------

ELDOParser::Meas_whenContext::Meas_whenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_whenContext::WHEN() {
  return getToken(ELDOParser::WHEN, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Meas_whenContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}


size_t ELDOParser::Meas_whenContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_when;
}

void ELDOParser::Meas_whenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_when(this);
}

void ELDOParser::Meas_whenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_when(this);
}


std::any ELDOParser::Meas_whenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_when(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_whenContext* ELDOParser::meas_when() {
  Meas_whenContext *_localctx = _tracker.createInstance<Meas_whenContext>(_ctx, getState());
  enterRule(_localctx, 226, ELDOParser::RuleMeas_when);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1147);
    match(ELDOParser::WHEN);
    setState(1148);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_derivativeContext ------------------------------------------------------------------

ELDOParser::Meas_derivativeContext::Meas_derivativeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_derivativeContext::DERIVATIVE() {
  return getToken(ELDOParser::DERIVATIVE, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Meas_derivativeContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}


size_t ELDOParser::Meas_derivativeContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_derivative;
}

void ELDOParser::Meas_derivativeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_derivative(this);
}

void ELDOParser::Meas_derivativeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_derivative(this);
}


std::any ELDOParser::Meas_derivativeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_derivative(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_derivativeContext* ELDOParser::meas_derivative() {
  Meas_derivativeContext *_localctx = _tracker.createInstance<Meas_derivativeContext>(_ctx, getState());
  enterRule(_localctx, 228, ELDOParser::RuleMeas_derivative);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1150);
    match(ELDOParser::DERIVATIVE);
    setState(1151);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_paramContext ------------------------------------------------------------------

ELDOParser::Meas_paramContext::Meas_paramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_paramContext::PARAM() {
  return getToken(ELDOParser::PARAM, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Meas_paramContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}

tree::TerminalNode* ELDOParser::Meas_paramContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}


size_t ELDOParser::Meas_paramContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_param;
}

void ELDOParser::Meas_paramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_param(this);
}

void ELDOParser::Meas_paramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_param(this);
}


std::any ELDOParser::Meas_paramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_param(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_paramContext* ELDOParser::meas_param() {
  Meas_paramContext *_localctx = _tracker.createInstance<Meas_paramContext>(_ctx, getState());
  enterRule(_localctx, 230, ELDOParser::RuleMeas_param);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1153);
    match(ELDOParser::PARAM);
    setState(1155);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::EQUAL) {
      setState(1154);
      match(ELDOParser::EQUAL);
    }
    setState(1157);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_trigContext ------------------------------------------------------------------

ELDOParser::Meas_trigContext::Meas_trigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_trigContext::TRIG() {
  return getToken(ELDOParser::TRIG, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::Meas_trigContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Meas_trigContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_trig;
}

void ELDOParser::Meas_trigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_trig(this);
}

void ELDOParser::Meas_trigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_trig(this);
}


std::any ELDOParser::Meas_trigContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_trig(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_trigContext* ELDOParser::meas_trig() {
  Meas_trigContext *_localctx = _tracker.createInstance<Meas_trigContext>(_ctx, getState());
  enterRule(_localctx, 232, ELDOParser::RuleMeas_trig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1159);
    match(ELDOParser::TRIG);
    setState(1160);
    parameter_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Meas_targContext ------------------------------------------------------------------

ELDOParser::Meas_targContext::Meas_targContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Meas_targContext::TARG() {
  return getToken(ELDOParser::TARG, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::Meas_targContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Meas_targContext::getRuleIndex() const {
  return ELDOParser::RuleMeas_targ;
}

void ELDOParser::Meas_targContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeas_targ(this);
}

void ELDOParser::Meas_targContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeas_targ(this);
}


std::any ELDOParser::Meas_targContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMeas_targ(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Meas_targContext* ELDOParser::meas_targ() {
  Meas_targContext *_localctx = _tracker.createInstance<Meas_targContext>(_ctx, getState());
  enterRule(_localctx, 234, ELDOParser::RuleMeas_targ);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1162);
    match(ELDOParser::TARG);
    setState(1163);
    parameter_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectContext ------------------------------------------------------------------

ELDOParser::ConnectContext::ConnectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::ConnectContext::CONNECT() {
  return getToken(ELDOParser::CONNECT, 0);
}

std::vector<ELDOParser::ExpressionContext *> ELDOParser::ConnectContext::expression() {
  return getRuleContexts<ELDOParser::ExpressionContext>();
}

ELDOParser::ExpressionContext* ELDOParser::ConnectContext::expression(size_t i) {
  return getRuleContext<ELDOParser::ExpressionContext>(i);
}

ELDOParser::End_of_lineContext* ELDOParser::ConnectContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::ConnectContext::getRuleIndex() const {
  return ELDOParser::RuleConnect;
}

void ELDOParser::ConnectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConnect(this);
}

void ELDOParser::ConnectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConnect(this);
}


std::any ELDOParser::ConnectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitConnect(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ConnectContext* ELDOParser::connect() {
  ConnectContext *_localctx = _tracker.createInstance<ConnectContext>(_ctx, getState());
  enterRule(_localctx, 236, ELDOParser::RuleConnect);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1165);
    match(ELDOParser::CONNECT);
    setState(1166);
    expression(0);
    setState(1167);
    expression(0);
    setState(1168);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_declarationsContext ------------------------------------------------------------------

ELDOParser::Global_declarationsContext::Global_declarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Global_declarationsContext::GLOBAL_PARAM() {
  return getToken(ELDOParser::GLOBAL_PARAM, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::Global_declarationsContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::Global_declarationsContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::Global_declarationsContext::getRuleIndex() const {
  return ELDOParser::RuleGlobal_declarations;
}

void ELDOParser::Global_declarationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_declarations(this);
}

void ELDOParser::Global_declarationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_declarations(this);
}


std::any ELDOParser::Global_declarationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitGlobal_declarations(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Global_declarationsContext* ELDOParser::global_declarations() {
  Global_declarationsContext *_localctx = _tracker.createInstance<Global_declarationsContext>(_ctx, getState());
  enterRule(_localctx, 238, ELDOParser::RuleGlobal_declarations);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1170);
    match(ELDOParser::GLOBAL_PARAM);
    setState(1171);
    parameter_list();
    setState(1172);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentContext ------------------------------------------------------------------

ELDOParser::ComponentContext::ComponentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Component_typeContext* ELDOParser::ComponentContext::component_type() {
  return getRuleContext<ELDOParser::Component_typeContext>(0);
}

ELDOParser::End_of_lineContext* ELDOParser::ComponentContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}

std::vector<ELDOParser::Component_attributeContext *> ELDOParser::ComponentContext::component_attribute() {
  return getRuleContexts<ELDOParser::Component_attributeContext>();
}

ELDOParser::Component_attributeContext* ELDOParser::ComponentContext::component_attribute(size_t i) {
  return getRuleContext<ELDOParser::Component_attributeContext>(i);
}


size_t ELDOParser::ComponentContext::getRuleIndex() const {
  return ELDOParser::RuleComponent;
}

void ELDOParser::ComponentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent(this);
}

void ELDOParser::ComponentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent(this);
}


std::any ELDOParser::ComponentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ComponentContext* ELDOParser::component() {
  ComponentContext *_localctx = _tracker.createInstance<ComponentContext>(_ctx, getState());
  enterRule(_localctx, 240, ELDOParser::RuleComponent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1174);
    component_type();
    setState(1178);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1175);
        component_attribute(); 
      }
      setState(1180);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
    }
    setState(1181);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_typeContext ------------------------------------------------------------------

ELDOParser::Component_typeContext::Component_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::ResistorContext* ELDOParser::Component_typeContext::resistor() {
  return getRuleContext<ELDOParser::ResistorContext>(0);
}

ELDOParser::CapacitorContext* ELDOParser::Component_typeContext::capacitor() {
  return getRuleContext<ELDOParser::CapacitorContext>(0);
}

ELDOParser::InductorContext* ELDOParser::Component_typeContext::inductor() {
  return getRuleContext<ELDOParser::InductorContext>(0);
}

ELDOParser::Coupled_inductorContext* ELDOParser::Component_typeContext::coupled_inductor() {
  return getRuleContext<ELDOParser::Coupled_inductorContext>(0);
}

ELDOParser::Diffusion_resistorContext* ELDOParser::Component_typeContext::diffusion_resistor() {
  return getRuleContext<ELDOParser::Diffusion_resistorContext>(0);
}

ELDOParser::Transmission_lineContext* ELDOParser::Component_typeContext::transmission_line() {
  return getRuleContext<ELDOParser::Transmission_lineContext>(0);
}

ELDOParser::Lossy_transmission_lineContext* ELDOParser::Component_typeContext::lossy_transmission_line() {
  return getRuleContext<ELDOParser::Lossy_transmission_lineContext>(0);
}

ELDOParser::Ltl_w_modelContext* ELDOParser::Component_typeContext::ltl_w_model() {
  return getRuleContext<ELDOParser::Ltl_w_modelContext>(0);
}

ELDOParser::Ltl_u_modelContext* ELDOParser::Component_typeContext::ltl_u_model() {
  return getRuleContext<ELDOParser::Ltl_u_modelContext>(0);
}

ELDOParser::Junction_diodeContext* ELDOParser::Component_typeContext::junction_diode() {
  return getRuleContext<ELDOParser::Junction_diodeContext>(0);
}

ELDOParser::BjtContext* ELDOParser::Component_typeContext::bjt() {
  return getRuleContext<ELDOParser::BjtContext>(0);
}

ELDOParser::JfetContext* ELDOParser::Component_typeContext::jfet() {
  return getRuleContext<ELDOParser::JfetContext>(0);
}

ELDOParser::MosfetContext* ELDOParser::Component_typeContext::mosfet() {
  return getRuleContext<ELDOParser::MosfetContext>(0);
}

ELDOParser::Subckt_instanceContext* ELDOParser::Component_typeContext::subckt_instance() {
  return getRuleContext<ELDOParser::Subckt_instanceContext>(0);
}

ELDOParser::IvsourceContext* ELDOParser::Component_typeContext::ivsource() {
  return getRuleContext<ELDOParser::IvsourceContext>(0);
}

ELDOParser::IcsourceContext* ELDOParser::Component_typeContext::icsource() {
  return getRuleContext<ELDOParser::IcsourceContext>(0);
}

ELDOParser::VcvsContext* ELDOParser::Component_typeContext::vcvs() {
  return getRuleContext<ELDOParser::VcvsContext>(0);
}

ELDOParser::CccsContext* ELDOParser::Component_typeContext::cccs() {
  return getRuleContext<ELDOParser::CccsContext>(0);
}

ELDOParser::VccsContext* ELDOParser::Component_typeContext::vccs() {
  return getRuleContext<ELDOParser::VccsContext>(0);
}

ELDOParser::CcvsContext* ELDOParser::Component_typeContext::ccvs() {
  return getRuleContext<ELDOParser::CcvsContext>(0);
}

ELDOParser::Noise_functionContext* ELDOParser::Component_typeContext::noise_function() {
  return getRuleContext<ELDOParser::Noise_functionContext>(0);
}

ELDOParser::SwContext* ELDOParser::Component_typeContext::sw() {
  return getRuleContext<ELDOParser::SwContext>(0);
}

ELDOParser::Operational_amplifierContext* ELDOParser::Component_typeContext::operational_amplifier() {
  return getRuleContext<ELDOParser::Operational_amplifierContext>(0);
}

ELDOParser::Two_input_gateContext* ELDOParser::Component_typeContext::two_input_gate() {
  return getRuleContext<ELDOParser::Two_input_gateContext>(0);
}


size_t ELDOParser::Component_typeContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_type;
}

void ELDOParser::Component_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_type(this);
}

void ELDOParser::Component_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_type(this);
}


std::any ELDOParser::Component_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_type(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_typeContext* ELDOParser::component_type() {
  Component_typeContext *_localctx = _tracker.createInstance<Component_typeContext>(_ctx, getState());
  enterRule(_localctx, 242, ELDOParser::RuleComponent_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1207);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ELDOParser::RESISTOR: {
        enterOuterAlt(_localctx, 1);
        setState(1183);
        resistor();
        break;
      }

      case ELDOParser::CAPACITOR: {
        enterOuterAlt(_localctx, 2);
        setState(1184);
        capacitor();
        break;
      }

      case ELDOParser::INDUCTOR: {
        enterOuterAlt(_localctx, 3);
        setState(1185);
        inductor();
        break;
      }

      case ELDOParser::COUPLED_INDUCTOR: {
        enterOuterAlt(_localctx, 4);
        setState(1186);
        coupled_inductor();
        break;
      }

      case ELDOParser::DIFFUSION_RESISTOR: {
        enterOuterAlt(_localctx, 5);
        setState(1187);
        diffusion_resistor();
        break;
      }

      case ELDOParser::TRANSMISSION_LINE: {
        enterOuterAlt(_localctx, 6);
        setState(1188);
        transmission_line();
        break;
      }

      case ELDOParser::LOSSY_TRANSMISSION_LINE: {
        enterOuterAlt(_localctx, 7);
        setState(1189);
        lossy_transmission_line();
        break;
      }

      case ELDOParser::LTL_W_MODEL: {
        enterOuterAlt(_localctx, 8);
        setState(1190);
        ltl_w_model();
        break;
      }

      case ELDOParser::LTL_U_MODEL: {
        enterOuterAlt(_localctx, 9);
        setState(1191);
        ltl_u_model();
        break;
      }

      case ELDOParser::JUNCTION_DIODE: {
        enterOuterAlt(_localctx, 10);
        setState(1192);
        junction_diode();
        break;
      }

      case ELDOParser::BJT: {
        enterOuterAlt(_localctx, 11);
        setState(1193);
        bjt();
        break;
      }

      case ELDOParser::JFET: {
        enterOuterAlt(_localctx, 12);
        setState(1194);
        jfet();
        break;
      }

      case ELDOParser::MOSFET: {
        enterOuterAlt(_localctx, 13);
        setState(1195);
        mosfet();
        break;
      }

      case ELDOParser::SUBCK_INSTANCE: {
        enterOuterAlt(_localctx, 14);
        setState(1196);
        subckt_instance();
        break;
      }

      case ELDOParser::IVSOURCE: {
        enterOuterAlt(_localctx, 15);
        setState(1197);
        ivsource();
        break;
      }

      case ELDOParser::ICSOURCE: {
        enterOuterAlt(_localctx, 16);
        setState(1198);
        icsource();
        break;
      }

      case ELDOParser::VCVS: {
        enterOuterAlt(_localctx, 17);
        setState(1199);
        vcvs();
        break;
      }

      case ELDOParser::CCCS: {
        enterOuterAlt(_localctx, 18);
        setState(1200);
        cccs();
        break;
      }

      case ELDOParser::VCCS: {
        enterOuterAlt(_localctx, 19);
        setState(1201);
        vccs();
        break;
      }

      case ELDOParser::CCVS: {
        enterOuterAlt(_localctx, 20);
        setState(1202);
        ccvs();
        break;
      }

      case ELDOParser::NOISE: {
        enterOuterAlt(_localctx, 21);
        setState(1203);
        noise_function();
        break;
      }

      case ELDOParser::SW: {
        enterOuterAlt(_localctx, 22);
        setState(1204);
        sw();
        break;
      }

      case ELDOParser::OPA: {
        enterOuterAlt(_localctx, 23);
        setState(1205);
        operational_amplifier();
        break;
      }

      case ELDOParser::DIG_NAND:
      case ELDOParser::DIG_AND:
      case ELDOParser::DIG_NOR:
      case ELDOParser::DIG_OR:
      case ELDOParser::DIG_XOR: {
        enterOuterAlt(_localctx, 24);
        setState(1206);
        two_input_gate();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_attributeContext ------------------------------------------------------------------

ELDOParser::Component_attributeContext::Component_attributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Component_parameter_listContext* ELDOParser::Component_attributeContext::component_parameter_list() {
  return getRuleContext<ELDOParser::Component_parameter_listContext>(0);
}

ELDOParser::Component_valueContext* ELDOParser::Component_attributeContext::component_value() {
  return getRuleContext<ELDOParser::Component_valueContext>(0);
}

ELDOParser::Component_analysisContext* ELDOParser::Component_attributeContext::component_analysis() {
  return getRuleContext<ELDOParser::Component_analysisContext>(0);
}

ELDOParser::Component_pin_listContext* ELDOParser::Component_attributeContext::component_pin_list() {
  return getRuleContext<ELDOParser::Component_pin_listContext>(0);
}

ELDOParser::Component_port_listContext* ELDOParser::Component_attributeContext::component_port_list() {
  return getRuleContext<ELDOParser::Component_port_listContext>(0);
}

ELDOParser::Component_net_listContext* ELDOParser::Component_attributeContext::component_net_list() {
  return getRuleContext<ELDOParser::Component_net_listContext>(0);
}

ELDOParser::Component_coupling_listContext* ELDOParser::Component_attributeContext::component_coupling_list() {
  return getRuleContext<ELDOParser::Component_coupling_listContext>(0);
}

ELDOParser::Component_value_listContext* ELDOParser::Component_attributeContext::component_value_list() {
  return getRuleContext<ELDOParser::Component_value_listContext>(0);
}

ELDOParser::Component_tableContext* ELDOParser::Component_attributeContext::component_table() {
  return getRuleContext<ELDOParser::Component_tableContext>(0);
}

ELDOParser::Component_positional_keyworkContext* ELDOParser::Component_attributeContext::component_positional_keywork() {
  return getRuleContext<ELDOParser::Component_positional_keyworkContext>(0);
}

ELDOParser::Interp_typeContext* ELDOParser::Component_attributeContext::interp_type() {
  return getRuleContext<ELDOParser::Interp_typeContext>(0);
}


size_t ELDOParser::Component_attributeContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_attribute;
}

void ELDOParser::Component_attributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_attribute(this);
}

void ELDOParser::Component_attributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_attribute(this);
}


std::any ELDOParser::Component_attributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_attribute(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_attributeContext* ELDOParser::component_attribute() {
  Component_attributeContext *_localctx = _tracker.createInstance<Component_attributeContext>(_ctx, getState());
  enterRule(_localctx, 244, ELDOParser::RuleComponent_attribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1220);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1209);
      component_parameter_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1210);
      component_value();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1211);
      component_analysis();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1212);
      component_pin_list();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1213);
      component_port_list();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1214);
      component_net_list();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1215);
      component_coupling_list();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1216);
      component_value_list();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1217);
      component_table();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1218);
      component_positional_keywork();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1219);
      interp_type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_valueContext ------------------------------------------------------------------

ELDOParser::Component_valueContext::Component_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_valueContext::OPEN_CURLY() {
  return getToken(ELDOParser::OPEN_CURLY, 0);
}

tree::TerminalNode* ELDOParser::Component_valueContext::CLOSE_CURLY() {
  return getToken(ELDOParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* ELDOParser::Component_valueContext::STRING() {
  return getToken(ELDOParser::STRING, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Component_valueContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}


size_t ELDOParser::Component_valueContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_value;
}

void ELDOParser::Component_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_value(this);
}

void ELDOParser::Component_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_value(this);
}


std::any ELDOParser::Component_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_value(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_valueContext* ELDOParser::component_value() {
  Component_valueContext *_localctx = _tracker.createInstance<Component_valueContext>(_ctx, getState());
  enterRule(_localctx, 246, ELDOParser::RuleComponent_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1232);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1222);
      match(ELDOParser::OPEN_CURLY);
      setState(1225);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
      case 1: {
        setState(1223);
        match(ELDOParser::STRING);
        break;
      }

      case 2: {
        setState(1224);
        expression(0);
        break;
      }

      default:
        break;
      }
      setState(1227);
      match(ELDOParser::CLOSE_CURLY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1230);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
      case 1: {
        setState(1228);
        match(ELDOParser::STRING);
        break;
      }

      case 2: {
        setState(1229);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_parameter_listContext ------------------------------------------------------------------

ELDOParser::Component_parameter_listContext::Component_parameter_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_parameter_listContext::PARAM_LIST_START() {
  return getToken(ELDOParser::PARAM_LIST_START, 0);
}

tree::TerminalNode* ELDOParser::Component_parameter_listContext::GENERIC_LIST_START() {
  return getToken(ELDOParser::GENERIC_LIST_START, 0);
}

ELDOParser::Parameter_listContext* ELDOParser::Component_parameter_listContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}


size_t ELDOParser::Component_parameter_listContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_parameter_list;
}

void ELDOParser::Component_parameter_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_parameter_list(this);
}

void ELDOParser::Component_parameter_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_parameter_list(this);
}


std::any ELDOParser::Component_parameter_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_parameter_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_parameter_listContext* ELDOParser::component_parameter_list() {
  Component_parameter_listContext *_localctx = _tracker.createInstance<Component_parameter_listContext>(_ctx, getState());
  enterRule(_localctx, 248, ELDOParser::RuleComponent_parameter_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1240);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1234);
      match(ELDOParser::PARAM_LIST_START);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1235);
      match(ELDOParser::GENERIC_LIST_START);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1237);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
      case 1: {
        setState(1236);
        _la = _input->LA(1);
        if (!(_la == ELDOParser::PARAM_LIST_START

        || _la == ELDOParser::GENERIC_LIST_START)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
      }
      setState(1239);
      parameter_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_analysisContext ------------------------------------------------------------------

ELDOParser::Component_analysisContext::Component_analysisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_analysisContext::OPEN_CURLY() {
  return getToken(ELDOParser::OPEN_CURLY, 0);
}

tree::TerminalNode* ELDOParser::Component_analysisContext::CLOSE_CURLY() {
  return getToken(ELDOParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* ELDOParser::Component_analysisContext::AC() {
  return getToken(ELDOParser::AC, 0);
}

tree::TerminalNode* ELDOParser::Component_analysisContext::DC() {
  return getToken(ELDOParser::DC, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Component_analysisContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}


size_t ELDOParser::Component_analysisContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_analysis;
}

void ELDOParser::Component_analysisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_analysis(this);
}

void ELDOParser::Component_analysisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_analysis(this);
}


std::any ELDOParser::Component_analysisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_analysis(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_analysisContext* ELDOParser::component_analysis() {
  Component_analysisContext *_localctx = _tracker.createInstance<Component_analysisContext>(_ctx, getState());
  enterRule(_localctx, 250, ELDOParser::RuleComponent_analysis);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1252);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1242);
      _la = _input->LA(1);
      if (!(_la == ELDOParser::AC

      || _la == ELDOParser::DC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1243);
      match(ELDOParser::OPEN_CURLY);
      setState(1245);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ELDOParser::MOD

      || _la == ELDOParser::MODEL || ((((_la - 138) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 138)) & 1946157227) != 0)) {
        setState(1244);
        expression(0);
      }
      setState(1247);
      match(ELDOParser::CLOSE_CURLY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1248);
      _la = _input->LA(1);
      if (!(_la == ELDOParser::AC

      || _la == ELDOParser::DC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1250);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
      case 1: {
        setState(1249);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_positional_keyworkContext ------------------------------------------------------------------

ELDOParser::Component_positional_keyworkContext::Component_positional_keyworkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_positional_keyworkContext::NOISE() {
  return getToken(ELDOParser::NOISE, 0);
}


size_t ELDOParser::Component_positional_keyworkContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_positional_keywork;
}

void ELDOParser::Component_positional_keyworkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_positional_keywork(this);
}

void ELDOParser::Component_positional_keyworkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_positional_keywork(this);
}


std::any ELDOParser::Component_positional_keyworkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_positional_keywork(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_positional_keyworkContext* ELDOParser::component_positional_keywork() {
  Component_positional_keyworkContext *_localctx = _tracker.createInstance<Component_positional_keyworkContext>(_ctx, getState());
  enterRule(_localctx, 252, ELDOParser::RuleComponent_positional_keywork);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1254);
    match(ELDOParser::NOISE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_pin_listContext ------------------------------------------------------------------

ELDOParser::Component_pin_listContext::Component_pin_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_pin_listContext::PIN_LIST_START() {
  return getToken(ELDOParser::PIN_LIST_START, 0);
}

ELDOParser::Node_listContext* ELDOParser::Component_pin_listContext::node_list() {
  return getRuleContext<ELDOParser::Node_listContext>(0);
}


size_t ELDOParser::Component_pin_listContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_pin_list;
}

void ELDOParser::Component_pin_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_pin_list(this);
}

void ELDOParser::Component_pin_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_pin_list(this);
}


std::any ELDOParser::Component_pin_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_pin_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_pin_listContext* ELDOParser::component_pin_list() {
  Component_pin_listContext *_localctx = _tracker.createInstance<Component_pin_listContext>(_ctx, getState());
  enterRule(_localctx, 254, ELDOParser::RuleComponent_pin_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1256);
    match(ELDOParser::PIN_LIST_START);
    setState(1257);
    node_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_port_listContext ------------------------------------------------------------------

ELDOParser::Component_port_listContext::Component_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_port_listContext::PORT_LIST_START() {
  return getToken(ELDOParser::PORT_LIST_START, 0);
}

ELDOParser::Node_listContext* ELDOParser::Component_port_listContext::node_list() {
  return getRuleContext<ELDOParser::Node_listContext>(0);
}


size_t ELDOParser::Component_port_listContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_port_list;
}

void ELDOParser::Component_port_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_port_list(this);
}

void ELDOParser::Component_port_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_port_list(this);
}


std::any ELDOParser::Component_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_port_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_port_listContext* ELDOParser::component_port_list() {
  Component_port_listContext *_localctx = _tracker.createInstance<Component_port_listContext>(_ctx, getState());
  enterRule(_localctx, 256, ELDOParser::RuleComponent_port_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1259);
    match(ELDOParser::PORT_LIST_START);
    setState(1260);
    node_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_net_listContext ------------------------------------------------------------------

ELDOParser::Component_net_listContext::Component_net_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_net_listContext::NET_LIST_START() {
  return getToken(ELDOParser::NET_LIST_START, 0);
}

ELDOParser::Node_listContext* ELDOParser::Component_net_listContext::node_list() {
  return getRuleContext<ELDOParser::Node_listContext>(0);
}


size_t ELDOParser::Component_net_listContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_net_list;
}

void ELDOParser::Component_net_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_net_list(this);
}

void ELDOParser::Component_net_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_net_list(this);
}


std::any ELDOParser::Component_net_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_net_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_net_listContext* ELDOParser::component_net_list() {
  Component_net_listContext *_localctx = _tracker.createInstance<Component_net_listContext>(_ctx, getState());
  enterRule(_localctx, 258, ELDOParser::RuleComponent_net_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1262);
    match(ELDOParser::NET_LIST_START);
    setState(1263);
    node_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_coupling_listContext ------------------------------------------------------------------

ELDOParser::Component_coupling_listContext::Component_coupling_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_coupling_listContext::COUPLING_LIST_START() {
  return getToken(ELDOParser::COUPLING_LIST_START, 0);
}

std::vector<ELDOParser::ExpressionContext *> ELDOParser::Component_coupling_listContext::expression() {
  return getRuleContexts<ELDOParser::ExpressionContext>();
}

ELDOParser::ExpressionContext* ELDOParser::Component_coupling_listContext::expression(size_t i) {
  return getRuleContext<ELDOParser::ExpressionContext>(i);
}


size_t ELDOParser::Component_coupling_listContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_coupling_list;
}

void ELDOParser::Component_coupling_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_coupling_list(this);
}

void ELDOParser::Component_coupling_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_coupling_list(this);
}


std::any ELDOParser::Component_coupling_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_coupling_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_coupling_listContext* ELDOParser::component_coupling_list() {
  Component_coupling_listContext *_localctx = _tracker.createInstance<Component_coupling_listContext>(_ctx, getState());
  enterRule(_localctx, 260, ELDOParser::RuleComponent_coupling_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1265);
    match(ELDOParser::COUPLING_LIST_START);
    setState(1267); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1266);
              expression(0);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1269); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_tableContext ------------------------------------------------------------------

ELDOParser::Component_tableContext::Component_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_tableContext::TABLE() {
  return getToken(ELDOParser::TABLE, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Component_tableContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}

tree::TerminalNode* ELDOParser::Component_tableContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

std::vector<ELDOParser::Expression_listContext *> ELDOParser::Component_tableContext::expression_list() {
  return getRuleContexts<ELDOParser::Expression_listContext>();
}

ELDOParser::Expression_listContext* ELDOParser::Component_tableContext::expression_list(size_t i) {
  return getRuleContext<ELDOParser::Expression_listContext>(i);
}


size_t ELDOParser::Component_tableContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_table;
}

void ELDOParser::Component_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_table(this);
}

void ELDOParser::Component_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_table(this);
}


std::any ELDOParser::Component_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_table(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_tableContext* ELDOParser::component_table() {
  Component_tableContext *_localctx = _tracker.createInstance<Component_tableContext>(_ctx, getState());
  enterRule(_localctx, 262, ELDOParser::RuleComponent_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1271);
    match(ELDOParser::TABLE);
    setState(1272);
    expression(0);
    setState(1273);
    match(ELDOParser::EQUAL);
    setState(1275); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1274);
              expression_list();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1277); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_value_listContext ------------------------------------------------------------------

ELDOParser::Component_value_listContext::Component_value_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Component_value_listContext::OPEN_ROUND() {
  return getToken(ELDOParser::OPEN_ROUND, 0);
}

tree::TerminalNode* ELDOParser::Component_value_listContext::CLOSE_ROUND() {
  return getToken(ELDOParser::CLOSE_ROUND, 0);
}

tree::TerminalNode* ELDOParser::Component_value_listContext::PWL() {
  return getToken(ELDOParser::PWL, 0);
}

tree::TerminalNode* ELDOParser::Component_value_listContext::SIN() {
  return getToken(ELDOParser::SIN, 0);
}

tree::TerminalNode* ELDOParser::Component_value_listContext::SFFM() {
  return getToken(ELDOParser::SFFM, 0);
}

tree::TerminalNode* ELDOParser::Component_value_listContext::PULSE() {
  return getToken(ELDOParser::PULSE, 0);
}

tree::TerminalNode* ELDOParser::Component_value_listContext::EXP() {
  return getToken(ELDOParser::EXP, 0);
}

std::vector<ELDOParser::ExpressionContext *> ELDOParser::Component_value_listContext::expression() {
  return getRuleContexts<ELDOParser::ExpressionContext>();
}

ELDOParser::ExpressionContext* ELDOParser::Component_value_listContext::expression(size_t i) {
  return getRuleContext<ELDOParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ELDOParser::Component_value_listContext::COMMA() {
  return getTokens(ELDOParser::COMMA);
}

tree::TerminalNode* ELDOParser::Component_value_listContext::COMMA(size_t i) {
  return getToken(ELDOParser::COMMA, i);
}


size_t ELDOParser::Component_value_listContext::getRuleIndex() const {
  return ELDOParser::RuleComponent_value_list;
}

void ELDOParser::Component_value_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_value_list(this);
}

void ELDOParser::Component_value_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_value_list(this);
}


std::any ELDOParser::Component_value_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitComponent_value_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Component_value_listContext* ELDOParser::component_value_list() {
  Component_value_listContext *_localctx = _tracker.createInstance<Component_value_listContext>(_ctx, getState());
  enterRule(_localctx, 264, ELDOParser::RuleComponent_value_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1279);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2130303778816) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1280);
    match(ELDOParser::OPEN_ROUND);
    setState(1285); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1281);
      expression(0);
      setState(1283);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ELDOParser::COMMA) {
        setState(1282);
        match(ELDOParser::COMMA);
      }
      setState(1287); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL || ((((_la - 138) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 138)) & 1946157227) != 0));
    setState(1289);
    match(ELDOParser::CLOSE_ROUND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interp_typeContext ------------------------------------------------------------------

ELDOParser::Interp_typeContext::Interp_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Interp_typeContext::INTERP() {
  return getToken(ELDOParser::INTERP, 0);
}

tree::TerminalNode* ELDOParser::Interp_typeContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Interp_typeContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Interp_typeContext::getRuleIndex() const {
  return ELDOParser::RuleInterp_type;
}

void ELDOParser::Interp_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterp_type(this);
}

void ELDOParser::Interp_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterp_type(this);
}


std::any ELDOParser::Interp_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitInterp_type(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Interp_typeContext* ELDOParser::interp_type() {
  Interp_typeContext *_localctx = _tracker.createInstance<Interp_typeContext>(_ctx, getState());
  enterRule(_localctx, 266, ELDOParser::RuleInterp_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1291);
    match(ELDOParser::INTERP);
    setState(1292);
    match(ELDOParser::EQUAL);
    setState(1293);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResistorContext ------------------------------------------------------------------

ELDOParser::ResistorContext::ResistorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::ResistorContext::RESISTOR() {
  return getToken(ELDOParser::RESISTOR, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::ResistorContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::ResistorContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}

tree::TerminalNode* ELDOParser::ResistorContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::ResistorContext::getRuleIndex() const {
  return ELDOParser::RuleResistor;
}

void ELDOParser::ResistorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResistor(this);
}

void ELDOParser::ResistorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResistor(this);
}


std::any ELDOParser::ResistorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitResistor(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ResistorContext* ELDOParser::resistor() {
  ResistorContext *_localctx = _tracker.createInstance<ResistorContext>(_ctx, getState());
  enterRule(_localctx, 268, ELDOParser::RuleResistor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1295);
    match(ELDOParser::RESISTOR);
    setState(1296);
    node();
    setState(1297);
    node();
    setState(1299);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      setState(1298);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CapacitorContext ------------------------------------------------------------------

ELDOParser::CapacitorContext::CapacitorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::CapacitorContext::CAPACITOR() {
  return getToken(ELDOParser::CAPACITOR, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::CapacitorContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::CapacitorContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}

tree::TerminalNode* ELDOParser::CapacitorContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::CapacitorContext::getRuleIndex() const {
  return ELDOParser::RuleCapacitor;
}

void ELDOParser::CapacitorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCapacitor(this);
}

void ELDOParser::CapacitorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCapacitor(this);
}


std::any ELDOParser::CapacitorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitCapacitor(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::CapacitorContext* ELDOParser::capacitor() {
  CapacitorContext *_localctx = _tracker.createInstance<CapacitorContext>(_ctx, getState());
  enterRule(_localctx, 270, ELDOParser::RuleCapacitor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1301);
    match(ELDOParser::CAPACITOR);
    setState(1302);
    node();
    setState(1303);
    node();
    setState(1305);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      setState(1304);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InductorContext ------------------------------------------------------------------

ELDOParser::InductorContext::InductorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::InductorContext::INDUCTOR() {
  return getToken(ELDOParser::INDUCTOR, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::InductorContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::InductorContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::InductorContext::getRuleIndex() const {
  return ELDOParser::RuleInductor;
}

void ELDOParser::InductorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInductor(this);
}

void ELDOParser::InductorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInductor(this);
}


std::any ELDOParser::InductorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitInductor(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::InductorContext* ELDOParser::inductor() {
  InductorContext *_localctx = _tracker.createInstance<InductorContext>(_ctx, getState());
  enterRule(_localctx, 272, ELDOParser::RuleInductor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1307);
    match(ELDOParser::INDUCTOR);
    setState(1308);
    node();
    setState(1309);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Coupled_inductorContext ------------------------------------------------------------------

ELDOParser::Coupled_inductorContext::Coupled_inductorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Coupled_inductorContext::COUPLED_INDUCTOR() {
  return getToken(ELDOParser::COUPLED_INDUCTOR, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Coupled_inductorContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Coupled_inductorContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}


size_t ELDOParser::Coupled_inductorContext::getRuleIndex() const {
  return ELDOParser::RuleCoupled_inductor;
}

void ELDOParser::Coupled_inductorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCoupled_inductor(this);
}

void ELDOParser::Coupled_inductorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCoupled_inductor(this);
}


std::any ELDOParser::Coupled_inductorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitCoupled_inductor(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Coupled_inductorContext* ELDOParser::coupled_inductor() {
  Coupled_inductorContext *_localctx = _tracker.createInstance<Coupled_inductorContext>(_ctx, getState());
  enterRule(_localctx, 274, ELDOParser::RuleCoupled_inductor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1311);
    match(ELDOParser::COUPLED_INDUCTOR);
    setState(1312);
    match(ELDOParser::ID);
    setState(1313);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Diffusion_resistorContext ------------------------------------------------------------------

ELDOParser::Diffusion_resistorContext::Diffusion_resistorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Diffusion_resistorContext::DIFFUSION_RESISTOR() {
  return getToken(ELDOParser::DIFFUSION_RESISTOR, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::Diffusion_resistorContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::Diffusion_resistorContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}

tree::TerminalNode* ELDOParser::Diffusion_resistorContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Diffusion_resistorContext::getRuleIndex() const {
  return ELDOParser::RuleDiffusion_resistor;
}

void ELDOParser::Diffusion_resistorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiffusion_resistor(this);
}

void ELDOParser::Diffusion_resistorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiffusion_resistor(this);
}


std::any ELDOParser::Diffusion_resistorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitDiffusion_resistor(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Diffusion_resistorContext* ELDOParser::diffusion_resistor() {
  Diffusion_resistorContext *_localctx = _tracker.createInstance<Diffusion_resistorContext>(_ctx, getState());
  enterRule(_localctx, 276, ELDOParser::RuleDiffusion_resistor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1315);
    match(ELDOParser::DIFFUSION_RESISTOR);
    setState(1316);
    node();
    setState(1317);
    node();
    setState(1319);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      setState(1318);
      node();
      break;
    }

    default:
      break;
    }
    setState(1321);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transmission_lineContext ------------------------------------------------------------------

ELDOParser::Transmission_lineContext::Transmission_lineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Transmission_lineContext::TRANSMISSION_LINE() {
  return getToken(ELDOParser::TRANSMISSION_LINE, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::Transmission_lineContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::Transmission_lineContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::Transmission_lineContext::getRuleIndex() const {
  return ELDOParser::RuleTransmission_line;
}

void ELDOParser::Transmission_lineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransmission_line(this);
}

void ELDOParser::Transmission_lineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransmission_line(this);
}


std::any ELDOParser::Transmission_lineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitTransmission_line(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Transmission_lineContext* ELDOParser::transmission_line() {
  Transmission_lineContext *_localctx = _tracker.createInstance<Transmission_lineContext>(_ctx, getState());
  enterRule(_localctx, 278, ELDOParser::RuleTransmission_line);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1323);
    match(ELDOParser::TRANSMISSION_LINE);
    setState(1324);
    node();
    setState(1325);
    node();
    setState(1326);
    node();
    setState(1327);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lossy_transmission_lineContext ------------------------------------------------------------------

ELDOParser::Lossy_transmission_lineContext::Lossy_transmission_lineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Lossy_transmission_lineContext::LOSSY_TRANSMISSION_LINE() {
  return getToken(ELDOParser::LOSSY_TRANSMISSION_LINE, 0);
}


size_t ELDOParser::Lossy_transmission_lineContext::getRuleIndex() const {
  return ELDOParser::RuleLossy_transmission_line;
}

void ELDOParser::Lossy_transmission_lineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLossy_transmission_line(this);
}

void ELDOParser::Lossy_transmission_lineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLossy_transmission_line(this);
}


std::any ELDOParser::Lossy_transmission_lineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLossy_transmission_line(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Lossy_transmission_lineContext* ELDOParser::lossy_transmission_line() {
  Lossy_transmission_lineContext *_localctx = _tracker.createInstance<Lossy_transmission_lineContext>(_ctx, getState());
  enterRule(_localctx, 280, ELDOParser::RuleLossy_transmission_line);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1329);
    match(ELDOParser::LOSSY_TRANSMISSION_LINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ltl_w_modelContext ------------------------------------------------------------------

ELDOParser::Ltl_w_modelContext::Ltl_w_modelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ltl_w_modelContext::LTL_W_MODEL() {
  return getToken(ELDOParser::LTL_W_MODEL, 0);
}


size_t ELDOParser::Ltl_w_modelContext::getRuleIndex() const {
  return ELDOParser::RuleLtl_w_model;
}

void ELDOParser::Ltl_w_modelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLtl_w_model(this);
}

void ELDOParser::Ltl_w_modelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLtl_w_model(this);
}


std::any ELDOParser::Ltl_w_modelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLtl_w_model(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ltl_w_modelContext* ELDOParser::ltl_w_model() {
  Ltl_w_modelContext *_localctx = _tracker.createInstance<Ltl_w_modelContext>(_ctx, getState());
  enterRule(_localctx, 282, ELDOParser::RuleLtl_w_model);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1331);
    match(ELDOParser::LTL_W_MODEL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ltl_u_modelContext ------------------------------------------------------------------

ELDOParser::Ltl_u_modelContext::Ltl_u_modelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Ltl_u_modelContext::LTL_U_MODEL() {
  return getToken(ELDOParser::LTL_U_MODEL, 0);
}


size_t ELDOParser::Ltl_u_modelContext::getRuleIndex() const {
  return ELDOParser::RuleLtl_u_model;
}

void ELDOParser::Ltl_u_modelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLtl_u_model(this);
}

void ELDOParser::Ltl_u_modelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLtl_u_model(this);
}


std::any ELDOParser::Ltl_u_modelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitLtl_u_model(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Ltl_u_modelContext* ELDOParser::ltl_u_model() {
  Ltl_u_modelContext *_localctx = _tracker.createInstance<Ltl_u_modelContext>(_ctx, getState());
  enterRule(_localctx, 284, ELDOParser::RuleLtl_u_model);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1333);
    match(ELDOParser::LTL_U_MODEL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Junction_diodeContext ------------------------------------------------------------------

ELDOParser::Junction_diodeContext::Junction_diodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Junction_diodeContext::JUNCTION_DIODE() {
  return getToken(ELDOParser::JUNCTION_DIODE, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::Junction_diodeContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::Junction_diodeContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::Junction_diodeContext::getRuleIndex() const {
  return ELDOParser::RuleJunction_diode;
}

void ELDOParser::Junction_diodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJunction_diode(this);
}

void ELDOParser::Junction_diodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJunction_diode(this);
}


std::any ELDOParser::Junction_diodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitJunction_diode(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Junction_diodeContext* ELDOParser::junction_diode() {
  Junction_diodeContext *_localctx = _tracker.createInstance<Junction_diodeContext>(_ctx, getState());
  enterRule(_localctx, 286, ELDOParser::RuleJunction_diode);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1335);
    match(ELDOParser::JUNCTION_DIODE);
    setState(1336);
    node();
    setState(1337);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BjtContext ------------------------------------------------------------------

ELDOParser::BjtContext::BjtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::BjtContext::BJT() {
  return getToken(ELDOParser::BJT, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::BjtContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::BjtContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::BjtContext::getRuleIndex() const {
  return ELDOParser::RuleBjt;
}

void ELDOParser::BjtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBjt(this);
}

void ELDOParser::BjtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBjt(this);
}


std::any ELDOParser::BjtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitBjt(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::BjtContext* ELDOParser::bjt() {
  BjtContext *_localctx = _tracker.createInstance<BjtContext>(_ctx, getState());
  enterRule(_localctx, 288, ELDOParser::RuleBjt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1339);
    match(ELDOParser::BJT);
    setState(1340);
    node();
    setState(1341);
    node();
    setState(1342);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JfetContext ------------------------------------------------------------------

ELDOParser::JfetContext::JfetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::JfetContext::JFET() {
  return getToken(ELDOParser::JFET, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::JfetContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::JfetContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}

tree::TerminalNode* ELDOParser::JfetContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::JfetContext::getRuleIndex() const {
  return ELDOParser::RuleJfet;
}

void ELDOParser::JfetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJfet(this);
}

void ELDOParser::JfetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJfet(this);
}


std::any ELDOParser::JfetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitJfet(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::JfetContext* ELDOParser::jfet() {
  JfetContext *_localctx = _tracker.createInstance<JfetContext>(_ctx, getState());
  enterRule(_localctx, 290, ELDOParser::RuleJfet);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1344);
    match(ELDOParser::JFET);
    setState(1345);
    node();
    setState(1346);
    node();
    setState(1347);
    node();
    setState(1348);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MosfetContext ------------------------------------------------------------------

ELDOParser::MosfetContext::MosfetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::MosfetContext::MOSFET() {
  return getToken(ELDOParser::MOSFET, 0);
}

ELDOParser::Node_listContext* ELDOParser::MosfetContext::node_list() {
  return getRuleContext<ELDOParser::Node_listContext>(0);
}

tree::TerminalNode* ELDOParser::MosfetContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::MosfetContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

tree::TerminalNode* ELDOParser::MosfetContext::MODEL() {
  return getToken(ELDOParser::MODEL, 0);
}

tree::TerminalNode* ELDOParser::MosfetContext::MOD() {
  return getToken(ELDOParser::MOD, 0);
}


size_t ELDOParser::MosfetContext::getRuleIndex() const {
  return ELDOParser::RuleMosfet;
}

void ELDOParser::MosfetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMosfet(this);
}

void ELDOParser::MosfetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMosfet(this);
}


std::any ELDOParser::MosfetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitMosfet(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::MosfetContext* ELDOParser::mosfet() {
  MosfetContext *_localctx = _tracker.createInstance<MosfetContext>(_ctx, getState());
  enterRule(_localctx, 292, ELDOParser::RuleMosfet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1350);
    match(ELDOParser::MOSFET);
    setState(1351);
    node_list();
    setState(1354);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL) {
      setState(1352);
      _la = _input->LA(1);
      if (!(_la == ELDOParser::MOD

      || _la == ELDOParser::MODEL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1353);
      match(ELDOParser::EQUAL);
    }
    setState(1356);
    match(ELDOParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subckt_instanceContext ------------------------------------------------------------------

ELDOParser::Subckt_instanceContext::Subckt_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Subckt_instanceContext::SUBCK_INSTANCE() {
  return getToken(ELDOParser::SUBCK_INSTANCE, 0);
}

ELDOParser::Node_listContext* ELDOParser::Subckt_instanceContext::node_list() {
  return getRuleContext<ELDOParser::Node_listContext>(0);
}

tree::TerminalNode* ELDOParser::Subckt_instanceContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::Subckt_instanceContext::MODEL() {
  return getToken(ELDOParser::MODEL, 0);
}

tree::TerminalNode* ELDOParser::Subckt_instanceContext::COLON() {
  return getToken(ELDOParser::COLON, 0);
}


size_t ELDOParser::Subckt_instanceContext::getRuleIndex() const {
  return ELDOParser::RuleSubckt_instance;
}

void ELDOParser::Subckt_instanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubckt_instance(this);
}

void ELDOParser::Subckt_instanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubckt_instance(this);
}


std::any ELDOParser::Subckt_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSubckt_instance(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Subckt_instanceContext* ELDOParser::subckt_instance() {
  Subckt_instanceContext *_localctx = _tracker.createInstance<Subckt_instanceContext>(_ctx, getState());
  enterRule(_localctx, 294, ELDOParser::RuleSubckt_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1368);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1358);
      match(ELDOParser::SUBCK_INSTANCE);
      setState(1359);
      node_list();
      setState(1360);
      match(ELDOParser::ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1362);
      match(ELDOParser::SUBCK_INSTANCE);
      setState(1365);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ELDOParser::MODEL) {
        setState(1363);
        match(ELDOParser::MODEL);
        setState(1364);
        match(ELDOParser::COLON);
      }
      setState(1367);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IvsourceContext ------------------------------------------------------------------

ELDOParser::IvsourceContext::IvsourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::IvsourceContext::IVSOURCE() {
  return getToken(ELDOParser::IVSOURCE, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::IvsourceContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::IvsourceContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::IvsourceContext::getRuleIndex() const {
  return ELDOParser::RuleIvsource;
}

void ELDOParser::IvsourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIvsource(this);
}

void ELDOParser::IvsourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIvsource(this);
}


std::any ELDOParser::IvsourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitIvsource(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::IvsourceContext* ELDOParser::ivsource() {
  IvsourceContext *_localctx = _tracker.createInstance<IvsourceContext>(_ctx, getState());
  enterRule(_localctx, 296, ELDOParser::RuleIvsource);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1370);
    match(ELDOParser::IVSOURCE);
    setState(1371);
    node();
    setState(1372);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IcsourceContext ------------------------------------------------------------------

ELDOParser::IcsourceContext::IcsourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::IcsourceContext::ICSOURCE() {
  return getToken(ELDOParser::ICSOURCE, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::IcsourceContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::IcsourceContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::IcsourceContext::getRuleIndex() const {
  return ELDOParser::RuleIcsource;
}

void ELDOParser::IcsourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIcsource(this);
}

void ELDOParser::IcsourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIcsource(this);
}


std::any ELDOParser::IcsourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitIcsource(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::IcsourceContext* ELDOParser::icsource() {
  IcsourceContext *_localctx = _tracker.createInstance<IcsourceContext>(_ctx, getState());
  enterRule(_localctx, 298, ELDOParser::RuleIcsource);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1374);
    match(ELDOParser::ICSOURCE);
    setState(1375);
    node();
    setState(1376);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VcvsContext ------------------------------------------------------------------

ELDOParser::VcvsContext::VcvsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::VcvsContext::VCVS() {
  return getToken(ELDOParser::VCVS, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::VcvsContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::VcvsContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::VcvsContext::getRuleIndex() const {
  return ELDOParser::RuleVcvs;
}

void ELDOParser::VcvsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVcvs(this);
}

void ELDOParser::VcvsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVcvs(this);
}


std::any ELDOParser::VcvsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitVcvs(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::VcvsContext* ELDOParser::vcvs() {
  VcvsContext *_localctx = _tracker.createInstance<VcvsContext>(_ctx, getState());
  enterRule(_localctx, 300, ELDOParser::RuleVcvs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1378);
    match(ELDOParser::VCVS);
    setState(1379);
    node();
    setState(1380);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CccsContext ------------------------------------------------------------------

ELDOParser::CccsContext::CccsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::CccsContext::CCCS() {
  return getToken(ELDOParser::CCCS, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::CccsContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::CccsContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::CccsContext::getRuleIndex() const {
  return ELDOParser::RuleCccs;
}

void ELDOParser::CccsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCccs(this);
}

void ELDOParser::CccsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCccs(this);
}


std::any ELDOParser::CccsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitCccs(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::CccsContext* ELDOParser::cccs() {
  CccsContext *_localctx = _tracker.createInstance<CccsContext>(_ctx, getState());
  enterRule(_localctx, 302, ELDOParser::RuleCccs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1382);
    match(ELDOParser::CCCS);
    setState(1383);
    node();
    setState(1384);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VccsContext ------------------------------------------------------------------

ELDOParser::VccsContext::VccsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::VccsContext::VCCS() {
  return getToken(ELDOParser::VCCS, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::VccsContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::VccsContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::VccsContext::getRuleIndex() const {
  return ELDOParser::RuleVccs;
}

void ELDOParser::VccsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVccs(this);
}

void ELDOParser::VccsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVccs(this);
}


std::any ELDOParser::VccsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitVccs(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::VccsContext* ELDOParser::vccs() {
  VccsContext *_localctx = _tracker.createInstance<VccsContext>(_ctx, getState());
  enterRule(_localctx, 304, ELDOParser::RuleVccs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1386);
    match(ELDOParser::VCCS);
    setState(1387);
    node();
    setState(1388);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CcvsContext ------------------------------------------------------------------

ELDOParser::CcvsContext::CcvsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::CcvsContext::CCVS() {
  return getToken(ELDOParser::CCVS, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::CcvsContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::CcvsContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}


size_t ELDOParser::CcvsContext::getRuleIndex() const {
  return ELDOParser::RuleCcvs;
}

void ELDOParser::CcvsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCcvs(this);
}

void ELDOParser::CcvsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCcvs(this);
}


std::any ELDOParser::CcvsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitCcvs(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::CcvsContext* ELDOParser::ccvs() {
  CcvsContext *_localctx = _tracker.createInstance<CcvsContext>(_ctx, getState());
  enterRule(_localctx, 306, ELDOParser::RuleCcvs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1390);
    match(ELDOParser::CCVS);
    setState(1391);
    node();
    setState(1392);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Noise_functionContext ------------------------------------------------------------------

ELDOParser::Noise_functionContext::Noise_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Noise_functionContext::NOISE() {
  return getToken(ELDOParser::NOISE, 0);
}


size_t ELDOParser::Noise_functionContext::getRuleIndex() const {
  return ELDOParser::RuleNoise_function;
}

void ELDOParser::Noise_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoise_function(this);
}

void ELDOParser::Noise_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoise_function(this);
}


std::any ELDOParser::Noise_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNoise_function(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Noise_functionContext* ELDOParser::noise_function() {
  Noise_functionContext *_localctx = _tracker.createInstance<Noise_functionContext>(_ctx, getState());
  enterRule(_localctx, 308, ELDOParser::RuleNoise_function);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1394);
    match(ELDOParser::NOISE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwContext ------------------------------------------------------------------

ELDOParser::SwContext::SwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::SwContext::SW() {
  return getToken(ELDOParser::SW, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::SwContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::SwContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}

tree::TerminalNode* ELDOParser::SwContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

std::vector<ELDOParser::Expression_atomContext *> ELDOParser::SwContext::expression_atom() {
  return getRuleContexts<ELDOParser::Expression_atomContext>();
}

ELDOParser::Expression_atomContext* ELDOParser::SwContext::expression_atom(size_t i) {
  return getRuleContext<ELDOParser::Expression_atomContext>(i);
}


size_t ELDOParser::SwContext::getRuleIndex() const {
  return ELDOParser::RuleSw;
}

void ELDOParser::SwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSw(this);
}

void ELDOParser::SwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSw(this);
}


std::any ELDOParser::SwContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitSw(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::SwContext* ELDOParser::sw() {
  SwContext *_localctx = _tracker.createInstance<SwContext>(_ctx, getState());
  enterRule(_localctx, 310, ELDOParser::RuleSw);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1396);
    match(ELDOParser::SW);
    setState(1397);
    node();
    setState(1398);
    node();
    setState(1399);
    node();
    setState(1401);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
    case 1: {
      setState(1400);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(1407);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      setState(1403);
      expression_atom();
      setState(1405);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
      case 1: {
        setState(1404);
        expression_atom();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operational_amplifierContext ------------------------------------------------------------------

ELDOParser::Operational_amplifierContext::Operational_amplifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Operational_amplifierContext::OPA() {
  return getToken(ELDOParser::OPA, 0);
}

std::vector<ELDOParser::NodeContext *> ELDOParser::Operational_amplifierContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::Operational_amplifierContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}

tree::TerminalNode* ELDOParser::Operational_amplifierContext::ID() {
  return getToken(ELDOParser::ID, 0);
}


size_t ELDOParser::Operational_amplifierContext::getRuleIndex() const {
  return ELDOParser::RuleOperational_amplifier;
}

void ELDOParser::Operational_amplifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperational_amplifier(this);
}

void ELDOParser::Operational_amplifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperational_amplifier(this);
}


std::any ELDOParser::Operational_amplifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitOperational_amplifier(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Operational_amplifierContext* ELDOParser::operational_amplifier() {
  Operational_amplifierContext *_localctx = _tracker.createInstance<Operational_amplifierContext>(_ctx, getState());
  enterRule(_localctx, 312, ELDOParser::RuleOperational_amplifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1409);
    match(ELDOParser::OPA);
    setState(1410);
    node();
    setState(1411);
    node();
    setState(1412);
    node();
    setState(1413);
    node();
    setState(1415);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx)) {
    case 1: {
      setState(1414);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Two_input_gateContext ------------------------------------------------------------------

ELDOParser::Two_input_gateContext::Two_input_gateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::NodeContext *> ELDOParser::Two_input_gateContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::Two_input_gateContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}

ELDOParser::Parameter_listContext* ELDOParser::Two_input_gateContext::parameter_list() {
  return getRuleContext<ELDOParser::Parameter_listContext>(0);
}

tree::TerminalNode* ELDOParser::Two_input_gateContext::DIG_NAND() {
  return getToken(ELDOParser::DIG_NAND, 0);
}

tree::TerminalNode* ELDOParser::Two_input_gateContext::DIG_AND() {
  return getToken(ELDOParser::DIG_AND, 0);
}

tree::TerminalNode* ELDOParser::Two_input_gateContext::DIG_OR() {
  return getToken(ELDOParser::DIG_OR, 0);
}

tree::TerminalNode* ELDOParser::Two_input_gateContext::DIG_NOR() {
  return getToken(ELDOParser::DIG_NOR, 0);
}

tree::TerminalNode* ELDOParser::Two_input_gateContext::DIG_XOR() {
  return getToken(ELDOParser::DIG_XOR, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::Two_input_gateContext::ID() {
  return getTokens(ELDOParser::ID);
}

tree::TerminalNode* ELDOParser::Two_input_gateContext::ID(size_t i) {
  return getToken(ELDOParser::ID, i);
}


size_t ELDOParser::Two_input_gateContext::getRuleIndex() const {
  return ELDOParser::RuleTwo_input_gate;
}

void ELDOParser::Two_input_gateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTwo_input_gate(this);
}

void ELDOParser::Two_input_gateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTwo_input_gate(this);
}


std::any ELDOParser::Two_input_gateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitTwo_input_gate(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Two_input_gateContext* ELDOParser::two_input_gate() {
  Two_input_gateContext *_localctx = _tracker.createInstance<Two_input_gateContext>(_ctx, getState());
  enterRule(_localctx, 314, ELDOParser::RuleTwo_input_gate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1417);
    _la = _input->LA(1);
    if (!(((((_la - 113) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 113)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1418);
    node();
    setState(1419);
    node();
    setState(1420);
    node();
    setState(1423);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      setState(1421);
      match(ELDOParser::ID);
      setState(1422);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(1426);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
    case 1: {
      setState(1425);
      match(ELDOParser::ID);
      break;
    }

    default:
      break;
    }
    setState(1428);
    parameter_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndContext ------------------------------------------------------------------

ELDOParser::EndContext::EndContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::EndContext::NETLIST_END() {
  return getToken(ELDOParser::NETLIST_END, 0);
}

ELDOParser::End_of_lineContext* ELDOParser::EndContext::end_of_line() {
  return getRuleContext<ELDOParser::End_of_lineContext>(0);
}


size_t ELDOParser::EndContext::getRuleIndex() const {
  return ELDOParser::RuleEnd;
}

void ELDOParser::EndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd(this);
}

void ELDOParser::EndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd(this);
}


std::any ELDOParser::EndContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitEnd(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::EndContext* ELDOParser::end() {
  EndContext *_localctx = _tracker.createInstance<EndContext>(_ctx, getState());
  enterRule(_localctx, 316, ELDOParser::RuleEnd);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1430);
    match(ELDOParser::NETLIST_END);
    setState(1431);
    end_of_line();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

ELDOParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Expression_unaryContext* ELDOParser::ExpressionContext::expression_unary() {
  return getRuleContext<ELDOParser::Expression_unaryContext>(0);
}

ELDOParser::Expression_function_callContext* ELDOParser::ExpressionContext::expression_function_call() {
  return getRuleContext<ELDOParser::Expression_function_callContext>(0);
}

ELDOParser::Expression_listContext* ELDOParser::ExpressionContext::expression_list() {
  return getRuleContext<ELDOParser::Expression_listContext>(0);
}

ELDOParser::Expression_atomContext* ELDOParser::ExpressionContext::expression_atom() {
  return getRuleContext<ELDOParser::Expression_atomContext>(0);
}

std::vector<ELDOParser::ExpressionContext *> ELDOParser::ExpressionContext::expression() {
  return getRuleContexts<ELDOParser::ExpressionContext>();
}

ELDOParser::ExpressionContext* ELDOParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<ELDOParser::ExpressionContext>(i);
}

tree::TerminalNode* ELDOParser::ExpressionContext::QUESTION_MARK() {
  return getToken(ELDOParser::QUESTION_MARK, 0);
}

tree::TerminalNode* ELDOParser::ExpressionContext::COLON() {
  return getToken(ELDOParser::COLON, 0);
}

tree::TerminalNode* ELDOParser::ExpressionContext::OPEN_CURLY() {
  return getToken(ELDOParser::OPEN_CURLY, 0);
}

tree::TerminalNode* ELDOParser::ExpressionContext::CLOSE_CURLY() {
  return getToken(ELDOParser::CLOSE_CURLY, 0);
}

ELDOParser::Expression_operatorContext* ELDOParser::ExpressionContext::expression_operator() {
  return getRuleContext<ELDOParser::Expression_operatorContext>(0);
}


size_t ELDOParser::ExpressionContext::getRuleIndex() const {
  return ELDOParser::RuleExpression;
}

void ELDOParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void ELDOParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


std::any ELDOParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


ELDOParser::ExpressionContext* ELDOParser::expression() {
   return expression(0);
}

ELDOParser::ExpressionContext* ELDOParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ELDOParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  ELDOParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 318;
  enterRecursionRule(_localctx, 318, ELDOParser::RuleExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1438);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx)) {
    case 1: {
      setState(1434);
      expression_unary();
      break;
    }

    case 2: {
      setState(1435);
      expression_function_call();
      break;
    }

    case 3: {
      setState(1436);
      expression_list();
      break;
    }

    case 4: {
      setState(1437);
      expression_atom();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1458);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1456);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(1440);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(1441);
          match(ELDOParser::QUESTION_MARK);
          setState(1442);
          expression(0);
          setState(1443);
          match(ELDOParser::COLON);
          setState(1444);
          expression(2);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(1446);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(1447);
          match(ELDOParser::OPEN_CURLY);
          setState(1448);
          expression(0);
          setState(1449);
          match(ELDOParser::CLOSE_CURLY);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(1451);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(1452);
          expression_operator();
          setState(1454);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
          case 1: {
            setState(1453);
            expression(0);
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(1460);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Expression_unaryContext ------------------------------------------------------------------

ELDOParser::Expression_unaryContext::Expression_unaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::ExpressionContext* ELDOParser::Expression_unaryContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}

tree::TerminalNode* ELDOParser::Expression_unaryContext::PLUS() {
  return getToken(ELDOParser::PLUS, 0);
}

tree::TerminalNode* ELDOParser::Expression_unaryContext::MINUS() {
  return getToken(ELDOParser::MINUS, 0);
}


size_t ELDOParser::Expression_unaryContext::getRuleIndex() const {
  return ELDOParser::RuleExpression_unary;
}

void ELDOParser::Expression_unaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_unary(this);
}

void ELDOParser::Expression_unaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_unary(this);
}


std::any ELDOParser::Expression_unaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitExpression_unary(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Expression_unaryContext* ELDOParser::expression_unary() {
  Expression_unaryContext *_localctx = _tracker.createInstance<Expression_unaryContext>(_ctx, getState());
  enterRule(_localctx, 320, ELDOParser::RuleExpression_unary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1461);
    _la = _input->LA(1);
    if (!(_la == ELDOParser::PLUS

    || _la == ELDOParser::MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1462);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_function_callContext ------------------------------------------------------------------

ELDOParser::Expression_function_callContext::Expression_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::MOD() {
  return getToken(ELDOParser::MOD, 0);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::MODEL() {
  return getToken(ELDOParser::MODEL, 0);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::OPEN_ROUND() {
  return getToken(ELDOParser::OPEN_ROUND, 0);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::OPEN_CURLY() {
  return getToken(ELDOParser::OPEN_CURLY, 0);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::OPEN_SQUARE() {
  return getToken(ELDOParser::OPEN_SQUARE, 0);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::CLOSE_ROUND() {
  return getToken(ELDOParser::CLOSE_ROUND, 0);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::CLOSE_CURLY() {
  return getToken(ELDOParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::CLOSE_SQUARE() {
  return getToken(ELDOParser::CLOSE_SQUARE, 0);
}

std::vector<ELDOParser::ExpressionContext *> ELDOParser::Expression_function_callContext::expression() {
  return getRuleContexts<ELDOParser::ExpressionContext>();
}

ELDOParser::ExpressionContext* ELDOParser::Expression_function_callContext::expression(size_t i) {
  return getRuleContext<ELDOParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ELDOParser::Expression_function_callContext::COMMA() {
  return getTokens(ELDOParser::COMMA);
}

tree::TerminalNode* ELDOParser::Expression_function_callContext::COMMA(size_t i) {
  return getToken(ELDOParser::COMMA, i);
}


size_t ELDOParser::Expression_function_callContext::getRuleIndex() const {
  return ELDOParser::RuleExpression_function_call;
}

void ELDOParser::Expression_function_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_function_call(this);
}

void ELDOParser::Expression_function_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_function_call(this);
}


std::any ELDOParser::Expression_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitExpression_function_call(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Expression_function_callContext* ELDOParser::expression_function_call() {
  Expression_function_callContext *_localctx = _tracker.createInstance<Expression_function_callContext>(_ctx, getState());
  enterRule(_localctx, 322, ELDOParser::RuleExpression_function_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1464);
    _la = _input->LA(1);
    if (!(_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL || _la == ELDOParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1465);
    _la = _input->LA(1);
    if (!(((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 21) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1470); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1466);
      expression(0);
      setState(1468);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ELDOParser::COMMA) {
        setState(1467);
        match(ELDOParser::COMMA);
      }
      setState(1472); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL || ((((_la - 138) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 138)) & 1946157227) != 0));
    setState(1474);
    _la = _input->LA(1);
    if (!(((((_la - 142) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 142)) & 21) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_listContext ------------------------------------------------------------------

ELDOParser::Expression_listContext::Expression_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Expression_listContext::OPEN_ROUND() {
  return getToken(ELDOParser::OPEN_ROUND, 0);
}

tree::TerminalNode* ELDOParser::Expression_listContext::OPEN_CURLY() {
  return getToken(ELDOParser::OPEN_CURLY, 0);
}

tree::TerminalNode* ELDOParser::Expression_listContext::OPEN_SQUARE() {
  return getToken(ELDOParser::OPEN_SQUARE, 0);
}

tree::TerminalNode* ELDOParser::Expression_listContext::CLOSE_ROUND() {
  return getToken(ELDOParser::CLOSE_ROUND, 0);
}

tree::TerminalNode* ELDOParser::Expression_listContext::CLOSE_CURLY() {
  return getToken(ELDOParser::CLOSE_CURLY, 0);
}

tree::TerminalNode* ELDOParser::Expression_listContext::CLOSE_SQUARE() {
  return getToken(ELDOParser::CLOSE_SQUARE, 0);
}

std::vector<ELDOParser::ExpressionContext *> ELDOParser::Expression_listContext::expression() {
  return getRuleContexts<ELDOParser::ExpressionContext>();
}

ELDOParser::ExpressionContext* ELDOParser::Expression_listContext::expression(size_t i) {
  return getRuleContext<ELDOParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ELDOParser::Expression_listContext::COMMA() {
  return getTokens(ELDOParser::COMMA);
}

tree::TerminalNode* ELDOParser::Expression_listContext::COMMA(size_t i) {
  return getToken(ELDOParser::COMMA, i);
}


size_t ELDOParser::Expression_listContext::getRuleIndex() const {
  return ELDOParser::RuleExpression_list;
}

void ELDOParser::Expression_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_list(this);
}

void ELDOParser::Expression_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_list(this);
}


std::any ELDOParser::Expression_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitExpression_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Expression_listContext* ELDOParser::expression_list() {
  Expression_listContext *_localctx = _tracker.createInstance<Expression_listContext>(_ctx, getState());
  enterRule(_localctx, 324, ELDOParser::RuleExpression_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1476);
    _la = _input->LA(1);
    if (!(((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 21) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1481); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1477);
      expression(0);
      setState(1479);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ELDOParser::COMMA) {
        setState(1478);
        match(ELDOParser::COMMA);
      }
      setState(1483); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ELDOParser::MOD

    || _la == ELDOParser::MODEL || ((((_la - 138) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 138)) & 1946157227) != 0));
    setState(1485);
    _la = _input->LA(1);
    if (!(((((_la - 142) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 142)) & 21) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_operatorContext ------------------------------------------------------------------

ELDOParser::Expression_operatorContext::Expression_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::PLUS() {
  return getToken(ELDOParser::PLUS, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::MINUS() {
  return getToken(ELDOParser::MINUS, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::STAR() {
  return getToken(ELDOParser::STAR, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::SLASH() {
  return getToken(ELDOParser::SLASH, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LOGIC_AND() {
  return getToken(ELDOParser::LOGIC_AND, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LOGIC_BITWISE_AND() {
  return getToken(ELDOParser::LOGIC_BITWISE_AND, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LOGIC_OR() {
  return getToken(ELDOParser::LOGIC_OR, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LOGIC_BITWISE_OR() {
  return getToken(ELDOParser::LOGIC_BITWISE_OR, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LOGIC_EQUAL() {
  return getToken(ELDOParser::LOGIC_EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LOGIC_NOT_EQUAL() {
  return getToken(ELDOParser::LOGIC_NOT_EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LOGIC_XOR() {
  return getToken(ELDOParser::LOGIC_XOR, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LESS_THAN() {
  return getToken(ELDOParser::LESS_THAN, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::LESS_THAN_EQUAL() {
  return getToken(ELDOParser::LESS_THAN_EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::GREATER_THAN() {
  return getToken(ELDOParser::GREATER_THAN, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::GREATER_THAN_EQUAL() {
  return getToken(ELDOParser::GREATER_THAN_EQUAL, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::EXCLAMATION_MARK() {
  return getToken(ELDOParser::EXCLAMATION_MARK, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::BITWISE_SHIFT_LEFT() {
  return getToken(ELDOParser::BITWISE_SHIFT_LEFT, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::BITWISE_SHIFT_RIGHT() {
  return getToken(ELDOParser::BITWISE_SHIFT_RIGHT, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::POWER_OPERATOR() {
  return getToken(ELDOParser::POWER_OPERATOR, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::CARET() {
  return getToken(ELDOParser::CARET, 0);
}

tree::TerminalNode* ELDOParser::Expression_operatorContext::PERCENT() {
  return getToken(ELDOParser::PERCENT, 0);
}


size_t ELDOParser::Expression_operatorContext::getRuleIndex() const {
  return ELDOParser::RuleExpression_operator;
}

void ELDOParser::Expression_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_operator(this);
}

void ELDOParser::Expression_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_operator(this);
}


std::any ELDOParser::Expression_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitExpression_operator(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Expression_operatorContext* ELDOParser::expression_operator() {
  Expression_operatorContext *_localctx = _tracker.createInstance<Expression_operatorContext>(_ctx, getState());
  enterRule(_localctx, 326, ELDOParser::RuleExpression_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1487);
    _la = _input->LA(1);
    if (!(((((_la - 118) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 118)) & 13469024845823) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_atomContext ------------------------------------------------------------------

ELDOParser::Expression_atomContext::Expression_atomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Expression_atomContext::NUMBER() {
  return getToken(ELDOParser::NUMBER, 0);
}

tree::TerminalNode* ELDOParser::Expression_atomContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::Expression_atomContext::STRING() {
  return getToken(ELDOParser::STRING, 0);
}

tree::TerminalNode* ELDOParser::Expression_atomContext::PERCENTAGE() {
  return getToken(ELDOParser::PERCENTAGE, 0);
}


size_t ELDOParser::Expression_atomContext::getRuleIndex() const {
  return ELDOParser::RuleExpression_atom;
}

void ELDOParser::Expression_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_atom(this);
}

void ELDOParser::Expression_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_atom(this);
}


std::any ELDOParser::Expression_atomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitExpression_atom(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Expression_atomContext* ELDOParser::expression_atom() {
  Expression_atomContext *_localctx = _tracker.createInstance<Expression_atomContext>(_ctx, getState());
  enterRule(_localctx, 328, ELDOParser::RuleExpression_atom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1489);
    _la = _input->LA(1);
    if (!(((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & 29) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_listContext ------------------------------------------------------------------

ELDOParser::Node_listContext::Node_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::Node_list_itemContext *> ELDOParser::Node_listContext::node_list_item() {
  return getRuleContexts<ELDOParser::Node_list_itemContext>();
}

ELDOParser::Node_list_itemContext* ELDOParser::Node_listContext::node_list_item(size_t i) {
  return getRuleContext<ELDOParser::Node_list_itemContext>(i);
}

std::vector<tree::TerminalNode *> ELDOParser::Node_listContext::COMMA() {
  return getTokens(ELDOParser::COMMA);
}

tree::TerminalNode* ELDOParser::Node_listContext::COMMA(size_t i) {
  return getToken(ELDOParser::COMMA, i);
}

tree::TerminalNode* ELDOParser::Node_listContext::OPEN_ROUND() {
  return getToken(ELDOParser::OPEN_ROUND, 0);
}

tree::TerminalNode* ELDOParser::Node_listContext::CLOSE_ROUND() {
  return getToken(ELDOParser::CLOSE_ROUND, 0);
}


size_t ELDOParser::Node_listContext::getRuleIndex() const {
  return ELDOParser::RuleNode_list;
}

void ELDOParser::Node_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_list(this);
}

void ELDOParser::Node_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_list(this);
}


std::any ELDOParser::Node_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNode_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Node_listContext* ELDOParser::node_list() {
  Node_listContext *_localctx = _tracker.createInstance<Node_listContext>(_ctx, getState());
  enterRule(_localctx, 330, ELDOParser::RuleNode_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1510);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ELDOParser::NUMBER:
      case ELDOParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1495); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1491);
                  node_list_item();
                  setState(1493);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == ELDOParser::COMMA) {
                    setState(1492);
                    match(ELDOParser::COMMA);
                  }
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1497); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case ELDOParser::OPEN_ROUND: {
        enterOuterAlt(_localctx, 2);
        setState(1499);
        match(ELDOParser::OPEN_ROUND);
        setState(1504); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1500);
          node_list_item();
          setState(1502);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == ELDOParser::COMMA) {
            setState(1501);
            match(ELDOParser::COMMA);
          }
          setState(1506); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == ELDOParser::NUMBER

        || _la == ELDOParser::ID);
        setState(1508);
        match(ELDOParser::CLOSE_ROUND);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_list_itemContext ------------------------------------------------------------------

ELDOParser::Node_list_itemContext::Node_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::NodeContext* ELDOParser::Node_list_itemContext::node() {
  return getRuleContext<ELDOParser::NodeContext>(0);
}

ELDOParser::Node_mappingContext* ELDOParser::Node_list_itemContext::node_mapping() {
  return getRuleContext<ELDOParser::Node_mappingContext>(0);
}


size_t ELDOParser::Node_list_itemContext::getRuleIndex() const {
  return ELDOParser::RuleNode_list_item;
}

void ELDOParser::Node_list_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_list_item(this);
}

void ELDOParser::Node_list_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_list_item(this);
}


std::any ELDOParser::Node_list_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNode_list_item(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Node_list_itemContext* ELDOParser::node_list_item() {
  Node_list_itemContext *_localctx = _tracker.createInstance<Node_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 332, ELDOParser::RuleNode_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1514);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1512);
      node();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1513);
      node_mapping();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Node_mappingContext ------------------------------------------------------------------

ELDOParser::Node_mappingContext::Node_mappingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ELDOParser::NodeContext *> ELDOParser::Node_mappingContext::node() {
  return getRuleContexts<ELDOParser::NodeContext>();
}

ELDOParser::NodeContext* ELDOParser::Node_mappingContext::node(size_t i) {
  return getRuleContext<ELDOParser::NodeContext>(i);
}

tree::TerminalNode* ELDOParser::Node_mappingContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}


size_t ELDOParser::Node_mappingContext::getRuleIndex() const {
  return ELDOParser::RuleNode_mapping;
}

void ELDOParser::Node_mappingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode_mapping(this);
}

void ELDOParser::Node_mappingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode_mapping(this);
}


std::any ELDOParser::Node_mappingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNode_mapping(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Node_mappingContext* ELDOParser::node_mapping() {
  Node_mappingContext *_localctx = _tracker.createInstance<Node_mappingContext>(_ctx, getState());
  enterRule(_localctx, 334, ELDOParser::RuleNode_mapping);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1516);
    node();
    setState(1517);
    match(ELDOParser::EQUAL);
    setState(1518);
    node();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NodeContext ------------------------------------------------------------------

ELDOParser::NodeContext::NodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::NodeContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::NodeContext::NUMBER() {
  return getToken(ELDOParser::NUMBER, 0);
}

tree::TerminalNode* ELDOParser::NodeContext::DOT() {
  return getToken(ELDOParser::DOT, 0);
}

ELDOParser::NodeContext* ELDOParser::NodeContext::node() {
  return getRuleContext<ELDOParser::NodeContext>(0);
}


size_t ELDOParser::NodeContext::getRuleIndex() const {
  return ELDOParser::RuleNode;
}

void ELDOParser::NodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNode(this);
}

void ELDOParser::NodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNode(this);
}


std::any ELDOParser::NodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitNode(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::NodeContext* ELDOParser::node() {
  NodeContext *_localctx = _tracker.createInstance<NodeContext>(_ctx, getState());
  enterRule(_localctx, 336, ELDOParser::RuleNode);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1520);
    _la = _input->LA(1);
    if (!(_la == ELDOParser::NUMBER

    || _la == ELDOParser::ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1523);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::DOT) {
      setState(1521);
      match(ELDOParser::DOT);
      setState(1522);
      node();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_listContext ------------------------------------------------------------------

ELDOParser::Parameter_listContext::Parameter_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Parameter_listContext::PARAM_LIST_START() {
  return getToken(ELDOParser::PARAM_LIST_START, 0);
}

tree::TerminalNode* ELDOParser::Parameter_listContext::OPEN_ROUND() {
  return getToken(ELDOParser::OPEN_ROUND, 0);
}

std::vector<ELDOParser::Parameter_list_itemContext *> ELDOParser::Parameter_listContext::parameter_list_item() {
  return getRuleContexts<ELDOParser::Parameter_list_itemContext>();
}

ELDOParser::Parameter_list_itemContext* ELDOParser::Parameter_listContext::parameter_list_item(size_t i) {
  return getRuleContext<ELDOParser::Parameter_list_itemContext>(i);
}

tree::TerminalNode* ELDOParser::Parameter_listContext::CLOSE_ROUND() {
  return getToken(ELDOParser::CLOSE_ROUND, 0);
}


size_t ELDOParser::Parameter_listContext::getRuleIndex() const {
  return ELDOParser::RuleParameter_list;
}

void ELDOParser::Parameter_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_list(this);
}

void ELDOParser::Parameter_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_list(this);
}


std::any ELDOParser::Parameter_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitParameter_list(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Parameter_listContext* ELDOParser::parameter_list() {
  Parameter_listContext *_localctx = _tracker.createInstance<Parameter_listContext>(_ctx, getState());
  enterRule(_localctx, 338, ELDOParser::RuleParameter_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1526);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::PARAM_LIST_START) {
      setState(1525);
      match(ELDOParser::PARAM_LIST_START);
    }
    setState(1529);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(1528);
      match(ELDOParser::OPEN_ROUND);
      break;
    }

    default:
      break;
    }
    setState(1532); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1531);
              parameter_list_item();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1534); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(1537);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::CLOSE_ROUND) {
      setState(1536);
      match(ELDOParser::CLOSE_ROUND);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_list_itemContext ------------------------------------------------------------------

ELDOParser::Parameter_list_itemContext::Parameter_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::ParameterContext* ELDOParser::Parameter_list_itemContext::parameter() {
  return getRuleContext<ELDOParser::ParameterContext>(0);
}


size_t ELDOParser::Parameter_list_itemContext::getRuleIndex() const {
  return ELDOParser::RuleParameter_list_item;
}

void ELDOParser::Parameter_list_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_list_item(this);
}

void ELDOParser::Parameter_list_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_list_item(this);
}


std::any ELDOParser::Parameter_list_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitParameter_list_item(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Parameter_list_itemContext* ELDOParser::parameter_list_item() {
  Parameter_list_itemContext *_localctx = _tracker.createInstance<Parameter_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 340, ELDOParser::RuleParameter_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1539);
    parameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

ELDOParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Parameter_lhsContext* ELDOParser::ParameterContext::parameter_lhs() {
  return getRuleContext<ELDOParser::Parameter_lhsContext>(0);
}

ELDOParser::Parameter_rhsContext* ELDOParser::ParameterContext::parameter_rhs() {
  return getRuleContext<ELDOParser::Parameter_rhsContext>(0);
}


size_t ELDOParser::ParameterContext::getRuleIndex() const {
  return ELDOParser::RuleParameter;
}

void ELDOParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void ELDOParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}


std::any ELDOParser::ParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitParameter(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::ParameterContext* ELDOParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 342, ELDOParser::RuleParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1541);
    parameter_lhs();
    setState(1543);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ELDOParser::EQUAL) {
      setState(1542);
      parameter_rhs();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_lhsContext ------------------------------------------------------------------

ELDOParser::Parameter_lhsContext::Parameter_lhsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Expression_function_callContext* ELDOParser::Parameter_lhsContext::expression_function_call() {
  return getRuleContext<ELDOParser::Expression_function_callContext>(0);
}

ELDOParser::Expression_listContext* ELDOParser::Parameter_lhsContext::expression_list() {
  return getRuleContext<ELDOParser::Expression_listContext>(0);
}

tree::TerminalNode* ELDOParser::Parameter_lhsContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::Parameter_lhsContext::MOD() {
  return getToken(ELDOParser::MOD, 0);
}

tree::TerminalNode* ELDOParser::Parameter_lhsContext::MODEL() {
  return getToken(ELDOParser::MODEL, 0);
}


size_t ELDOParser::Parameter_lhsContext::getRuleIndex() const {
  return ELDOParser::RuleParameter_lhs;
}

void ELDOParser::Parameter_lhsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_lhs(this);
}

void ELDOParser::Parameter_lhsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_lhs(this);
}


std::any ELDOParser::Parameter_lhsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitParameter_lhs(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Parameter_lhsContext* ELDOParser::parameter_lhs() {
  Parameter_lhsContext *_localctx = _tracker.createInstance<Parameter_lhsContext>(_ctx, getState());
  enterRule(_localctx, 344, ELDOParser::RuleParameter_lhs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1548);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1545);
      expression_function_call();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1546);
      expression_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1547);
      _la = _input->LA(1);
      if (!(_la == ELDOParser::MOD

      || _la == ELDOParser::MODEL || _la == ELDOParser::ID)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_rhsContext ------------------------------------------------------------------

ELDOParser::Parameter_rhsContext::Parameter_rhsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Parameter_rhsContext::EQUAL() {
  return getToken(ELDOParser::EQUAL, 0);
}

ELDOParser::ExpressionContext* ELDOParser::Parameter_rhsContext::expression() {
  return getRuleContext<ELDOParser::ExpressionContext>(0);
}


size_t ELDOParser::Parameter_rhsContext::getRuleIndex() const {
  return ELDOParser::RuleParameter_rhs;
}

void ELDOParser::Parameter_rhsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_rhs(this);
}

void ELDOParser::Parameter_rhsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_rhs(this);
}


std::any ELDOParser::Parameter_rhsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitParameter_rhs(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Parameter_rhsContext* ELDOParser::parameter_rhs() {
  Parameter_rhsContext *_localctx = _tracker.createInstance<Parameter_rhsContext>(_ctx, getState());
  enterRule(_localctx, 346, ELDOParser::RuleParameter_rhs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1550);
    match(ELDOParser::EQUAL);
    setState(1551);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilepathContext ------------------------------------------------------------------

ELDOParser::FilepathContext::FilepathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ELDOParser::Filepath_elementContext* ELDOParser::FilepathContext::filepath_element() {
  return getRuleContext<ELDOParser::Filepath_elementContext>(0);
}


size_t ELDOParser::FilepathContext::getRuleIndex() const {
  return ELDOParser::RuleFilepath;
}

void ELDOParser::FilepathContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilepath(this);
}

void ELDOParser::FilepathContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilepath(this);
}


std::any ELDOParser::FilepathContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitFilepath(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::FilepathContext* ELDOParser::filepath() {
  FilepathContext *_localctx = _tracker.createInstance<FilepathContext>(_ctx, getState());
  enterRule(_localctx, 348, ELDOParser::RuleFilepath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1553);
    filepath_element();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Filepath_elementContext ------------------------------------------------------------------

ELDOParser::Filepath_elementContext::Filepath_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::Filepath_elementContext::ID() {
  return getToken(ELDOParser::ID, 0);
}

tree::TerminalNode* ELDOParser::Filepath_elementContext::STRING() {
  return getToken(ELDOParser::STRING, 0);
}

ELDOParser::Filepath_elementContext* ELDOParser::Filepath_elementContext::filepath_element() {
  return getRuleContext<ELDOParser::Filepath_elementContext>(0);
}

std::vector<tree::TerminalNode *> ELDOParser::Filepath_elementContext::APEX() {
  return getTokens(ELDOParser::APEX);
}

tree::TerminalNode* ELDOParser::Filepath_elementContext::APEX(size_t i) {
  return getToken(ELDOParser::APEX, i);
}

tree::TerminalNode* ELDOParser::Filepath_elementContext::SLASH() {
  return getToken(ELDOParser::SLASH, 0);
}

tree::TerminalNode* ELDOParser::Filepath_elementContext::DOT() {
  return getToken(ELDOParser::DOT, 0);
}

tree::TerminalNode* ELDOParser::Filepath_elementContext::MINUS() {
  return getToken(ELDOParser::MINUS, 0);
}

tree::TerminalNode* ELDOParser::Filepath_elementContext::DOLLAR() {
  return getToken(ELDOParser::DOLLAR, 0);
}


size_t ELDOParser::Filepath_elementContext::getRuleIndex() const {
  return ELDOParser::RuleFilepath_element;
}

void ELDOParser::Filepath_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilepath_element(this);
}

void ELDOParser::Filepath_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilepath_element(this);
}


std::any ELDOParser::Filepath_elementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitFilepath_element(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::Filepath_elementContext* ELDOParser::filepath_element() {
  Filepath_elementContext *_localctx = _tracker.createInstance<Filepath_elementContext>(_ctx, getState());
  enterRule(_localctx, 350, ELDOParser::RuleFilepath_element);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1571);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1555);
      match(ELDOParser::ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1556);
      match(ELDOParser::STRING);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1557);
      match(ELDOParser::ID);
      setState(1558);
      filepath_element();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1559);
      match(ELDOParser::APEX);
      setState(1560);
      filepath_element();
      setState(1561);
      match(ELDOParser::APEX);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1563);
      match(ELDOParser::SLASH);
      setState(1564);
      filepath_element();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1565);
      match(ELDOParser::DOT);
      setState(1566);
      filepath_element();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1567);
      match(ELDOParser::MINUS);
      setState(1568);
      filepath_element();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1569);
      match(ELDOParser::DOLLAR);
      setState(1570);
      filepath_element();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_of_lineContext ------------------------------------------------------------------

ELDOParser::End_of_lineContext::End_of_lineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ELDOParser::End_of_lineContext::EOF() {
  return getToken(ELDOParser::EOF, 0);
}

std::vector<tree::TerminalNode *> ELDOParser::End_of_lineContext::NL() {
  return getTokens(ELDOParser::NL);
}

tree::TerminalNode* ELDOParser::End_of_lineContext::NL(size_t i) {
  return getToken(ELDOParser::NL, i);
}


size_t ELDOParser::End_of_lineContext::getRuleIndex() const {
  return ELDOParser::RuleEnd_of_line;
}

void ELDOParser::End_of_lineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd_of_line(this);
}

void ELDOParser::End_of_lineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ELDOParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd_of_line(this);
}


std::any ELDOParser::End_of_lineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ELDOParserVisitor*>(visitor))
    return parserVisitor->visitEnd_of_line(this);
  else
    return visitor->visitChildren(this);
}

ELDOParser::End_of_lineContext* ELDOParser::end_of_line() {
  End_of_lineContext *_localctx = _tracker.createInstance<End_of_lineContext>(_ctx, getState());
  enterRule(_localctx, 352, ELDOParser::RuleEnd_of_line);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1580);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx)) {
    case 1: {
      setState(1576);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1573);
          match(ELDOParser::NL); 
        }
        setState(1578);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx);
      }
      break;
    }

    case 2: {
      setState(1579);
      match(ELDOParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool ELDOParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 159: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool ELDOParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);
    case 1: return precpred(_ctx, 3);
    case 2: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

void ELDOParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  eldoparserParserInitialize();
#else
  ::antlr4::internal::call_once(eldoparserParserOnceFlag, eldoparserParserInitialize);
#endif
}
